{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "eaf91bb7_68bb55b3",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 10,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2024-05-30T16:40:51Z",
      "side": 1,
      "message": "This may not need to be addressed as part of this patch.  In a mutual aggregation system the URIs will change depending on which aggregator you are querying.  Aggregation prefixes will not be applied to URIs that come from the aggregating BMC.\n\nIs the expectation that URIs will be consistent regardless of which BMC is queried as the aggregator?",
      "range": {
        "startLine": 9,
        "startChar": 55,
        "endLine": 10,
        "endChar": 43
      },
      "revId": "ab2880d4cb9fe9be18942047efb56a2f0b60b9bd",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dbd8381d_9b4b91fe",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 10,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-05-30T23:27:31Z",
      "side": 1,
      "message": "I would say we should actively try to avoid that requirement if at all possible;  Syncronizing header names seems like a pain, although could be doable now that",
      "parentUuid": "eaf91bb7_68bb55b3",
      "range": {
        "startLine": 9,
        "startChar": 55,
        "endLine": 10,
        "endChar": 43
      },
      "revId": "ab2880d4cb9fe9be18942047efb56a2f0b60b9bd",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2bf9764b_aacf6519",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 10,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2024-05-31T00:38:39Z",
      "side": 1,
      "message": "It would be a huge pain.  I\u0027m also in favor of not going down that road.\n\nI think you\u0027d hit a similar issue that arose during implementing Redfish Aggregation.  The original thought was resources on the aggregating BMC would also get an aggregation prefix: `main_`.  That meant the current URIs would change depending on if aggregation was enabled.\n\nThat was not desirable so the idea was abandoned.  If the URIs need to be consistent regardless of aggregator then I feel like we\u0027d end up having to modify URIs on the aggregating BMC.",
      "parentUuid": "dbd8381d_9b4b91fe",
      "range": {
        "startLine": 9,
        "startChar": 55,
        "endLine": 10,
        "endChar": 43
      },
      "revId": "ab2880d4cb9fe9be18942047efb56a2f0b60b9bd",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6a8d6a51_c9ba9900",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 10,
      "author": {
        "id": 1001762
      },
      "writtenOn": "2024-05-31T04:40:44Z",
      "side": 1,
      "message": "I am not clear about the discussion here. I don\u0027t see any issue in making aggregation enabled in all BMCs. There is no change in the static redfish url. An external client will make usual top level request to any BMC. The bmc will have its own private list of satellite information. So it can gather and attach prefix (a unique name of satellite BMC) to urls returned from satellite. So the clients will be using same BMC for satellite resources with prefixed urls. It will works as usual. Yes we need to worry if client switches the  BMC and uses prefixed urls obtained from previous BMC. As long as we can uniquely identify BMC from prefix name, then it is just an easier implementation to test if the incoming prefix is current BMC or not before forwarding.",
      "parentUuid": "2bf9764b_aacf6519",
      "range": {
        "startLine": 9,
        "startChar": 55,
        "endLine": 10,
        "endChar": 43
      },
      "revId": "ab2880d4cb9fe9be18942047efb56a2f0b60b9bd",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b510d528_b6e5dfb8",
        "filename": "redfish-core/include/redfish_aggregator.hpp",
        "patchSetId": 3
      },
      "lineNbr": 1200,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2024-05-30T16:40:51Z",
      "side": 1,
      "message": "Your commit points out this breaks multi-level aggregation such as A aggregates B and B aggregates C.  I don\u0027t think we should break that functionality regardless of how widespread its use currently is.  Better to get it right the first time.\n\nCould we instead add a custom header to the aggregation request object which contains the identifiers of the BMCs that have been aggregated so far?  Those identifiers could be something like the `SCHEME://HOST:PORT` key used by the `connectionPools` in our internal `HttpClient`.\n\nAnother option is to use the aggregation prefix as the identifier.  That will require implementing generating aggregation prefixes.  Right now it\u0027s just hardcoded to always be `5B247A_`.  That\u0027ll likely need to be implemented regardless as part of enabling mutual aggregation.  It\u0027s not as useful if there can only be two BMCs in the entire system.\n\nThe flow would look something like this:\n\n1. Add the `SCHEME://HOST:PORT` of the aggregator\n2. Retrieve the satellite configs\n3. If the Satellite `SCHEME://HOST:PORT` is NOT in the header then add it and proceed with aggregation and forward the request\n4. Else don\u0027t forward the request since we\u0027ve already queried that satellite elsewhere in the chain.",
      "range": {
        "startLine": 1193,
        "startChar": 0,
        "endLine": 1200,
        "endChar": 9
      },
      "revId": "ab2880d4cb9fe9be18942047efb56a2f0b60b9bd",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c6c0b472_be1fb9ac",
        "filename": "redfish-core/include/redfish_aggregator.hpp",
        "patchSetId": 3
      },
      "lineNbr": 1200,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-05-30T23:27:31Z",
      "side": 1,
      "message": "I don\u0027t know if HOST:port works, because an aggregator might be accessing through a different host/port than the BMC thinks it\u0027s on.  We had a similar problem with trying to enforce the Location header. But maybe we could do something with UUID?  Send a header like \"aggregated from\" and the UUID.  If we ever see a UUID in the list that we\u0027re aggregating the satellite of, or see our own UUID in the list, refuse to aggregate?",
      "parentUuid": "b510d528_b6e5dfb8",
      "range": {
        "startLine": 1193,
        "startChar": 0,
        "endLine": 1200,
        "endChar": 9
      },
      "revId": "ab2880d4cb9fe9be18942047efb56a2f0b60b9bd",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6b33b000_11720fb8",
        "filename": "redfish-core/include/redfish_aggregator.hpp",
        "patchSetId": 3
      },
      "lineNbr": 1200,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2024-05-31T00:38:39Z",
      "side": 1,
      "message": "UUID could work.  We previously discussed using that as the seed for generating aggregation prefixes.\n\nWe\u0027ll need to warn the satellites as well though of all BMCs that the message is getting forwarded to.  Consider this setup:\n\n* A aggregates B \u0026 C\n* B aggregates A \u0026 C\n* C aggregates A \u0026 B\n\nLet\u0027s say we query A for `/redfish/v1/Chassis`.  That\u0027s a top level collection so A also needs to forward that request to B and C.  In that request we only include the UUID of A.\n\nB aggregates A \u0026 C.  B would think it needs to forward the request to C since the only UUID in the header is for A (who just sent the request).  Likewise, C would forward the request to B and ignore A.\n\nThe end result is the resources from B and C get included twice in the overall response in some form or fashion.\n```\nQuery -\u003e A -\u003e B -\u003e C\n          \\\n           -\u003e C -\u003e B\n```\n\nIf the original forwarded request from A contained the UUID for A as well as the ones for the destinations then B and C would not make redundant forwards since they know that \"something\" has already aggregated one of the BMCs they\u0027re aggregating.\n\nFor that to work each BMC will have to know the UUIDs of the BMCs they\u0027re aggregating in addition to their own.  I can think of two ways to make that happen:\n\n1. Each BMC makes an initial query to retrieve the UUID and decide if it should proceed with the actual aggregation.\n2. We let the BMCs cache their satellite configs and as part of that they retrieve the UUIDs from the satellites before normal operation actually begins.",
      "parentUuid": "c6c0b472_be1fb9ac",
      "range": {
        "startLine": 1193,
        "startChar": 0,
        "endLine": 1200,
        "endChar": 9
      },
      "revId": "ab2880d4cb9fe9be18942047efb56a2f0b60b9bd",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "244c1ef8_013adf22",
        "filename": "redfish-core/include/redfish_aggregator.hpp",
        "patchSetId": 3
      },
      "lineNbr": 1200,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-05-31T00:44:51Z",
      "side": 1,
      "message": "\u003e UUID could work.  We previously discussed using that as the seed for generating aggregation prefixes.\n\u003e \n\u003e We\u0027ll need to warn the satellites as well though of all BMCs that the message is getting forwarded to.  Consider this setup:\n\u003e \n\u003e * A aggregates B \u0026 C\n\u003e * B aggregates A \u0026 C\n\u003e * C aggregates A \u0026 B\n\u003e \n\u003e Let\u0027s say we query A for `/redfish/v1/Chassis`.  That\u0027s a top level collection so A also needs to forward that request to B and C.  In that request we only include the UUID of A.\n\u003e \n\u003e B aggregates A \u0026 C.  B would think it needs to forward the request to C since the only UUID in the header is for A (who just sent the request).  Likewise, C would forward the request to B and ignore A.\n\u003e \n\u003e The end result is the resources from B and C get included twice in the overall response in some form or fashion.\n\u003e ```\n\u003e Query -\u003e A -\u003e B -\u003e C\n\u003e           \\\n\u003e            -\u003e C -\u003e B\n\u003e ```\n\u003e \n\n\nUg...... the above made my brain hurt, but makes sense.  To support that kind of cluster topology we almost have to attach \"resource created by\" type metadata to every request.\n\n\u003e If the original forwarded request from A contained the UUID for A as well as the ones for the destinations then B and C would not make redundant forwards since they know that \"something\" has already aggregated one of the BMCs they\u0027re aggregating.\n\u003e \n\u003e For that to work each BMC will have to know the UUIDs of the BMCs they\u0027re aggregating in addition to their own.  I can think of two ways to make that happen:\n\u003e \n\u003e 1. Each BMC makes an initial query to retrieve the UUID and decide if it should proceed with the actual aggregation.\n\u003e 2. We let the BMCs cache their satellite configs and as part of that they retrieve the UUIDs from the satellites before normal operation actually begins.\n\nArguably we should be caching the sattelite UUID already, so I suspect this would be fine.\n\nAlternatively, maybe at startup, each aggregator builds that little map in memory, so that when it makes requests we can pick a path?  IDK;  We should really get multiple satellites working first.",
      "parentUuid": "6b33b000_11720fb8",
      "range": {
        "startLine": 1193,
        "startChar": 0,
        "endLine": 1200,
        "endChar": 9
      },
      "revId": "ab2880d4cb9fe9be18942047efb56a2f0b60b9bd",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "97db84d0_8831c487",
        "filename": "redfish-core/include/redfish_aggregator.hpp",
        "patchSetId": 3
      },
      "lineNbr": 1200,
      "author": {
        "id": 1001762
      },
      "writtenOn": "2024-05-31T05:37:19Z",
      "side": 1,
      "message": "Query -\u003e A -\u003e B -\u003e C\n          \\\n           -\u003e C -\u003e B\nAssuming we have uuid for BMCs available.\nCan\u0027t A decide what to put in request header to avoid this duplicates. \n1) When we forward request to B , we add C uuid in excluding list. \n2) Forward for C is inverse of 1.\nSo this will avoid duplicate aggregation right? The extra cost is in copying request for siblings.",
      "parentUuid": "244c1ef8_013adf22",
      "range": {
        "startLine": 1193,
        "startChar": 0,
        "endLine": 1200,
        "endChar": 9
      },
      "revId": "ab2880d4cb9fe9be18942047efb56a2f0b60b9bd",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "51592508_6a65a8fc",
        "filename": "redfish-core/include/redfish_aggregator.hpp",
        "patchSetId": 3
      },
      "lineNbr": 1200,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-05-31T21:41:54Z",
      "side": 1,
      "message": "\u003e Query -\u003e A -\u003e B -\u003e C\n\u003e           \\\n\u003e            -\u003e C -\u003e B\n\u003e Assuming we have uuid for BMCs available.\n\u003e Can\u0027t A decide what to put in request header to avoid this duplicates. \n\nA doesn\u0027t know which resources in a collection came from B, and which ones came from C.  Also, they\u0027re not unique URIs, the collections are merged, so there\u0027s not a single header we could use to know.\n\n\u003e 1) When we forward request to B , we add C uuid in excluding list. \n\u003e 2) Forward for C is inverse of 1.\n\u003e So this will avoid duplicate aggregation right? The extra cost is in copying request for siblings.\n\n\nI don\u0027t think it avoids it\n\nA sets As UUID forwards to B and C\nAt this point B doesn\u0027t know if it should forward to C or not, and there\u0027s no UUID to compare to in the request, because we only know B and C\n\n\n\n\nIt could be we\u0027re overcomplicating it at this point.  Do we have any designs that require loops like that?",
      "parentUuid": "97db84d0_8831c487",
      "range": {
        "startLine": 1193,
        "startChar": 0,
        "endLine": 1200,
        "endChar": 9
      },
      "revId": "ab2880d4cb9fe9be18942047efb56a2f0b60b9bd",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}