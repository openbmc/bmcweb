{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "eaf91bb7_68bb55b3",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 10,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2024-05-30T16:40:51Z",
      "side": 1,
      "message": "This may not need to be addressed as part of this patch.  In a mutual aggregation system the URIs will change depending on which aggregator you are querying.  Aggregation prefixes will not be applied to URIs that come from the aggregating BMC.\n\nIs the expectation that URIs will be consistent regardless of which BMC is queried as the aggregator?",
      "range": {
        "startLine": 9,
        "startChar": 55,
        "endLine": 10,
        "endChar": 43
      },
      "revId": "ab2880d4cb9fe9be18942047efb56a2f0b60b9bd",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dbd8381d_9b4b91fe",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 10,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-05-30T23:27:31Z",
      "side": 1,
      "message": "I would say we should actively try to avoid that requirement if at all possible;  Syncronizing header names seems like a pain, although could be doable now that",
      "parentUuid": "eaf91bb7_68bb55b3",
      "range": {
        "startLine": 9,
        "startChar": 55,
        "endLine": 10,
        "endChar": 43
      },
      "revId": "ab2880d4cb9fe9be18942047efb56a2f0b60b9bd",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2bf9764b_aacf6519",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 10,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2024-05-31T00:38:39Z",
      "side": 1,
      "message": "It would be a huge pain.  I\u0027m also in favor of not going down that road.\n\nI think you\u0027d hit a similar issue that arose during implementing Redfish Aggregation.  The original thought was resources on the aggregating BMC would also get an aggregation prefix: `main_`.  That meant the current URIs would change depending on if aggregation was enabled.\n\nThat was not desirable so the idea was abandoned.  If the URIs need to be consistent regardless of aggregator then I feel like we\u0027d end up having to modify URIs on the aggregating BMC.",
      "parentUuid": "dbd8381d_9b4b91fe",
      "range": {
        "startLine": 9,
        "startChar": 55,
        "endLine": 10,
        "endChar": 43
      },
      "revId": "ab2880d4cb9fe9be18942047efb56a2f0b60b9bd",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6a8d6a51_c9ba9900",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 10,
      "author": {
        "id": 1001762
      },
      "writtenOn": "2024-05-31T04:40:44Z",
      "side": 1,
      "message": "I am not clear about the discussion here. I don\u0027t see any issue in making aggregation enabled in all BMCs. There is no change in the static redfish url. An external client will make usual top level request to any BMC. The bmc will have its own private list of satellite information. So it can gather and attach prefix (a unique name of satellite BMC) to urls returned from satellite. So the clients will be using same BMC for satellite resources with prefixed urls. It will works as usual. Yes we need to worry if client switches the  BMC and uses prefixed urls obtained from previous BMC. As long as we can uniquely identify BMC from prefix name, then it is just an easier implementation to test if the incoming prefix is current BMC or not before forwarding.",
      "parentUuid": "2bf9764b_aacf6519",
      "range": {
        "startLine": 9,
        "startChar": 55,
        "endLine": 10,
        "endChar": 43
      },
      "revId": "ab2880d4cb9fe9be18942047efb56a2f0b60b9bd",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d17ec3ee_b90ddf6f",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 10,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2024-06-04T01:40:41Z",
      "side": 1,
      "message": "\u003e Yes we need to worry if client switches the BMC and uses prefixed urls obtained from previous BMC. As long as we can uniquely identify BMC from prefix name, then it is just an easier implementation to test if the incoming prefix is current BMC or not before forwarding.\n\nYes, this scenario is the one I\u0027m saying we shouldn\u0027t support.  From the client\u0027s perspective querying a different BMC should be treated as if it\u0027s querying a completely new system.\n\nConsider a simple system where A aggregates B and B aggregates A.  Let\u0027s say each machine has two `Chassis` resources.  A has `Main` and `ExampleA`.  B has `Main` and `ExampleB`.\n\nIf support is added for multiple satellite BMCs then the aggregation prefix would likely become something like `{aggregation_prefix}_{Satellite_uuid}_`.  Right now it\u0027s just `{aggregation_prefix}_` which is `5B247A_`.\n\nHere\u0027s what you\u0027d see when querying Machine A\n```\n~# curl -s {MACH_A_IP}/redfish/v1/Chassis\n{\n  \"@odata.id\": \"/redfish/v1/Chassis\",\n  \"@odata.type\": \"#ChassisCollection.ChassisCollection\",\n  \"Members\": [\n    {\n      \"@odata.id\": \"/redfish/v1/Chassis/Main\"\n    },\n    {\n      \"@odata.id\": \"/redfish/v1/Chassis/ExampleA\"\n    },\n    {\n      \"@odata.id\": \"/redfish/v1/Chassis/{aggregation_prefix}_{B_uuid}_Main\"\n    },\n    {\n      \"@odata.id\": \"/redfish/v1/Chassis/{aggregation_prefix}_{B_uuid}_ExampleB\"\n    }\n  ],\n  \"Members@odata.count\": 4,\n  \"Name\": \"Chassis Collection\"\n}\n```\n\nHere\u0027s what you\u0027d see when querying Machine B\n```\n~# curl -s {MACH_B_IP}/redfish/v1/Chassis\n{\n  \"@odata.id\": \"/redfish/v1/Chassis\",\n  \"@odata.type\": \"#ChassisCollection.ChassisCollection\",\n  \"Members\": [\n    {\n      \"@odata.id\": \"/redfish/v1/Chassis/Main\"\n    },\n    {\n      \"@odata.id\": \"/redfish/v1/Chassis/ExampleB\"\n    },\n    {\n      \"@odata.id\": \"/redfish/v1/Chassis/{aggregation_prefix}_{A_uuid}_Main\"\n    },\n    {\n      \"@odata.id\": \"/redfish/v1/Chassis/{aggregation_prefix}_{A_uuid}_ExampleA\"\n    },\n  ],\n  \"Members@odata.count\": 4,\n  \"Name\": \"Chassis Collection\"\n}\n```\n\nYou get the same resources but they have different URIs depending on which BMC is queried.  I think that should be fine.  Things start getting really gross if instead you want the URIs to match regardless of which BMC was queried.\n\nBMCWeb at its core has to handle requests differently depending on whether or not it\u0027s meant for a satellite BMC.  That\u0027s denoted by the `{aggregation_prefix}_` in the URI.  That also guarantees that there will be a difference in the URIs of local resources vs aggregated resources.",
      "parentUuid": "6a8d6a51_c9ba9900",
      "range": {
        "startLine": 9,
        "startChar": 55,
        "endLine": 10,
        "endChar": 43
      },
      "revId": "ab2880d4cb9fe9be18942047efb56a2f0b60b9bd",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e566c6a4_608240cf",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 10,
      "author": {
        "id": 1001762
      },
      "writtenOn": "2024-06-05T04:13:07Z",
      "side": 1,
      "message": "I did not get it.\nWhat happens suppose client switches from Machine A to Machine B and uses the url obtained from Machine A to Machine B.\n### case 1\n   Use url /redfish/v1/Chassis/Main \n   ##### Desired result:\n   It get the details of machine B in response. Client cannot expect machine A data here, as he made the switch explicitly.\n   ##### Implementable?\n   \n   Yes it is implementable. I don\u0027t see why it will not work. \n\n### case 2\n   Use url /redfish/v1/Chassis/{aggregation_prefix}_{B_uuid}_Main\n   ##### Desired result\n   \n   Bmc can parse the uuid and recognise that it is directed to itself. So it can return the local response instead of forwarding.\n   \n   ##### Implementable?\n   \n   I don\u0027t see any problem in achieving it. Prerequisite for it is to have a dictionary of uuid to bmc mapping.",
      "parentUuid": "d17ec3ee_b90ddf6f",
      "range": {
        "startLine": 9,
        "startChar": 55,
        "endLine": 10,
        "endChar": 43
      },
      "revId": "ab2880d4cb9fe9be18942047efb56a2f0b60b9bd",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "11a8cfed_0b6a063d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 10,
      "author": {
        "id": 1001762
      },
      "writtenOn": "2026-02-12T04:07:04Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "e566c6a4_608240cf",
      "range": {
        "startLine": 9,
        "startChar": 55,
        "endLine": 10,
        "endChar": 43
      },
      "revId": "ab2880d4cb9fe9be18942047efb56a2f0b60b9bd",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "96ada8aa_ec801e2a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1001762
      },
      "writtenOn": "2024-06-13T11:29:32Z",
      "side": 1,
      "message": "In order to implement a generic solution, we should first support multiple satellite capabilities and an uuid assignment scheme for the BMCs for proper request forwarding and duplicate removals. So keeping it as WIP till dependencies are solved.",
      "revId": "ab2880d4cb9fe9be18942047efb56a2f0b60b9bd",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b510d528_b6e5dfb8",
        "filename": "redfish-core/include/redfish_aggregator.hpp",
        "patchSetId": 3
      },
      "lineNbr": 1200,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2024-05-30T16:40:51Z",
      "side": 1,
      "message": "Your commit points out this breaks multi-level aggregation such as A aggregates B and B aggregates C.  I don\u0027t think we should break that functionality regardless of how widespread its use currently is.  Better to get it right the first time.\n\nCould we instead add a custom header to the aggregation request object which contains the identifiers of the BMCs that have been aggregated so far?  Those identifiers could be something like the `SCHEME://HOST:PORT` key used by the `connectionPools` in our internal `HttpClient`.\n\nAnother option is to use the aggregation prefix as the identifier.  That will require implementing generating aggregation prefixes.  Right now it\u0027s just hardcoded to always be `5B247A_`.  That\u0027ll likely need to be implemented regardless as part of enabling mutual aggregation.  It\u0027s not as useful if there can only be two BMCs in the entire system.\n\nThe flow would look something like this:\n\n1. Add the `SCHEME://HOST:PORT` of the aggregator\n2. Retrieve the satellite configs\n3. If the Satellite `SCHEME://HOST:PORT` is NOT in the header then add it and proceed with aggregation and forward the request\n4. Else don\u0027t forward the request since we\u0027ve already queried that satellite elsewhere in the chain.",
      "range": {
        "startLine": 1193,
        "startChar": 0,
        "endLine": 1200,
        "endChar": 9
      },
      "revId": "ab2880d4cb9fe9be18942047efb56a2f0b60b9bd",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c6c0b472_be1fb9ac",
        "filename": "redfish-core/include/redfish_aggregator.hpp",
        "patchSetId": 3
      },
      "lineNbr": 1200,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-05-30T23:27:31Z",
      "side": 1,
      "message": "I don\u0027t know if HOST:port works, because an aggregator might be accessing through a different host/port than the BMC thinks it\u0027s on.  We had a similar problem with trying to enforce the Location header. But maybe we could do something with UUID?  Send a header like \"aggregated from\" and the UUID.  If we ever see a UUID in the list that we\u0027re aggregating the satellite of, or see our own UUID in the list, refuse to aggregate?",
      "parentUuid": "b510d528_b6e5dfb8",
      "range": {
        "startLine": 1193,
        "startChar": 0,
        "endLine": 1200,
        "endChar": 9
      },
      "revId": "ab2880d4cb9fe9be18942047efb56a2f0b60b9bd",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6b33b000_11720fb8",
        "filename": "redfish-core/include/redfish_aggregator.hpp",
        "patchSetId": 3
      },
      "lineNbr": 1200,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2024-05-31T00:38:39Z",
      "side": 1,
      "message": "UUID could work.  We previously discussed using that as the seed for generating aggregation prefixes.\n\nWe\u0027ll need to warn the satellites as well though of all BMCs that the message is getting forwarded to.  Consider this setup:\n\n* A aggregates B \u0026 C\n* B aggregates A \u0026 C\n* C aggregates A \u0026 B\n\nLet\u0027s say we query A for `/redfish/v1/Chassis`.  That\u0027s a top level collection so A also needs to forward that request to B and C.  In that request we only include the UUID of A.\n\nB aggregates A \u0026 C.  B would think it needs to forward the request to C since the only UUID in the header is for A (who just sent the request).  Likewise, C would forward the request to B and ignore A.\n\nThe end result is the resources from B and C get included twice in the overall response in some form or fashion.\n```\nQuery -\u003e A -\u003e B -\u003e C\n          \\\n           -\u003e C -\u003e B\n```\n\nIf the original forwarded request from A contained the UUID for A as well as the ones for the destinations then B and C would not make redundant forwards since they know that \"something\" has already aggregated one of the BMCs they\u0027re aggregating.\n\nFor that to work each BMC will have to know the UUIDs of the BMCs they\u0027re aggregating in addition to their own.  I can think of two ways to make that happen:\n\n1. Each BMC makes an initial query to retrieve the UUID and decide if it should proceed with the actual aggregation.\n2. We let the BMCs cache their satellite configs and as part of that they retrieve the UUIDs from the satellites before normal operation actually begins.",
      "parentUuid": "c6c0b472_be1fb9ac",
      "range": {
        "startLine": 1193,
        "startChar": 0,
        "endLine": 1200,
        "endChar": 9
      },
      "revId": "ab2880d4cb9fe9be18942047efb56a2f0b60b9bd",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "244c1ef8_013adf22",
        "filename": "redfish-core/include/redfish_aggregator.hpp",
        "patchSetId": 3
      },
      "lineNbr": 1200,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-05-31T00:44:51Z",
      "side": 1,
      "message": "\u003e UUID could work.  We previously discussed using that as the seed for generating aggregation prefixes.\n\u003e \n\u003e We\u0027ll need to warn the satellites as well though of all BMCs that the message is getting forwarded to.  Consider this setup:\n\u003e \n\u003e * A aggregates B \u0026 C\n\u003e * B aggregates A \u0026 C\n\u003e * C aggregates A \u0026 B\n\u003e \n\u003e Let\u0027s say we query A for `/redfish/v1/Chassis`.  That\u0027s a top level collection so A also needs to forward that request to B and C.  In that request we only include the UUID of A.\n\u003e \n\u003e B aggregates A \u0026 C.  B would think it needs to forward the request to C since the only UUID in the header is for A (who just sent the request).  Likewise, C would forward the request to B and ignore A.\n\u003e \n\u003e The end result is the resources from B and C get included twice in the overall response in some form or fashion.\n\u003e ```\n\u003e Query -\u003e A -\u003e B -\u003e C\n\u003e           \\\n\u003e            -\u003e C -\u003e B\n\u003e ```\n\u003e \n\n\nUg...... the above made my brain hurt, but makes sense.  To support that kind of cluster topology we almost have to attach \"resource created by\" type metadata to every request.\n\n\u003e If the original forwarded request from A contained the UUID for A as well as the ones for the destinations then B and C would not make redundant forwards since they know that \"something\" has already aggregated one of the BMCs they\u0027re aggregating.\n\u003e \n\u003e For that to work each BMC will have to know the UUIDs of the BMCs they\u0027re aggregating in addition to their own.  I can think of two ways to make that happen:\n\u003e \n\u003e 1. Each BMC makes an initial query to retrieve the UUID and decide if it should proceed with the actual aggregation.\n\u003e 2. We let the BMCs cache their satellite configs and as part of that they retrieve the UUIDs from the satellites before normal operation actually begins.\n\nArguably we should be caching the sattelite UUID already, so I suspect this would be fine.\n\nAlternatively, maybe at startup, each aggregator builds that little map in memory, so that when it makes requests we can pick a path?  IDK;  We should really get multiple satellites working first.",
      "parentUuid": "6b33b000_11720fb8",
      "range": {
        "startLine": 1193,
        "startChar": 0,
        "endLine": 1200,
        "endChar": 9
      },
      "revId": "ab2880d4cb9fe9be18942047efb56a2f0b60b9bd",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "97db84d0_8831c487",
        "filename": "redfish-core/include/redfish_aggregator.hpp",
        "patchSetId": 3
      },
      "lineNbr": 1200,
      "author": {
        "id": 1001762
      },
      "writtenOn": "2024-05-31T05:37:19Z",
      "side": 1,
      "message": "Query -\u003e A -\u003e B -\u003e C\n          \\\n           -\u003e C -\u003e B\nAssuming we have uuid for BMCs available.\nCan\u0027t A decide what to put in request header to avoid this duplicates. \n1) When we forward request to B , we add C uuid in excluding list. \n2) Forward for C is inverse of 1.\nSo this will avoid duplicate aggregation right? The extra cost is in copying request for siblings.",
      "parentUuid": "244c1ef8_013adf22",
      "range": {
        "startLine": 1193,
        "startChar": 0,
        "endLine": 1200,
        "endChar": 9
      },
      "revId": "ab2880d4cb9fe9be18942047efb56a2f0b60b9bd",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "51592508_6a65a8fc",
        "filename": "redfish-core/include/redfish_aggregator.hpp",
        "patchSetId": 3
      },
      "lineNbr": 1200,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-05-31T21:41:54Z",
      "side": 1,
      "message": "\u003e Query -\u003e A -\u003e B -\u003e C\n\u003e           \\\n\u003e            -\u003e C -\u003e B\n\u003e Assuming we have uuid for BMCs available.\n\u003e Can\u0027t A decide what to put in request header to avoid this duplicates. \n\nA doesn\u0027t know which resources in a collection came from B, and which ones came from C.  Also, they\u0027re not unique URIs, the collections are merged, so there\u0027s not a single header we could use to know.\n\n\u003e 1) When we forward request to B , we add C uuid in excluding list. \n\u003e 2) Forward for C is inverse of 1.\n\u003e So this will avoid duplicate aggregation right? The extra cost is in copying request for siblings.\n\n\nI don\u0027t think it avoids it\n\nA sets As UUID forwards to B and C\nAt this point B doesn\u0027t know if it should forward to C or not, and there\u0027s no UUID to compare to in the request, because we only know B and C\n\n\n\n\nIt could be we\u0027re overcomplicating it at this point.  Do we have any designs that require loops like that?",
      "parentUuid": "97db84d0_8831c487",
      "range": {
        "startLine": 1193,
        "startChar": 0,
        "endLine": 1200,
        "endChar": 9
      },
      "revId": "ab2880d4cb9fe9be18942047efb56a2f0b60b9bd",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8a364a1b_5bc750f3",
        "filename": "redfish-core/include/redfish_aggregator.hpp",
        "patchSetId": 3
      },
      "lineNbr": 1200,
      "author": {
        "id": 1001762
      },
      "writtenOn": "2024-06-01T00:59:46Z",
      "side": 1,
      "message": "I did not explain it properly.\n\n```\nhandleRequest()\n{\n  \n  if this bmc is in request header\n\treturn // no need to handle as we have already seen this request\n  for( bmc b in  satellites)\n  \t{\n\t\tRequest r \u003d copy request\n\t\tr.addHeader( current bmc name)\n\t\tr.addHeader( all bmc in satellite list except b)\n\t\tforward r to b\n\t}\n  merge with local response\n  return response\n}\n\n\n```\n\nDoes not this work?\n\nEvery BMC knows its own satellite BMC\nAnd it  knows that it is going to forward the request to those satellite anyway\nSo it can add that information in the request header.\n\nNow when a Bmc process the header , it has the information about whether it saw the same request before or not. It handles the request based on that \n\nThis will avoid duplicates right?",
      "parentUuid": "51592508_6a65a8fc",
      "range": {
        "startLine": 1193,
        "startChar": 0,
        "endLine": 1200,
        "endChar": 9
      },
      "revId": "ab2880d4cb9fe9be18942047efb56a2f0b60b9bd",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "db234341_11fb95aa",
        "filename": "redfish-core/include/redfish_aggregator.hpp",
        "patchSetId": 3
      },
      "lineNbr": 1200,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2024-06-04T01:40:41Z",
      "side": 1,
      "message": "Splitting this off from https://gerrit.openbmc.org/c/openbmc/bmcweb/+/71685/comment/b510d528_b6e5dfb8/ to prevent that thread from become any more overloaded.\n\nThe concern about double counting can get particularly heinous if you have aggregation chains added to the mix.\n\n* A aggregates B \u0026 C\n* B aggregates D\n* C aggregates D\n\nIf you query `/redfish/v1/Chassis` on Machine A then fetching the information would look like this\n```\nA -\u003e B -\u003e D\n \\\n  -\u003e C -\u003e D\n```\n\nIn that case we\u0027ll duplicate D.  The proposed approach from the earlier thread won\u0027t help.  A has no idea that B and C are both aggregating D so it can\u0027t warn them in advance.\n\nAfter A forwards to B and C then those two paths occur in a vacuum.  B has no idea that C is aggregating D and C has no idea that B is aggregating D.\n\nMachine A would have to be able to recognize that these are duplicate resources\n* `/redfish/v1/Chassis/5B247A_{Buuid}_{Duuid}_ChassisId`\n* `/redfish/v1/Chassis/5B247A_{Cuuid}_{Duuid}_ChassisId`\n\nMachine A does not know that D exists so there is not a way for it to know that the `{Duuid}_` portion of the URIs comes from aggregation instead of being part of the actual ChassisId itself.\n\nMaybe that this point we just say something like \"Mutual Aggregation is only supported at the topmost level.  Don\u0027t create loops.\"?\n\nThe other option is the aggregator has to build a full topology and determine all the UUIDs beyond just the ones specified in its satellite configs.  That\u0027d be a lot of effort though to implement something that there may not be a need for.",
      "range": {
        "startLine": 1195,
        "startChar": 8,
        "endLine": 1200,
        "endChar": 9
      },
      "revId": "ab2880d4cb9fe9be18942047efb56a2f0b60b9bd",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aef0e508_39ca7d62",
        "filename": "redfish-core/include/redfish_aggregator.hpp",
        "patchSetId": 3
      },
      "lineNbr": 1200,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2024-06-04T01:40:41Z",
      "side": 1,
      "message": "\u003e Ug...... the above made my brain hurt, but makes sense. \n:D\n\n\u003e A sets As UUID forwards to B and C\n\u003e At this point B doesn\u0027t know if it should forward to C or not, and there\u0027s no UUID to compare to in the request, because we only know B and C\n\nI think Abhilash and I are saying the same thing at this point.  That\u0027s why I think the answer is the cache the satellite configs including their UUIDs.  That way A can also include the UUIDs for B and C in that initial request it forwards.\n\nB will likewise know the UUIDs of A and C.  When B receives that fowarded request from A then B will want to forward it to A and C since it aggregates both.  However, B likewise knows the UUIDs of A and C.  Their UUIDs will be in the header so it won\u0027t attempt to aggregate and it will just return normally.  The same thing would happen with C and we avoid duplicates.\n\nThere\u0027s another case that that may be of concern.  I\u0027m splitting it off as a separate comment.\n\n\u003e We should really get multiple satellites working first.\n+100.  Right now all we can really do anyway is a ring of A -\u003e B -\u003e A.  Enabling multiple satellite will require changing the aggregation prefix and considerations about caching the satellite configs.\n\nSome of these mutual aggregation questions will become a bit more clear when you can setup an actual topology instead of using my crude drawings.",
      "parentUuid": "8a364a1b_5bc750f3",
      "range": {
        "startLine": 1193,
        "startChar": 0,
        "endLine": 1200,
        "endChar": 9
      },
      "revId": "ab2880d4cb9fe9be18942047efb56a2f0b60b9bd",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6a29cd7b_d817648a",
        "filename": "redfish-core/include/redfish_aggregator.hpp",
        "patchSetId": 3
      },
      "lineNbr": 1200,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-06-04T16:31:45Z",
      "side": 1,
      "message": "\u003e Mutual Aggregation is only supported at the topmost level. Don\u0027t create loops.\n\n\nyep.  Lets just make this statement.",
      "parentUuid": "db234341_11fb95aa",
      "range": {
        "startLine": 1195,
        "startChar": 8,
        "endLine": 1200,
        "endChar": 9
      },
      "revId": "ab2880d4cb9fe9be18942047efb56a2f0b60b9bd",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3ec6856e_f4a08a72",
        "filename": "redfish-core/include/redfish_aggregator.hpp",
        "patchSetId": 3
      },
      "lineNbr": 1200,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-06-04T16:31:45Z",
      "side": 1,
      "message": "If you two understand it, I\u0027m happy to trust with whatever you two come up with, so I\u0027m more or less going to check out here.  Ping me if you want my input on anything, but I\u0027ll just trust that you guys have a solution that works.",
      "parentUuid": "aef0e508_39ca7d62",
      "range": {
        "startLine": 1193,
        "startChar": 0,
        "endLine": 1200,
        "endChar": 9
      },
      "revId": "ab2880d4cb9fe9be18942047efb56a2f0b60b9bd",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "157dae68_8e615303",
        "filename": "redfish-core/include/redfish_aggregator.hpp",
        "patchSetId": 3
      },
      "lineNbr": 1200,
      "author": {
        "id": 1001762
      },
      "writtenOn": "2024-06-05T04:46:02Z",
      "side": 1,
      "message": "A aggregates B \u0026 C\nB aggregates D\nC aggregates D\n\nYes this case is tricky to solve. we need following strategy for it \n1) we have global topology information available to all BMC,\n2) create a routing path for each satellite bmc add it to the header of satellite request. \n3) satellite uses the routing path for its aggregation.\n\nThis will also bring capabilities to aggregate/forward to BMC that are the part of the connected graph, which need not be always adjacent to the BMC. \n\nOr \n\nImplement a duplicate removal algorithm on the response before merging. \n\nQuestion is do we really need to support such topology? What is the need for such complicated BMC topology. \n\nJust a support for mutual aggregation and linear aggregation will do the job for all our practical use cases.",
      "parentUuid": "6a29cd7b_d817648a",
      "range": {
        "startLine": 1195,
        "startChar": 8,
        "endLine": 1200,
        "endChar": 9
      },
      "revId": "ab2880d4cb9fe9be18942047efb56a2f0b60b9bd",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ab20513a_232d68ed",
        "filename": "redfish-core/include/redfish_aggregator.hpp",
        "patchSetId": 3
      },
      "lineNbr": 1200,
      "author": {
        "id": 1001762
      },
      "writtenOn": "2026-02-12T04:04:22Z",
      "side": 1,
      "message": "This change set addresses deduplication of fully connected bmc topology. So marked as resolved",
      "parentUuid": "157dae68_8e615303",
      "range": {
        "startLine": 1195,
        "startChar": 8,
        "endLine": 1200,
        "endChar": 9
      },
      "revId": "ab2880d4cb9fe9be18942047efb56a2f0b60b9bd",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ea6e76d8_9c3ebe04",
        "filename": "redfish-core/include/redfish_aggregator.hpp",
        "patchSetId": 3
      },
      "lineNbr": 1200,
      "author": {
        "id": 1001762
      },
      "writtenOn": "2026-02-12T04:07:04Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "3ec6856e_f4a08a72",
      "range": {
        "startLine": 1193,
        "startChar": 0,
        "endLine": 1200,
        "endChar": 9
      },
      "revId": "ab2880d4cb9fe9be18942047efb56a2f0b60b9bd",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}