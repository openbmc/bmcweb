{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "ede58713_bd98f18e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 15,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-06-27T14:52:32Z",
      "side": 1,
      "message": "Can you please go into more detail on what this issue is, using data structure and variable names from the code?\n\nReading from the websocket should be fully initialized when onconnect is called.  Normally I wouldn\u0027t take issue with this, but the issue here is that onconnect is called AFTER the connection is negotiated (ie after boost::beast::websocket::async_accept has been called) which means that the socket itself has already transitioned to websocket mode by the point that onconnect is called, so the only way to close the socket is to use close().  I\u0027d be very surprised if errors in websocket libraries propogated properly when doing it this way.\n\nIf we must have an ability to do async operations as part of a connection operation, it should be a new method, something like beforeconnect(), so that we can modify the request before the negotiation is complete.  Does that make sense?",
      "range": {
        "startLine": 13,
        "startChar": 48,
        "endLine": 15,
        "endChar": 12
      },
      "revId": "33cc48fe9ab2a20757d60c92a34e7f772762e379",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "48f71322_0065cd5d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 15,
      "author": {
        "id": 1001489
      },
      "writtenOn": "2022-06-28T11:31:16Z",
      "side": 1,
      "message": "Sure, I\u0027ll try to explain from a code perspective. I\u0027ll just add that this is \na situation specific to nbd_proxy. Here we do the websocket upgrade \n\"// Perform the websocket upgrade\n        ws.async_accept(req, [this, self(shared_from_this())](\n                                 boost::system::error_code ec)\" \nThen we go to the acceptDone function, where the openHandler is started. \nBefore running the handler, we start the doRead() method which reads the \ndata for the websocket. In the case of nbd_proxy, openHandler has \nasychronous processes in it which are run in cascade. When the BMC is \nunder heavy load, the asynchronous processes in nbd_proxy do not \ncomplete their execution. In the meantime we start receiving data with \ndoRead which is aborted by an error due to the fact that the websocket \nis not yet ready to receive data (openHandler has finished its work but \nthe asynchronous processes in it haven\u0027t). To sum up upgrading to websocket can be \nasynchronous and we can\u0027t start handling data until openHandler \nfinishes. There is no mechanism here to prevent reading before the \nprocesses in nbd_proxy are finished.\nDoes that explain the problem a bit better?",
      "parentUuid": "ede58713_bd98f18e",
      "range": {
        "startLine": 13,
        "startChar": 48,
        "endLine": 15,
        "endChar": 12
      },
      "revId": "33cc48fe9ab2a20757d60c92a34e7f772762e379",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a8040cc5_6af5127b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 15,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-06-28T14:23:05Z",
      "side": 1,
      "message": "\u003e In the meantime we start receiving data with \ndoRead which is aborted by an error due to the fact that the websocket \nis not yet ready to receive data\n\nThe solution here is to put backpressure on the socket until the unix socket is opened.  We\u0027ve really needed a websocket backpressure mechanism for a while now.\n\n\n\u003e There is no mechanism here to prevent reading before the \nprocesses in nbd_proxy are finished.\n\nRight, we need to come up with one.",
      "parentUuid": "48f71322_0065cd5d",
      "range": {
        "startLine": 13,
        "startChar": 48,
        "endLine": 15,
        "endChar": 12
      },
      "revId": "33cc48fe9ab2a20757d60c92a34e7f772762e379",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cf9de494_4be999e5",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 15,
      "author": {
        "id": 1001489
      },
      "writtenOn": "2022-06-30T10:16:24Z",
      "side": 1,
      "message": "\u003e The solution here is to put backpressure on the socket until the unix socket is opened.\n\nDid you mean here to block the webscoket until we finish the initialization? In our case this machanism that I proposed is quite sufficient. If in your opinion this is not a satisfactory solution do you have perhaps an idea or suggestion how else we can do it? Or do you see/can you apply more generic solution?",
      "parentUuid": "a8040cc5_6af5127b",
      "range": {
        "startLine": 13,
        "startChar": 48,
        "endLine": 15,
        "endChar": 12
      },
      "revId": "33cc48fe9ab2a20757d60c92a34e7f772762e379",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a5f421d0_b8d3e738",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 15,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-06-30T18:58:35Z",
      "side": 1,
      "message": "\u003e \u003e The solution here is to put backpressure on the socket until the unix socket is opened.\n\u003e \n\u003e Did you mean here to block the webscoket until we finish the initialization?\n\nNo, not block, but don\u0027t accept messages callbacks (or maybe only accept the first one) until the socket is opened.  This same problem can be triggered if you reduce the bandwidth in certain portions of the code (either in the websocket or between the unix socket), you\u0027ll end up buffer overflowing because there\u0027s no ability to do backpressure.\n\nhttps://medium.com/@jayphelps/backpressure-explained-the-flow-of-data-through-software-2350b3e77ce7\n\n\u003e In our case this machanism that I proposed is quite sufficient.\n\nIn the case where it disconnects with 404, it will return both a websocket handshake and a 404, which isn\u0027t right to do in the HTTP RFC.\n\n\u003e If in your opinion this is not a satisfactory solution do you have perhaps an idea or suggestion how else we can do it? Or do you see/can you apply more generic solution?\n\nadd an onMessage handler that has a \"complete\" token, so backpressure can be applied on the websocket until the data has been forwarded to the unix socket.\n\n\nAlternatively, if you must have this feature, separating out a separate \"beforeOpen\" handler, that\u0027s distinct from \"onOpen\", so that we can call \"beforeOpen\" before the websocket handshake has completed.",
      "parentUuid": "cf9de494_4be999e5",
      "range": {
        "startLine": 13,
        "startChar": 48,
        "endLine": 15,
        "endChar": 12
      },
      "revId": "33cc48fe9ab2a20757d60c92a34e7f772762e379",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}