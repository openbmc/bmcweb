{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "4b8a48db_49daaa1c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 7,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-02-25T22:31:51Z",
      "side": 1,
      "message": "Looks like you forgot to check in the result of this generation.",
      "range": {
        "startLine": 7,
        "startChar": 0,
        "endLine": 7,
        "endChar": 8
      },
      "revId": "1ba21b0a1d5a25181bdfd5ac7ab4430022154514",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9a480453_2cda604a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 7,
      "author": {
        "id": 1002230
      },
      "writtenOn": "2025-02-26T18:15:33Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "4b8a48db_49daaa1c",
      "range": {
        "startLine": 7,
        "startChar": 0,
        "endLine": 7,
        "endChar": 8
      },
      "revId": "1ba21b0a1d5a25181bdfd5ac7ab4430022154514",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f42d40b5_9c53e6c8",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-02-25T22:31:51Z",
      "side": 1,
      "message": "Please take a look at the existing structures we have for redfish Message registries. What you\u0027ve implemented here looks like a duplicate.",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 13,
        "endChar": 22
      },
      "revId": "1ba21b0a1d5a25181bdfd5ac7ab4430022154514",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bf48aff9_0058c1ba",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1002230
      },
      "writtenOn": "2025-02-26T18:15:33Z",
      "side": 1,
      "message": "The reason I\u0027m doing this (making a separate structure) is, because the code using message registries get registry name and message ID, so it can load the registry and look for the message id in there.\nThe code I\u0027m writing gets dbus event id as an input, and here we have 2 options:\n1. Put lists of dbus events that should be mapped to particular message ID into existing message registry structures. In this case we will not need an additional structure, but we will need to traverse ALL the message registries looking for a messageID associated with the received dbus event name.\n2. Have a separate structure where each key points to particular registry and message id. You may think of it as an index. Since it\u0027s pre-generated and requires traversal only thru this index, it\u0027s much faster and cheaper that #1.",
      "parentUuid": "f42d40b5_9c53e6c8",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 13,
        "endChar": 22
      },
      "revId": "1ba21b0a1d5a25181bdfd5ac7ab4430022154514",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c20b91bb_d8304efc",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-02-27T02:33:58Z",
      "side": 1,
      "message": "\u003e The reason I\u0027m doing this (making a separate structure) is, because the code using message registries get registry name and message ID, so it can load the registry and look for the message id in there.\n\nAs a description, that code is identical to what exists.  Aside from pulling this information from dbus instead of journald, the differences in the actual redfish code here is negligeble, and a lot of effort has been spent already to keep the existing structures:\nA. No cost to construct at startup\nB. No sustained memory usage\n\n\u003e The code I\u0027m writing gets dbus event id as an input, and here we have 2 options:\n\u003e 1. Put lists of dbus events that should be mapped to particular message ID into existing message registry structures. In this case we will not need an additional structure, but we will need to traverse ALL the message registries looking for a messageID associated with the received dbus event name.\n\nKeep in mind, the existing lists are sorted, so this is a Log(N) search per registry to search, but given we know the prefix..... don\u0027t we know which registry to search for the ID?\n\n\u003e 2. Have a separate structure where each key points to particular registry and message id. You may think of it as an index. Since it\u0027s pre-generated and requires traversal only thru this index, it\u0027s much faster and cheaper that #1.\n\nLets start with the naive, simple version (keep changes incremental) and we can write a patch that \"shows\" (ideally with performance numbers) that we need a new structure.",
      "parentUuid": "bf48aff9_0058c1ba",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 13,
        "endChar": 22
      },
      "revId": "1ba21b0a1d5a25181bdfd5ac7ab4430022154514",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "475786ab_eed3fe3e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1002230
      },
      "writtenOn": "2025-02-27T16:13:19Z",
      "side": 1,
      "message": "Here is what I\u0027m dealing with. Say we know that \"xyz.openbmc_project.State.Leak.Detector.LeakDetectedCritical\" DBus message ID, corresponds to the \"LeakDetectedCritical\" message in the \"Environmental\" registry. This Redfish message, also suppose to have 1 argument.\n\nBMCWeb receives a message from DBus. This message comes as DBusPropertiesMap, which is pretty much an array of key value pairs. We know what keys to expect and this [code](https://github.com/openbmc/bmcweb/blob/e60300aee76b7875f5fc407acede2f05ddbdd9bc/redfish-core/include/utils/dbus_event_log_entry.hpp#L30) converts it to the DbusEventLogEntry structure.\nAfter conversion, in the structure we have DBus message (in the example it\u0027s \"xyz.openbmc_project.State.Leak.Detector.LeakDetectedCritical\"), and arguments (this particular message supposed to have 1 argument), they are stored in the \"AdditionalData\" map along with other information. Redfish returns arguments as an array, so there are no names, but position/index, the AdditionalData is a Map, so we need to know, what key each argument is associated with.\n\nNow, the job is:\n1. To find Redfish registry and MessageID that correspond to the DBus message name (\"xyz.openbmc_project.State.Leak.Detector.LeakDetectedCritical\").\n2. Find keys in the AdditionalData map for each of the arguments.\n\nAs you can see, on the input, there is no Redfish data whatsoever.\n\nWe have 2 options to do this.\n### Use existing structures. \nTo do so, we will need to\n   1. Define a new structure like:\n```\nstruct DBusMapInfo {\n  const char* dbusMessageName;\n  const std::array\u003cconst char*, 5\u003e agrumentNames;\n  const size_t numberOfArgumentsNames;\n  // we will also need types in the future, so the struct above will be more complicated.\n}\n```\n   2. Modify [redfish::registries::Message structure](https://github.com/openbmc/bmcweb/blob/master/redfish-core/include/registries.hpp#L43) by adding fields:\n```\n  const std::array\u003cDBusMapInfo, 10\u003e dbusMessageInfos,\n  const size_t numberOfDbusMessageInfos,\n```\n   3. Modifying search code like this:\n```\n// pseudo code\ndbusMessageName \u003d \"xyz.openbmc_project.State.Leak.Detector.LeakDetectedCritical;\nregistries \u003d getAllRegistries();\nfor (registry: registries) {\n  registryEntries \u003d registry.getAllEntries();\n  for (entry : registryEntries) {\n    for (i\u003d0; i\u003c entry.numberOfDbusMessageInfos; i++) {\n      if (strcmp(entry.dbusMessageInfos.dbusMessageName, dbusMessageName) \u003d\u003d 0) {\n         // Found corresponding message info\n         // So, we need to return DBusMapInfo as caller needs key names in the DBus AdditionalData for arguments; registry name and the entry for other info. \n         return std::tuple(entry.dbusMessageInfos, registry, entry);\n  }\n}\n```\n\n### Use a separate map\nIn this case, the map is pre-generated, it\u0027s a map (I\u0027ve converted it to an array of structs that use const/constexpr types) - dbusMessageName to a struct with registry and entry names and Dbus keys for arguments.\n\nWith this structure the lookup looks like:\n```\ndbusMessageName \u003d \"xyz.openbmc_project.State.Leak.Detector.LeakDetectedCritical;\nfor ([name, info]: dbusToRfMap) {\n  if (name \u003d\u003d dbusMessageName) {\n    registry \u003d getRegistryByName(info.registryName);\n    entry \u003d getEntryFromRegistry(registry, info.redfishMessageName);\n    return std::tuple(info, info.registryName, entry);\n  } \n}\n```\n\nIt mostly uses existing code to deal with registries, and it\u0027s much faster, as there are more redfish messages than dbus names, so it traverses smaller dataset.\n\nThe separate map option is better organized - the redfish::registries::Message remains clean, it contains only data related to the Redfish message, and nothing else that may or may not be in use.",
      "parentUuid": "c20b91bb_d8304efc",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 13,
        "endChar": 22
      },
      "revId": "1ba21b0a1d5a25181bdfd5ac7ab4430022154514",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4ee2135b_128669f1",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-02-28T22:01:55Z",
      "side": 1,
      "message": "Stepping back from data structures for a second:\n\nThis is the part I\u0027m not understanding.  Redfish needs arguments as indexes (%1, %2, %3, etc) to be able to do message string replacement from the registry template string and args.\n\nhttps://github.com/openbmc/bmcweb/blob/da9dc905da4e6d30125bcca160537cf2cdb2ddf4/redfish-core/include/registries.hpp#L47C20-L47C35\n\nAs we\u0027ve defined the dbus interface, where is that mapping coming from?  PDI?\n\nI have a minor preference for \"Use existing structures.\" option (because it keeps the structs the same). There\u0027s already some args that are per-argument, so combining them into a new struct, like\n\nMessageArg{\n   std::string_view dbusArgName;  \u003c- will be empty string for registries not generated from PDI\n   std::string_view argType;  \u003c- needs retained in both cases.\n}\n\nstruct Message\n{\n...\nstd::array\u003cconst MessageArg, 5\u003e paramTypes;\n}\n\nSeems worthwhile.  \n\nCan you elaborate on what the dbusMessageName arg would be or do?  I expected that PDI -\u003e messageId translation would be a mechanical transform (snake case to CamelCase, etc) and not that we\u0027d have to store a separate string.  I\u0027m happy to declare the mapping around \"Openbmc LeakDetectedCritical translates to Redfish Environmental LeakDetectedCritical\" type map here... but I think Patricks intent was for that to live in PDI (and that\u0027s probably a more proper place for it).\n\nKeep in mind, there\u0027s a boatload of Redfish MessageIds, and we have 1MB of binary space to play with, so some of the data structure intent here is trying to keep the binary data small, constexpr, in RODATA, and deduplicated as much as possible down to only what redfish needs so that we don\u0027t explode the binary when we pull in DMTF  where where we might use 10% of the messages in them.",
      "parentUuid": "475786ab_eed3fe3e",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 13,
        "endChar": 22
      },
      "revId": "1ba21b0a1d5a25181bdfd5ac7ab4430022154514",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "63dcefc9_045ec591",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-02-25T22:31:51Z",
      "side": 1,
      "message": "minor comments.",
      "revId": "1ba21b0a1d5a25181bdfd5ac7ab4430022154514",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aff9e416_ba1b75f1",
        "filename": "scripts/parse_registries.py",
        "patchSetId": 1
      },
      "lineNbr": 51,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-02-25T22:31:51Z",
      "side": 1,
      "message": "How does this stay up to date if we\u0027re pulling this from github directly?",
      "range": {
        "startLine": 51,
        "startChar": 0,
        "endLine": 51,
        "endChar": 131
      },
      "revId": "1ba21b0a1d5a25181bdfd5ac7ab4430022154514",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "05b17548_8249e7cf",
        "filename": "scripts/parse_registries.py",
        "patchSetId": 1
      },
      "lineNbr": 51,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-02-25T23:08:30Z",
      "side": 1,
      "message": "Nvm, bad comment.",
      "parentUuid": "aff9e416_ba1b75f1",
      "range": {
        "startLine": 51,
        "startChar": 0,
        "endLine": 51,
        "endChar": 131
      },
      "revId": "1ba21b0a1d5a25181bdfd5ac7ab4430022154514",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "df4da75f_1e4e5493",
        "filename": "scripts/parse_registries.py",
        "patchSetId": 1
      },
      "lineNbr": 704,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-02-25T22:31:51Z",
      "side": 1,
      "message": "Some issues with this structure:\n1. It\u0027s going to consume memory the whole time bmcweb is running\n2. It needs to be constructed/malloced/sorted at startup which effects the startup time on socket activation.\n\nPlease look at the existing Registry structures and model your code after them.  They don\u0027t have either of these problems, give essentially the same result.\n\nIf there\u0027s modifications we need to make to them, great, but I don\u0027t want to maintain two different structure definitions for storing a \"registry\" in the binary.",
      "revId": "1ba21b0a1d5a25181bdfd5ac7ab4430022154514",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "46789b17_0bbe88e8",
        "filename": "scripts/parse_registries.py",
        "patchSetId": 1
      },
      "lineNbr": 704,
      "author": {
        "id": 1002230
      },
      "writtenOn": "2025-02-26T18:15:33Z",
      "side": 1,
      "message": "I will look into making this static.\n\nBut I think we need a separate structure to make it efficient (see my point about this in the previous comment).",
      "parentUuid": "df4da75f_1e4e5493",
      "revId": "1ba21b0a1d5a25181bdfd5ac7ab4430022154514",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4602f98b_68a470d3",
        "filename": "scripts/parse_registries.py",
        "patchSetId": 1
      },
      "lineNbr": 704,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-02-27T02:33:58Z",
      "side": 1,
      "message": "see my last comment above.  Happy to have efficiency discussions and \"better data structure\" discussions.  Lets have them in a commit message with some testing so we can show:\nA. How much extra code we have to maintain to get this performance.\nB. How much performance we get out of it.\n\nAnd we can make a maintainability tradeoff.",
      "parentUuid": "46789b17_0bbe88e8",
      "revId": "1ba21b0a1d5a25181bdfd5ac7ab4430022154514",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d599cf2a_762dc6a1",
        "filename": "scripts/parse_registries.py",
        "patchSetId": 1
      },
      "lineNbr": 704,
      "author": {
        "id": 1002230
      },
      "writtenOn": "2025-02-27T16:19:34Z",
      "side": 1,
      "message": "I replied above. Option to reuse existing structure will require adding more code as well. I see only getRegistryFromPrefix and getMessageFromRegistry, but to implement traversal over registries, we will need to implement getAllRegistries, and traversal code.",
      "parentUuid": "4602f98b_68a470d3",
      "revId": "1ba21b0a1d5a25181bdfd5ac7ab4430022154514",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "92e1c4a8_6133fa33",
        "filename": "scripts/parse_registries.py",
        "patchSetId": 1
      },
      "lineNbr": 704,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-02-28T22:01:55Z",
      "side": 1,
      "message": "I\u0027m just going to close this out to avoid duplication.  Resolving the above discussion will resolve this one.",
      "parentUuid": "d599cf2a_762dc6a1",
      "revId": "1ba21b0a1d5a25181bdfd5ac7ab4430022154514",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3e5d42e7_cd5da478",
        "filename": "scripts/parse_registries.py",
        "patchSetId": 1
      },
      "lineNbr": 742,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-02-25T22:31:51Z",
      "side": 1,
      "message": "This script currently doesn\u0027t use type hints.  If you\u0027d like to refactor it to use them consistently, I\u0027m in support of that, but I\u0027d like to see it done in another commit.  Up to you if it happens before or after this feature add.",
      "range": {
        "startLine": 742,
        "startChar": 13,
        "endLine": 742,
        "endChar": 19
      },
      "revId": "1ba21b0a1d5a25181bdfd5ac7ab4430022154514",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a778050d_47758f60",
        "filename": "scripts/parse_registries.py",
        "patchSetId": 1
      },
      "lineNbr": 742,
      "author": {
        "id": 1002230
      },
      "writtenOn": "2025-02-26T16:17:12Z",
      "side": 1,
      "message": "Added a change before this one for that.",
      "parentUuid": "3e5d42e7_cd5da478",
      "range": {
        "startLine": 742,
        "startChar": 13,
        "endLine": 742,
        "endChar": 19
      },
      "revId": "1ba21b0a1d5a25181bdfd5ac7ab4430022154514",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "304a09fd_d9dfd6de",
        "filename": "scripts/parse_registries.py",
        "patchSetId": 1
      },
      "lineNbr": 890,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-02-25T22:31:51Z",
      "side": 1,
      "message": "Lets start by working through adding a single new shcema.",
      "range": {
        "startLine": 889,
        "startChar": 0,
        "endLine": 890,
        "endChar": 10
      },
      "revId": "1ba21b0a1d5a25181bdfd5ac7ab4430022154514",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "669468f4_44d9076c",
        "filename": "scripts/parse_registries.py",
        "patchSetId": 1
      },
      "lineNbr": 890,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-02-28T22:01:55Z",
      "side": 1,
      "message": "Obsolete",
      "parentUuid": "304a09fd_d9dfd6de",
      "range": {
        "startLine": 889,
        "startChar": 0,
        "endLine": 890,
        "endChar": 10
      },
      "revId": "1ba21b0a1d5a25181bdfd5ac7ab4430022154514",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}