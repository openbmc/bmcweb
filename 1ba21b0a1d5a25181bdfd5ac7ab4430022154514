{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "4b8a48db_49daaa1c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 7,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-02-25T22:31:51Z",
      "side": 1,
      "message": "Looks like you forgot to check in the result of this generation.",
      "range": {
        "startLine": 7,
        "startChar": 0,
        "endLine": 7,
        "endChar": 8
      },
      "revId": "1ba21b0a1d5a25181bdfd5ac7ab4430022154514",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9a480453_2cda604a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 7,
      "author": {
        "id": 1002230
      },
      "writtenOn": "2025-02-26T18:15:33Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "4b8a48db_49daaa1c",
      "range": {
        "startLine": 7,
        "startChar": 0,
        "endLine": 7,
        "endChar": 8
      },
      "revId": "1ba21b0a1d5a25181bdfd5ac7ab4430022154514",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f42d40b5_9c53e6c8",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-02-25T22:31:51Z",
      "side": 1,
      "message": "Please take a look at the existing structures we have for redfish Message registries. What you\u0027ve implemented here looks like a duplicate.",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 13,
        "endChar": 22
      },
      "revId": "1ba21b0a1d5a25181bdfd5ac7ab4430022154514",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bf48aff9_0058c1ba",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1002230
      },
      "writtenOn": "2025-02-26T18:15:33Z",
      "side": 1,
      "message": "The reason I\u0027m doing this (making a separate structure) is, because the code using message registries get registry name and message ID, so it can load the registry and look for the message id in there.\nThe code I\u0027m writing gets dbus event id as an input, and here we have 2 options:\n1. Put lists of dbus events that should be mapped to particular message ID into existing message registry structures. In this case we will not need an additional structure, but we will need to traverse ALL the message registries looking for a messageID associated with the received dbus event name.\n2. Have a separate structure where each key points to particular registry and message id. You may think of it as an index. Since it\u0027s pre-generated and requires traversal only thru this index, it\u0027s much faster and cheaper that #1.",
      "parentUuid": "f42d40b5_9c53e6c8",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 13,
        "endChar": 22
      },
      "revId": "1ba21b0a1d5a25181bdfd5ac7ab4430022154514",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c20b91bb_d8304efc",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-02-27T02:33:58Z",
      "side": 1,
      "message": "\u003e The reason I\u0027m doing this (making a separate structure) is, because the code using message registries get registry name and message ID, so it can load the registry and look for the message id in there.\n\nAs a description, that code is identical to what exists.  Aside from pulling this information from dbus instead of journald, the differences in the actual redfish code here is negligeble, and a lot of effort has been spent already to keep the existing structures:\nA. No cost to construct at startup\nB. No sustained memory usage\n\n\u003e The code I\u0027m writing gets dbus event id as an input, and here we have 2 options:\n\u003e 1. Put lists of dbus events that should be mapped to particular message ID into existing message registry structures. In this case we will not need an additional structure, but we will need to traverse ALL the message registries looking for a messageID associated with the received dbus event name.\n\nKeep in mind, the existing lists are sorted, so this is a Log(N) search per registry to search, but given we know the prefix..... don\u0027t we know which registry to search for the ID?\n\n\u003e 2. Have a separate structure where each key points to particular registry and message id. You may think of it as an index. Since it\u0027s pre-generated and requires traversal only thru this index, it\u0027s much faster and cheaper that #1.\n\nLets start with the naive, simple version (keep changes incremental) and we can write a patch that \"shows\" (ideally with performance numbers) that we need a new structure.",
      "parentUuid": "bf48aff9_0058c1ba",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 13,
        "endChar": 22
      },
      "revId": "1ba21b0a1d5a25181bdfd5ac7ab4430022154514",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "475786ab_eed3fe3e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1002230
      },
      "writtenOn": "2025-02-27T16:13:19Z",
      "side": 1,
      "message": "Here is what I\u0027m dealing with. Say we know that \"xyz.openbmc_project.State.Leak.Detector.LeakDetectedCritical\" DBus message ID, corresponds to the \"LeakDetectedCritical\" message in the \"Environmental\" registry. This Redfish message, also suppose to have 1 argument.\n\nBMCWeb receives a message from DBus. This message comes as DBusPropertiesMap, which is pretty much an array of key value pairs. We know what keys to expect and this [code](https://github.com/openbmc/bmcweb/blob/e60300aee76b7875f5fc407acede2f05ddbdd9bc/redfish-core/include/utils/dbus_event_log_entry.hpp#L30) converts it to the DbusEventLogEntry structure.\nAfter conversion, in the structure we have DBus message (in the example it\u0027s \"xyz.openbmc_project.State.Leak.Detector.LeakDetectedCritical\"), and arguments (this particular message supposed to have 1 argument), they are stored in the \"AdditionalData\" map along with other information. Redfish returns arguments as an array, so there are no names, but position/index, the AdditionalData is a Map, so we need to know, what key each argument is associated with.\n\nNow, the job is:\n1. To find Redfish registry and MessageID that correspond to the DBus message name (\"xyz.openbmc_project.State.Leak.Detector.LeakDetectedCritical\").\n2. Find keys in the AdditionalData map for each of the arguments.\n\nAs you can see, on the input, there is no Redfish data whatsoever.\n\nWe have 2 options to do this.\n### Use existing structures. \nTo do so, we will need to\n   1. Define a new structure like:\n```\nstruct DBusMapInfo {\n  const char* dbusMessageName;\n  const std::array\u003cconst char*, 5\u003e agrumentNames;\n  const size_t numberOfArgumentsNames;\n  // we will also need types in the future, so the struct above will be more complicated.\n}\n```\n   2. Modify [redfish::registries::Message structure](https://github.com/openbmc/bmcweb/blob/master/redfish-core/include/registries.hpp#L43) by adding fields:\n```\n  const std::array\u003cDBusMapInfo, 10\u003e dbusMessageInfos,\n  const size_t numberOfDbusMessageInfos,\n```\n   3. Modifying search code like this:\n```\n// pseudo code\ndbusMessageName \u003d \"xyz.openbmc_project.State.Leak.Detector.LeakDetectedCritical;\nregistries \u003d getAllRegistries();\nfor (registry: registries) {\n  registryEntries \u003d registry.getAllEntries();\n  for (entry : registryEntries) {\n    for (i\u003d0; i\u003c entry.numberOfDbusMessageInfos; i++) {\n      if (strcmp(entry.dbusMessageInfos.dbusMessageName, dbusMessageName) \u003d\u003d 0) {\n         // Found corresponding message info\n         // So, we need to return DBusMapInfo as caller needs key names in the DBus AdditionalData for arguments; registry name and the entry for other info. \n         return std::tuple(entry.dbusMessageInfos, registry, entry);\n  }\n}\n```\n\n### Use a separate map\nIn this case, the map is pre-generated, it\u0027s a map (I\u0027ve converted it to an array of structs that use const/constexpr types) - dbusMessageName to a struct with registry and entry names and Dbus keys for arguments.\n\nWith this structure the lookup looks like:\n```\ndbusMessageName \u003d \"xyz.openbmc_project.State.Leak.Detector.LeakDetectedCritical;\nfor ([name, info]: dbusToRfMap) {\n  if (name \u003d\u003d dbusMessageName) {\n    registry \u003d getRegistryByName(info.registryName);\n    entry \u003d getEntryFromRegistry(registry, info.redfishMessageName);\n    return std::tuple(info, info.registryName, entry);\n  } \n}\n```\n\nIt mostly uses existing code to deal with registries, and it\u0027s much faster, as there are more redfish messages than dbus names, so it traverses smaller dataset.\n\nThe separate map option is better organized - the redfish::registries::Message remains clean, it contains only data related to the Redfish message, and nothing else that may or may not be in use.",
      "parentUuid": "c20b91bb_d8304efc",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 13,
        "endChar": 22
      },
      "revId": "1ba21b0a1d5a25181bdfd5ac7ab4430022154514",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "63dcefc9_045ec591",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-02-25T22:31:51Z",
      "side": 1,
      "message": "minor comments.",
      "revId": "1ba21b0a1d5a25181bdfd5ac7ab4430022154514",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aff9e416_ba1b75f1",
        "filename": "scripts/parse_registries.py",
        "patchSetId": 1
      },
      "lineNbr": 51,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-02-25T22:31:51Z",
      "side": 1,
      "message": "How does this stay up to date if we\u0027re pulling this from github directly?",
      "range": {
        "startLine": 51,
        "startChar": 0,
        "endLine": 51,
        "endChar": 131
      },
      "revId": "1ba21b0a1d5a25181bdfd5ac7ab4430022154514",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "05b17548_8249e7cf",
        "filename": "scripts/parse_registries.py",
        "patchSetId": 1
      },
      "lineNbr": 51,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-02-25T23:08:30Z",
      "side": 1,
      "message": "Nvm, bad comment.",
      "parentUuid": "aff9e416_ba1b75f1",
      "range": {
        "startLine": 51,
        "startChar": 0,
        "endLine": 51,
        "endChar": 131
      },
      "revId": "1ba21b0a1d5a25181bdfd5ac7ab4430022154514",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "df4da75f_1e4e5493",
        "filename": "scripts/parse_registries.py",
        "patchSetId": 1
      },
      "lineNbr": 704,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-02-25T22:31:51Z",
      "side": 1,
      "message": "Some issues with this structure:\n1. It\u0027s going to consume memory the whole time bmcweb is running\n2. It needs to be constructed/malloced/sorted at startup which effects the startup time on socket activation.\n\nPlease look at the existing Registry structures and model your code after them.  They don\u0027t have either of these problems, give essentially the same result.\n\nIf there\u0027s modifications we need to make to them, great, but I don\u0027t want to maintain two different structure definitions for storing a \"registry\" in the binary.",
      "revId": "1ba21b0a1d5a25181bdfd5ac7ab4430022154514",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "46789b17_0bbe88e8",
        "filename": "scripts/parse_registries.py",
        "patchSetId": 1
      },
      "lineNbr": 704,
      "author": {
        "id": 1002230
      },
      "writtenOn": "2025-02-26T18:15:33Z",
      "side": 1,
      "message": "I will look into making this static.\n\nBut I think we need a separate structure to make it efficient (see my point about this in the previous comment).",
      "parentUuid": "df4da75f_1e4e5493",
      "revId": "1ba21b0a1d5a25181bdfd5ac7ab4430022154514",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4602f98b_68a470d3",
        "filename": "scripts/parse_registries.py",
        "patchSetId": 1
      },
      "lineNbr": 704,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-02-27T02:33:58Z",
      "side": 1,
      "message": "see my last comment above.  Happy to have efficiency discussions and \"better data structure\" discussions.  Lets have them in a commit message with some testing so we can show:\nA. How much extra code we have to maintain to get this performance.\nB. How much performance we get out of it.\n\nAnd we can make a maintainability tradeoff.",
      "parentUuid": "46789b17_0bbe88e8",
      "revId": "1ba21b0a1d5a25181bdfd5ac7ab4430022154514",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3e5d42e7_cd5da478",
        "filename": "scripts/parse_registries.py",
        "patchSetId": 1
      },
      "lineNbr": 742,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-02-25T22:31:51Z",
      "side": 1,
      "message": "This script currently doesn\u0027t use type hints.  If you\u0027d like to refactor it to use them consistently, I\u0027m in support of that, but I\u0027d like to see it done in another commit.  Up to you if it happens before or after this feature add.",
      "range": {
        "startLine": 742,
        "startChar": 13,
        "endLine": 742,
        "endChar": 19
      },
      "revId": "1ba21b0a1d5a25181bdfd5ac7ab4430022154514",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a778050d_47758f60",
        "filename": "scripts/parse_registries.py",
        "patchSetId": 1
      },
      "lineNbr": 742,
      "author": {
        "id": 1002230
      },
      "writtenOn": "2025-02-26T16:17:12Z",
      "side": 1,
      "message": "Added a change before this one for that.",
      "parentUuid": "3e5d42e7_cd5da478",
      "range": {
        "startLine": 742,
        "startChar": 13,
        "endLine": 742,
        "endChar": 19
      },
      "revId": "1ba21b0a1d5a25181bdfd5ac7ab4430022154514",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "304a09fd_d9dfd6de",
        "filename": "scripts/parse_registries.py",
        "patchSetId": 1
      },
      "lineNbr": 890,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-02-25T22:31:51Z",
      "side": 1,
      "message": "Lets start by working through adding a single new shcema.",
      "range": {
        "startLine": 889,
        "startChar": 0,
        "endLine": 890,
        "endChar": 10
      },
      "revId": "1ba21b0a1d5a25181bdfd5ac7ab4430022154514",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}