{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "6394efd7_6bfa10a5",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 11,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-07-12T04:28:26Z",
      "side": 1,
      "message": "In real scenarios, connect can definitely take more than a second, especially on low links, or SSL that takes a long time to bring the link up, so 1 second isn\u0027t going to work.\n\nWhat I\u0027d like to understand is why this matters at all.  If the destination is unreachable, aren\u0027t we bound by the linux timeouts, and shouldn\u0027t those be relatively quick based on L2 network routing?  I would expect the timeout in this case is just a security precaution for compromised network nodes that might not bring up the full connection quickly in an attempt to run the bmc out of resources, but clearly you\u0027re seeing something else here.",
      "range": {
        "startLine": 10,
        "startChar": 17,
        "endLine": 11,
        "endChar": 26
      },
      "revId": "122f379bf286075a7aac335399f2d1fb28765c15",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c443fad7_5f92defc",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 11,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-07-12T16:07:44Z",
      "side": 1,
      "message": "\u003e In real scenarios, connect can definitely take more than a second, especially on low links, or SSL that takes a long time to bring the link up, so 1 second isn\u0027t going to work.\nIn that case, is it possible to reduce the 30 second limit at all?\n\n\u003e ...but clearly you\u0027re seeing something else here\nOn my BMC I\u0027m seeing the timer in doConnect() completely expire when the destination is unreachable (i.e. \"The socket was closed due to a timeout\").  This takes the full 30 seconds.\n\nIn this case I\u0027m using an external IP rather than an arbitrary port on the localhost that has been configured to forward to a non-existent satellite BMC.",
      "parentUuid": "6394efd7_6bfa10a5",
      "range": {
        "startLine": 10,
        "startChar": 17,
        "endLine": 11,
        "endChar": 26
      },
      "revId": "122f379bf286075a7aac335399f2d1fb28765c15",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "540fca60_d3e7bd42",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 11,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-07-12T18:43:57Z",
      "side": 1,
      "message": "1 is way too short.....  5-15 seconds would be in my head as a relatively sane default, but.... we should be looking to something with more industry traction for inspiration.  What does curl/wget/requests do in this case for a timeout, and can we just copy them?\n\nNow that I\u0027ve had my coffee, I\u0027m starting to understand the problem more;  You have to bring up the connection, and do the request in the time that it takes the primary request to time out, which means you have more constraints on your timing.\n\n(thinking out loud) What if we relied on keep alive, and just kept an open connection to each aggregated resource all the time, then, if we get a request we could immediately check if the connection exists, and 502 immediately, instead of waiting for connect to fail?",
      "parentUuid": "c443fad7_5f92defc",
      "range": {
        "startLine": 10,
        "startChar": 17,
        "endLine": 11,
        "endChar": 26
      },
      "revId": "122f379bf286075a7aac335399f2d1fb28765c15",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b925826c_d74b8db5",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 11,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-07-12T21:08:34Z",
      "side": 1,
      "message": "\u003e What does curl/wget/requests do in this case for a timeout, and can we just copy them?\nBased on running curl on my local machine to some made-up destination, curl will just run until it hits its own internal timeout.  On my machine that seems to take ~130 seconds:\n```\ncurl: (28) Failed to connect to 192.92.32.1 port 80 after 130994 ms: Connection timed out\ncurl: (28) Failed to connect to 192.92.32.1 port 80 after 130045 ms: Connection timed out\ncurl: (28) Failed to connect to 192.92.32.1 port 80 after 129363 ms: Connection timed out\n```\n\nBasically we need to prove a negative (the destination does not exist) and the standard approach seems to be to wait for a timeout.  For now the only time that this hurts is the redfish aggregation edge case where either a satellite is unreachable, or the satellite config is incorrect.\n\n\u003e (thinking out loud) What if we relied on keep alive, and just kept an open connection to each aggregated resource all the time, then, if we get a request we could immediately check if the connection exists, and 502 immediately, instead of waiting for connect to fail?\n(Also thinking out loud) I think that would only work if the destination supports keep alive.  Also, I would need some way to handle the scenario where the destination blinking in and out results in not all of the connections in the pool remaining open.  \n\nI could take the same idea and add a bool to each connection pool that denotes if a connection timeout previously occurred.  That bool could only be set if we fall through due to a connection timeout.  It would be cleared anytime a connection is able to receive a response to a request.\n\nAs part of each message sendinging attempt we would first check the value of that bool for the specified connection pool.  When the bool is set then we would immediately return a 502, but at the same time we would also just send a ping to the destination to check in the background if that destination has become available again.  If it did then we would flip the bool so that future requests know to not return a 502.",
      "parentUuid": "540fca60_d3e7bd42",
      "range": {
        "startLine": 10,
        "startChar": 17,
        "endLine": 11,
        "endChar": 26
      },
      "revId": "122f379bf286075a7aac335399f2d1fb28765c15",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "36384145_101b604c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 11,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-07-12T22:11:42Z",
      "side": 1,
      "message": "\u003e \u003e What does curl/wget/requests do in this case for a timeout, and can we just copy them?\n\u003e Based on running curl on my local machine to some made-up destination, curl will just run until it hits its own internal timeout.  On my machine that seems to take ~130 seconds:\n\u003e ```\n\u003e curl: (28) Failed to connect to 192.92.32.1 port 80 after 130994 ms: Connection timed out\n\u003e curl: (28) Failed to connect to 192.92.32.1 port 80 after 130045 ms: Connection timed out\n\u003e curl: (28) Failed to connect to 192.92.32.1 port 80 after 129363 ms: Connection timed out\n\u003e ```\n\u003e \n\u003e Basically we need to prove a negative (the destination does not exist) and the standard approach seems to be to wait for a timeout.  For now the only time that this hurts is the redfish aggregation edge case where either a satellite is unreachable, or the satellite config is incorrect.\n\u003e \n\u003e \u003e (thinking out loud) What if we relied on keep alive, and just kept an open connection to each aggregated resource all the time, then, if we get a request we could immediately check if the connection exists, and 502 immediately, instead of waiting for connect to fail?\n\u003e (Also thinking out loud) I think that would only work if the destination supports keep alive. \n\nGood point, although it seems pretty reasonable that DMTF might require keepalive, given they require TLS.  I don\u0027t know of an implementation that doesn\u0027t support it, although you are technically correct.  For this use case it might be worth getting into the standard.\n\n\u003e Also, I would need some way to handle the scenario where the destination blinking in and out results in not all of the connections in the pool remaining open.  \n\n\nNot following in this case.  if tcp is dropping, wouldn\u0027t the connections be closing and be destroyed?\n\n\u003e \n\u003e I could take the same idea and add a bool to each connection pool that denotes if a connection timeout previously occurred.  That bool could only be set if we fall through due to a connection timeout.  It would be cleared anytime a connection is able to receive a response to a request.\n\n\n\u003e \n\u003e As part of each message sendinging attempt we would first check the value of that bool for the specified connection pool.  When the bool is set then we would immediately return a 502, but at the same time we would also just send a ping to the destination to check in the background if that destination has become available again.  If it did then we would flip the bool so that future requests know to not return a 502.\n\n\nOh, so you\u0027re thinking we keep connection objects alive regardless of their connectedness.  That might work?  Or maybe we need a \"last time connected\" time, so we can still handle the first-connect case?  Or the case where a keepalive was rightly timed out by the client.",
      "parentUuid": "b925826c_d74b8db5",
      "range": {
        "startLine": 10,
        "startChar": 17,
        "endLine": 11,
        "endChar": 26
      },
      "revId": "122f379bf286075a7aac335399f2d1fb28765c15",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4b47f701_861bd49f",
        "filename": "http/http_client.hpp",
        "patchSetId": 4
      },
      "lineNbr": 358,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-07-12T04:28:26Z",
      "side": 1,
      "message": "Now that this doesn\u0027t return early, this does nothing (which cppcheck will flag)",
      "range": {
        "startLine": 358,
        "startChar": 0,
        "endLine": 358,
        "endChar": 43
      },
      "revId": "122f379bf286075a7aac335399f2d1fb28765c15",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4bd45576_18c407ec",
        "filename": "http/http_client.hpp",
        "patchSetId": 4
      },
      "lineNbr": 358,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-07-12T16:07:44Z",
      "side": 1,
      "message": "I removed it",
      "parentUuid": "4b47f701_861bd49f",
      "range": {
        "startLine": 358,
        "startChar": 0,
        "endLine": 358,
        "endChar": 43
      },
      "revId": "122f379bf286075a7aac335399f2d1fb28765c15",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "db3f47b8_4b9fc75f",
        "filename": "http/http_client.hpp",
        "patchSetId": 4
      },
      "lineNbr": 382,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-07-12T04:28:26Z",
      "side": 1,
      "message": "Same here.",
      "range": {
        "startLine": 382,
        "startChar": 0,
        "endLine": 382,
        "endChar": 43
      },
      "revId": "122f379bf286075a7aac335399f2d1fb28765c15",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "24f963b3_9d358fd1",
        "filename": "http/http_client.hpp",
        "patchSetId": 4
      },
      "lineNbr": 382,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-07-12T16:07:44Z",
      "side": 1,
      "message": "I removed it",
      "parentUuid": "db3f47b8_4b9fc75f",
      "range": {
        "startLine": 382,
        "startChar": 0,
        "endLine": 382,
        "endChar": 43
      },
      "revId": "122f379bf286075a7aac335399f2d1fb28765c15",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}