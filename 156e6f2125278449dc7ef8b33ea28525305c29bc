{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "d8e66dd8_33ee98b7",
        "filename": "http/http_client.hpp",
        "patchSetId": 9
      },
      "lineNbr": 229,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-03-26T04:23:24Z",
      "side": 1,
      "message": "FYI, these type of captures are unsafe and should be avoided.  What was there was arguably more correct.  The qkward bit is that this will work 99% of the time in testing, but will cause rare and difficult to debug seg faults.",
      "range": {
        "startLine": 229,
        "startChar": 13,
        "endLine": 229,
        "endChar": 17
      },
      "revId": "156e6f2125278449dc7ef8b33ea28525305c29bc",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4f29b9da_64d957a6",
        "filename": "http/http_client.hpp",
        "patchSetId": 9
      },
      "lineNbr": 229,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-03-28T17:15:07Z",
      "side": 1,
      "message": "I was running into an issue where some of the member variables in ConnectionInfo were throwing errors if they were not initialized in the constructor while also being a member variable of another class. \n\nMy way around this was to instead use ConnectionInfo pointers inside ConnectionPool and then dynamically allocate a new ConnectionInfo object each time another one was needed.  However, this resulted in any calls to \"self(shared_from_this())\" throwing a weak_ptr exception due to the ConnectionInfo object being dynamically allocated.  Is there a way to convert this to a shared_ptr?",
      "parentUuid": "d8e66dd8_33ee98b7",
      "range": {
        "startLine": 229,
        "startChar": 13,
        "endLine": 229,
        "endChar": 17
      },
      "revId": "156e6f2125278449dc7ef8b33ea28525305c29bc",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0e5987b6_7c7fb362",
        "filename": "http/http_client.hpp",
        "patchSetId": 9
      },
      "lineNbr": 229,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-03-29T00:47:02Z",
      "side": 1,
      "message": "I was able to revert to capturing \"self(shared_from_this())\" rather than \"this\".  I did this by changing \"std::vector\u003cConnectionInfo*\u003e connections\" to \"std::vector\u003cstd::shared_ptr\u003cConnectionInfo\u003e\u003e\" and using \"make_shared\" when creating a new connection",
      "parentUuid": "4f29b9da_64d957a6",
      "range": {
        "startLine": 229,
        "startChar": 13,
        "endLine": 229,
        "endChar": 17
      },
      "revId": "156e6f2125278449dc7ef8b33ea28525305c29bc",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c42f3593_ba7d95d3",
        "filename": "http/http_client.hpp",
        "patchSetId": 9
      },
      "lineNbr": 229,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-03-29T01:53:57Z",
      "side": 1,
      "message": "yep, you got it.  to use shared_from_this the element has to be within a shared_ptr.",
      "parentUuid": "0e5987b6_7c7fb362",
      "range": {
        "startLine": 229,
        "startChar": 13,
        "endLine": 229,
        "endChar": 17
      },
      "revId": "156e6f2125278449dc7ef8b33ea28525305c29bc",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "99ff26c6_cb3aefc9",
        "filename": "http/http_client.hpp",
        "patchSetId": 9
      },
      "lineNbr": 308,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-03-24T23:51:45Z",
      "side": 1,
      "message": "Do I actually need to close this connection?",
      "range": {
        "startLine": 302,
        "startChar": 16,
        "endLine": 308,
        "endChar": 61
      },
      "revId": "156e6f2125278449dc7ef8b33ea28525305c29bc",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "819dba05_2f4570ff",
        "filename": "http/http_client.hpp",
        "patchSetId": 9
      },
      "lineNbr": 308,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-03-26T00:11:44Z",
      "side": 1,
      "message": "Per discussion with Ed, the connection should be closed.  The code has been updated to do that",
      "parentUuid": "99ff26c6_cb3aefc9",
      "range": {
        "startLine": 302,
        "startChar": 16,
        "endLine": 308,
        "endChar": 61
      },
      "revId": "156e6f2125278449dc7ef8b33ea28525305c29bc",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3c18966c_b51f53b5",
        "filename": "http/http_client.hpp",
        "patchSetId": 9
      },
      "lineNbr": 422,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-03-26T04:23:24Z",
      "side": 1,
      "message": "I realize this is still WIP, so feel free to ignore this for the moment, but your data structures above look like they assume only a single connection to a single client, and I think this is the most important data structure of this whole patch.  What I suspect you need to do is define a struct for looking up servers.  something like\n\nstruct HttpHost{\n   string hostname;\n   uint16_t port;\n}\n\nDefine an operator\u003c function for the above, then do something like:\n\nboost::container::flat_map\u003cHttpHost, std::vector\u003cstd::weak_ptr\u003cConnectionInfo\u003e\u003e\u003e\n\nIn general when a request needs to be performed you would do:\n\nLook through the struct and garbage collect connection weak_ptrs that need to be removed from the list (ie weak_ptr.lock() fails).\n\nLook up the key for this host, or create the key if it doesn\u0027t exist (ie try_emplace or operator[])\nloop over the connections to this host, and see if any connections exist that can be used.\nIf no connection to this host exists, create a new one and emplace it into the ConnectionInfo struct.\n\nAnother thing to note, this needs to have some kind of global scope so it can be shared across the bmc.",
      "range": {
        "startLine": 422,
        "startChar": 4,
        "endLine": 422,
        "endChar": 45
      },
      "revId": "156e6f2125278449dc7ef8b33ea28525305c29bc",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "030fb5c6_b78ba803",
        "filename": "http/http_client.hpp",
        "patchSetId": 9
      },
      "lineNbr": 422,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-03-30T00:01:47Z",
      "side": 1,
      "message": "I\u0027m assuming a single client to be denoted by its hostname:port pair.  ConnectionInfo is a single connection to a single client.  \n\nConnectionPool contains a vector of ConnectionInfo objects so it represents multiple connections to a single client.  \n\nHttpClient in Patchset9 contains a vector of ConnectionPool objects.  This has been changed to std::map as of Patchset 13.  Through this HttpClient allows multiple connections to multiple clients.\n\nHttpClient has also been implemented as a singleton to provide global access to sending requests.\n\nThe general process for sending a request is HttpClient\u0027s sendData() method now requires hostname and port arguments.  The hostname and port get concatenated to serve as the key hostnamePort. The \"std::map\u003chostnamePort,ConnectionPool\u003e connectionPools\" is checked for the hostnamePort key to see if the associated connection pool object exists.\n\nIf one exists then that ConnectionPool calls its own sendData() method which searches all of its connections for one that is not in use.  If a connection is not available then ConnectionPool will add a new connection to its pool and then use that connection to send the request.",
      "parentUuid": "3c18966c_b51f53b5",
      "range": {
        "startLine": 422,
        "startChar": 4,
        "endLine": 422,
        "endChar": 45
      },
      "revId": "156e6f2125278449dc7ef8b33ea28525305c29bc",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "65331b60_07156544",
        "filename": "http/http_client.hpp",
        "patchSetId": 9
      },
      "lineNbr": 422,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-05T21:18:09Z",
      "side": 1,
      "message": "\u003e \n\u003e ConnectionPool contains a vector of ConnectionInfo objects so it represents multiple connections to a single client.  \n\u003e \n\n\nI suspect I missed this subtlety the first time I reviewed this;  Seems like you have it under control.",
      "parentUuid": "030fb5c6_b78ba803",
      "range": {
        "startLine": 422,
        "startChar": 4,
        "endLine": 422,
        "endChar": 45
      },
      "revId": "156e6f2125278449dc7ef8b33ea28525305c29bc",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f74a6f3c_42a5c124",
        "filename": "http/http_client.hpp",
        "patchSetId": 9
      },
      "lineNbr": 422,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-04-05T22:37:45Z",
      "side": 1,
      "message": "No worries, it\u0027s a lot to parse so I appreciate the feedback",
      "parentUuid": "65331b60_07156544",
      "range": {
        "startLine": 422,
        "startChar": 4,
        "endLine": 422,
        "endChar": 45
      },
      "revId": "156e6f2125278449dc7ef8b33ea28525305c29bc",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "08c7a2c5_39bd79f9",
        "filename": "http/http_client.hpp",
        "patchSetId": 9
      },
      "lineNbr": 472,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-03-25T20:02:53Z",
      "side": 1,
      "message": "Is it alright to look up the io_context() each time instead of storing a copy of it?",
      "range": {
        "startLine": 472,
        "startChar": 31,
        "endLine": 472,
        "endChar": 71
      },
      "revId": "156e6f2125278449dc7ef8b33ea28525305c29bc",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3098e158_88adf509",
        "filename": "http/http_client.hpp",
        "patchSetId": 9
      },
      "lineNbr": 472,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-03-26T04:23:24Z",
      "side": 1,
      "message": "Yes, although you shouldn\u0027t be looking it up from the dbus connection while in the HTTP connection.  I would expect an http connection to be able to be instantiated without needing a dbus connection, which implies that you probably need to either grab it from the socket, or store a reference to it.",
      "parentUuid": "08c7a2c5_39bd79f9",
      "range": {
        "startLine": 472,
        "startChar": 31,
        "endLine": 472,
        "endChar": 71
      },
      "revId": "156e6f2125278449dc7ef8b33ea28525305c29bc",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f679512e_b44e8e63",
        "filename": "http/http_client.hpp",
        "patchSetId": 9
      },
      "lineNbr": 472,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-03-28T17:15:07Z",
      "side": 1,
      "message": "In that case I\u0027ll store a reference and use that whenever I need to add a new connection to the pool.",
      "parentUuid": "3098e158_88adf509",
      "range": {
        "startLine": 472,
        "startChar": 31,
        "endLine": 472,
        "endChar": 71
      },
      "revId": "156e6f2125278449dc7ef8b33ea28525305c29bc",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e66ca3f6_567ec469",
        "filename": "http/http_client.hpp",
        "patchSetId": 9
      },
      "lineNbr": 472,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-03-29T00:47:02Z",
      "side": 1,
      "message": "I changed the code as described",
      "parentUuid": "f679512e_b44e8e63",
      "range": {
        "startLine": 472,
        "startChar": 31,
        "endLine": 472,
        "endChar": 71
      },
      "revId": "156e6f2125278449dc7ef8b33ea28525305c29bc",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "567834a7_1f739889",
        "filename": "http/http_client.hpp",
        "patchSetId": 9
      },
      "lineNbr": 500,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-03-24T23:51:45Z",
      "side": 1,
      "message": "Should this be a map or flat_map?",
      "range": {
        "startLine": 500,
        "startChar": 0,
        "endLine": 500,
        "endChar": 48
      },
      "revId": "156e6f2125278449dc7ef8b33ea28525305c29bc",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3a6f635c_764ab3c8",
        "filename": "http/http_client.hpp",
        "patchSetId": 9
      },
      "lineNbr": 500,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-03-26T04:23:24Z",
      "side": 1,
      "message": "probably std::unordered_map if I had to guess.  There\u0027s no time when you\u0027re going to iterate the list, there\u0027s no need for it to be sorted, and lookups to it are going to be algorithmically rare so the standard one likely compiles smaller.  With that said, this is super unlikely to be in a hot loop, so I\u0027d be more worried about memory usage than anything.",
      "parentUuid": "567834a7_1f739889",
      "range": {
        "startLine": 500,
        "startChar": 0,
        "endLine": 500,
        "endChar": 48
      },
      "revId": "156e6f2125278449dc7ef8b33ea28525305c29bc",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fa04d21f_8cfa30ce",
        "filename": "http/http_client.hpp",
        "patchSetId": 9
      },
      "lineNbr": 500,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-03-28T17:15:07Z",
      "side": 1,
      "message": "I have a connectionPool for each destination host:port.  Each time a message is sent the first step is to look up the connection pool associated with the destination.  My worry with std::unordered_map is will a bmc typically have enough host:port destinations so that the hashing operation does not end up taking more time than would searching a map for a given host:port?",
      "parentUuid": "3a6f635c_764ab3c8",
      "range": {
        "startLine": 500,
        "startChar": 0,
        "endLine": 500,
        "endChar": 48
      },
      "revId": "156e6f2125278449dc7ef8b33ea28525305c29bc",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9fc84b6b_c08195e2",
        "filename": "http/http_client.hpp",
        "patchSetId": 9
      },
      "lineNbr": 500,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-03-30T00:01:47Z",
      "side": 1,
      "message": "In Patchset 13 I have modified this to be std::map instead of std::vector.  That\u0027s to keep it in line with the approach suggested in your above comment on line 422 as well as the discussions in https://gerrit.openbmc-project.xyz/c/openbmc/bmcweb/+/49667.",
      "parentUuid": "fa04d21f_8cfa30ce",
      "range": {
        "startLine": 500,
        "startChar": 0,
        "endLine": 500,
        "endChar": 48
      },
      "revId": "156e6f2125278449dc7ef8b33ea28525305c29bc",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "65014934_a0404b7f",
        "filename": "http/http_client.hpp",
        "patchSetId": 9
      },
      "lineNbr": 500,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-04-08T20:53:13Z",
      "side": 1,
      "message": "I\u0027m marking this as resolved since it is closely related to another comment suggesting I use unordered_map as the data structure.  That change has been made",
      "parentUuid": "9fc84b6b_c08195e2",
      "range": {
        "startLine": 500,
        "startChar": 0,
        "endLine": 500,
        "endChar": 48
      },
      "revId": "156e6f2125278449dc7ef8b33ea28525305c29bc",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}