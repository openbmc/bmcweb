{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "1e7091b8_628867ce",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 30
      },
      "lineNbr": 0,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-05-24T00:37:01Z",
      "side": 1,
      "message": "Aside from the general disagreement with the handling of `hostSocket` and the lack of generality wrt multiple consoles, this looks okay to me.",
      "revId": "8fa55b935f3d797459f5d2257215fc37db52a967",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a9cb000b_57fafb9a",
        "filename": "include/obmc_console.hpp",
        "patchSetId": 30
      },
      "lineNbr": 230,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-05-24T00:41:02Z",
      "side": 1,
      "message": "you need something to handle the case where two sockets connect at the same time.  If that happened while this dbus call was being done, you would have two dbus requests go out at the same moment, and they would collide on the other side.",
      "range": {
        "startLine": 214,
        "startChar": 0,
        "endLine": 230,
        "endChar": 19
      },
      "revId": "8fa55b935f3d797459f5d2257215fc37db52a967",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4bf7fc95_591574fe",
        "filename": "include/obmc_console.hpp",
        "patchSetId": 30
      },
      "lineNbr": 230,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-05-24T03:36:32Z",
      "side": 1,
      "message": "Can you clarify what you mean by collide on the other side? Isn\u0027t this case handled by the hostSocket null checks?",
      "parentUuid": "a9cb000b_57fafb9a",
      "range": {
        "startLine": 214,
        "startChar": 0,
        "endLine": 230,
        "endChar": 19
      },
      "revId": "8fa55b935f3d797459f5d2257215fc37db52a967",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "55a6bbe0_83c826fb",
        "filename": "include/obmc_console.hpp",
        "patchSetId": 30
      },
      "lineNbr": 230,
      "author": {
        "id": 1001634
      },
      "writtenOn": "2023-05-24T14:03:27Z",
      "side": 1,
      "message": "Ed, obmc-console already serializes requests on its end so there is no collition from obmc-console side. \n\nAndrew, Even if we have hostSocket check two request can check the hostSocket and it is null and went ahead and query the DBUS hence we need to handle it in the callback function itself.\n\nEd, Please correct me if I am wrong.",
      "parentUuid": "4bf7fc95_591574fe",
      "range": {
        "startLine": 214,
        "startChar": 0,
        "endLine": 230,
        "endChar": 19
      },
      "revId": "8fa55b935f3d797459f5d2257215fc37db52a967",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b20b8166_3f5656c1",
        "filename": "include/obmc_console.hpp",
        "patchSetId": 30
      },
      "lineNbr": 230,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-05-24T16:33:01Z",
      "side": 1,
      "message": "The flow here goes:\nonOpen called -\u003e dbus async_method_call #1\nonOpen called for 2nd connection -\u003e check on line 209 fires, but because it doesn\u0027t return, the read doesn\u0027t defer. Dbus async_method_call #2\n\nasync_method_call #1 returns, calls doRead, which calls     hostSocket-\u003easync_read_some( on line 83\n\ndbus async_method_call #2 returns, calls     hostSocket-\u003easync_read_some(\n AGAIN, which is already being read, and boom..... crash.\n\nOr am I missing something here?\n\nWhile normally I really do like incremental progress, i kind of wonder if we should just be focusing on getting the patch STACK correct here, because the possibility for the above flow goes completely away once the migration is made to session-level data structures instead of the global objects we have.\n\nidk, I\u0027m conflicted here.  I guess as written, I\u0027m ok with this merging, because the window for the race condition is going to be very very small. So long as there\u0027s quick followup to get us to the next \"correct\" iteration, I guess I\u0027m ok here..",
      "parentUuid": "55a6bbe0_83c826fb",
      "range": {
        "startLine": 214,
        "startChar": 0,
        "endLine": 230,
        "endChar": 19
      },
      "revId": "8fa55b935f3d797459f5d2257215fc37db52a967",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}