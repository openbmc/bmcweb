{
  "comments": [
    {
      "key": {
        "uuid": "df89cf61_fe322936",
        "filename": "include/vm_websocket.hpp",
        "patchSetId": 8
      },
      "lineNbr": 20,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2021-08-18T06:42:08Z",
      "side": 1,
      "message": "The document lists packets upto 2^25 or 32 MB. \n1. Where does the 128kB limit come from?\n2. Where does the 4 responses come from?\n\nBoth of these seem to be related to the implementation, possibly in the spawned nbd-proxy ?\n(not saying they are wrong just trying to understand)",
      "revId": "d6510a09ada8decb28af8aae7be8337ed29a12ea",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dabe62c6_d1f07ae0",
        "filename": "include/vm_websocket.hpp",
        "patchSetId": 8
      },
      "lineNbr": 20,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2021-08-19T03:20:19Z",
      "side": 1,
      "message": "1. Where does 128KB limit come from?\n- You might be right, the limitation seems to be a buffer size allocated in nbd-proxy https://github.com/openbmc/jsnbd/blob/master/nbd-proxy.c#L76 , but I didn\u0027t look into it.  However, we also found an issue in nbd-proxy splice system call yesterday, still investigating in this.\n\n2. Where does the 4 responses come from?\n- The original discussion is in Github: https://github.com/openbmc/bmcweb/issues/203, and 4 times buffer size is a sweet spot we found.",
      "parentUuid": "df89cf61_fe322936",
      "revId": "d6510a09ada8decb28af8aae7be8337ed29a12ea",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cb47fe44_77c94037",
        "filename": "include/vm_websocket.hpp",
        "patchSetId": 8
      },
      "lineNbr": 20,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2021-08-19T08:40:25Z",
      "side": 1,
      "message": "I just found out https://github.com/openbmc/bmcweb/blob/master/http/websocket.hpp#L75 here has allocate another 128KB+16Byte buffer... ðŸ˜“",
      "parentUuid": "dabe62c6_d1f07ae0",
      "revId": "d6510a09ada8decb28af8aae7be8337ed29a12ea",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8e2efd7a_c8f3c762",
        "filename": "include/vm_websocket.hpp",
        "patchSetId": 8
      },
      "lineNbr": 20,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2021-08-19T09:30:51Z",
      "side": 1,
      "message": "Ok, thanks for the pointers, it helped a lot.\n\nAfter looking at nbd-proxy, the kernel drivers/block/nbd.c, the kernel usb/gadget/functions/f_mass_storage.c and common-storage.h, I think this 128MB nbd request grouping is likely due the default size of the host sending to the \"scsi\" stack usb device and not an intentional buffer sizing or grouping.   Changing the queue tuning of the host may change the request boundaries.  (I\u0027m just scanning code; I don\u0027t have a system to trace.)\n\nJustification:  The usb gadget uses FSG_BUFSIZE\u003d16384 byte chunks, the request is whatever the host gave, the nbd takes the request, transmists an iov_iter to the network with the 16 byte header and then however many data chunks the network stack will take (with sizing).\n\nThe stack then seems to be nbd-client to unix socket to nbd-proxy to stdin/stdout pipes to this vm_websocket (with a static session) to Beast buffers to boost:asio to openssl and then over the network.\n\nThe fundamental problem is that the code tries to push too much in the flat buffer, and errors out instead of applying backpressure.\n\nHowever, everything is a stream once it goes through the nbd to socket code, and stays a stream until its parsed in the nbd server, which is the javascript code.\n\nIt might be the buffer you identified (Line 75) is larger than the flat buffer, \n\nBut it could also be that the buffer is not big enough for the websocket headers.  \n\nI have only skimmed websockets rfc but it appears to have variable size packet sizes, this code is just sending binary messages.  The TLS spec allows upto 2^14 bytes per TLS packet.  Both layers require knowing the size of data to be transmitted before transmitting a frame, and have hints to find that more data is immenent and the packet can grow.\n\nI will also note when reaching the end of the flat buffer it waits until its sent then shifts back; it\u0027s not a circular buffer stream.  Increasing the size of the buffer may increase the memmove overhead.",
      "parentUuid": "cb47fe44_77c94037",
      "revId": "d6510a09ada8decb28af8aae7be8337ed29a12ea",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    }
  ]
}