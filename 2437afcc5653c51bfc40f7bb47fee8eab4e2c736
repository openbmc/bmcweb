{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "499c91e3_19c48443",
        "filename": "http/http_client.hpp",
        "patchSetId": 27
      },
      "lineNbr": 246,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-05-24T14:49:59Z",
      "side": 1,
      "message": "Is this true in the aggregation case?  In theory we shouldn\u0027t be seeing 404 anywhere?",
      "range": {
        "startLine": 246,
        "startChar": 0,
        "endLine": 246,
        "endChar": 61
      },
      "revId": "2437afcc5653c51bfc40f7bb47fee8eab4e2c736",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c146b547_63c29227",
        "filename": "http/http_client.hpp",
        "patchSetId": 27
      },
      "lineNbr": 246,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-05-24T16:56:55Z",
      "side": 1,
      "message": "\u003e Is this true in the aggregation case?\nYes, because the aggregating BMC only knows if a request is meant for a satellite, not whether the requested resource exists on that satellite.  \n\n\u003e In theory we shouldn\u0027t be seeing 404 anywhere?\nIn theory a user should not request a 404, but it could happen due to something like typos while making manual queries.  If it does happen then the aggregator should just return the 404 from the satellite right away.  Otherwise we would exhaust the retry policy and return a 502.",
      "parentUuid": "499c91e3_19c48443",
      "range": {
        "startLine": 246,
        "startChar": 0,
        "endLine": 246,
        "endChar": 61
      },
      "revId": "2437afcc5653c51bfc40f7bb47fee8eab4e2c736",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a05b4574_3fe09f48",
        "filename": "http/http_client.hpp",
        "patchSetId": 27
      },
      "lineNbr": 246,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-05-27T18:41:16Z",
      "side": 1,
      "message": "\u003e \u003e Is this true in the aggregation case?\n\u003e Yes, because the aggregating BMC only knows if a request is meant for a satellite, not whether the requested resource exists on that satellite.  \n\u003e \n\u003e \u003e In theory we shouldn\u0027t be seeing 404 anywhere?\n\u003e In theory a user should not request a 404, but it could happen due to something like typos while making manual queries.  If it does happen then the aggregator should just return the 404 from the satellite right away.  Otherwise we would exhaust the retry policy and return a 502.\n\n\nDamn, this is another good reason we probably need to abstract the retry logic for each client.  EventService can\u0027t continue if it got 404, and should continue to retry.  Alternatively, we could add a flag to the retry policy to say if 404 is acceptable, but that kind of starts to get hacky.\n\nI\u0027m fine with either solution, but as written, pretty sure this breaks retry behavior on EventService.",
      "parentUuid": "c146b547_63c29227",
      "range": {
        "startLine": 246,
        "startChar": 0,
        "endLine": 246,
        "endChar": 61
      },
      "revId": "2437afcc5653c51bfc40f7bb47fee8eab4e2c736",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "214045dc_325b7341",
        "filename": "http/http_client.hpp",
        "patchSetId": 27
      },
      "lineNbr": 246,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-05-27T19:19:09Z",
      "side": 1,
      "message": "I don\u0027t want to use the flag option because there will likely be other error codes that need to be handled differently based on the application.  I will abstract the retry logic instead.\n\nI can add a callback to the retry policy which expects a response code and returns a bool based on if the value was acceptable.  The callback for EventService\u0027s policy would perform the existing check that considers 2XX as a success.  The callback for Aggregation\u0027s policy would consider 2XX and 404 as a success.\n\nI\u0027ll split this into its own patch while I\u0027m at it.",
      "parentUuid": "a05b4574_3fe09f48",
      "range": {
        "startLine": 246,
        "startChar": 0,
        "endLine": 246,
        "endChar": 61
      },
      "revId": "2437afcc5653c51bfc40f7bb47fee8eab4e2c736",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "19eb97d7_2d3a224c",
        "filename": "http/http_client.hpp",
        "patchSetId": 27
      },
      "lineNbr": 246,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-05-27T19:56:09Z",
      "side": 1,
      "message": "\u003e I don\u0027t want to use the flag option because there will likely be other error codes that need to be handled differently based on the application.  I will abstract the retry logic instead.\n\u003e \n\nSGTM.\n\n\u003e I can add a callback to the retry policy which expects a response code and returns a bool based on if the value was acceptable.\n\nSlight nit, please use std::error_code or boost::system::error_code (debatable which is more correct, we have both) instead of bool so that we can post specific failure types to the client (dns resolution failure, connect failure, tls failure, ect) and add to them over time.\n\n\u003e  The callback for EventService\u0027s policy would perform the existing check that considers 2XX as a success.  The callback for Aggregation\u0027s policy would consider 2XX and 404 as a success.\n\u003e \n\u003e I\u0027ll split this into its own patch while I\u0027m at it.\n\nSounds good.",
      "parentUuid": "214045dc_325b7341",
      "range": {
        "startLine": 246,
        "startChar": 0,
        "endLine": 246,
        "endChar": 61
      },
      "revId": "2437afcc5653c51bfc40f7bb47fee8eab4e2c736",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "eab21ef3_4bbe862d",
        "filename": "http/http_client.hpp",
        "patchSetId": 27
      },
      "lineNbr": 246,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-06-06T20:44:28Z",
      "side": 1,
      "message": "\u003e Slight nit, please use std::error_code or boost::system::error_code (debatable which is more correct, we have both) instead of bool so that we can post specific failure types to the client (dns resolution failure, connect failure, tls failure, ect) and add to them over time.\nSounds good.  I opted for the latter to be consistent with the rest of the file.  That change is now covered by an earlier patch in the chain: https://gerrit.openbmc.org/c/openbmc/bmcweb/+/54161",
      "parentUuid": "19eb97d7_2d3a224c",
      "range": {
        "startLine": 246,
        "startChar": 0,
        "endLine": 246,
        "endChar": 61
      },
      "revId": "2437afcc5653c51bfc40f7bb47fee8eab4e2c736",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2e5ef60d_7ad3f2e1",
        "filename": "http/http_client.hpp",
        "patchSetId": 27
      },
      "lineNbr": 456,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-05-24T14:49:59Z",
      "side": 1,
      "message": "Not quite following this.  I\u0027m assuming you\u0027re essentially doing the same thing as.\n\nconn-\u003ecallback \u003d nullptr;\n\nconsidering that tmp isn\u0027t used anywhere.  If we\u0027re needing to do this, we have some lifetime ownership issues that need sorted.  I suspect callback needs to own this connection by weak_ptr, not shared_ptr?",
      "range": {
        "startLine": 453,
        "startChar": 0,
        "endLine": 456,
        "endChar": 52
      },
      "revId": "2437afcc5653c51bfc40f7bb47fee8eab4e2c736",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ed201d46_9f30675f",
        "filename": "http/http_client.hpp",
        "patchSetId": 27
      },
      "lineNbr": 456,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-05-24T16:56:55Z",
      "side": 1,
      "message": "Yes, I should have used nullptr for that.  I\u0027ll try using weak_ptr and see if that can solves the lifetime issue.",
      "parentUuid": "2e5ef60d_7ad3f2e1",
      "range": {
        "startLine": 453,
        "startChar": 0,
        "endLine": 456,
        "endChar": 52
      },
      "revId": "2437afcc5653c51bfc40f7bb47fee8eab4e2c736",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2393f1be_acae1ff2",
        "filename": "http/http_client.hpp",
        "patchSetId": 27
      },
      "lineNbr": 456,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-05-27T18:41:16Z",
      "side": 1,
      "message": "üëç",
      "parentUuid": "ed201d46_9f30675f",
      "range": {
        "startLine": 453,
        "startChar": 0,
        "endLine": 456,
        "endChar": 52
      },
      "revId": "2437afcc5653c51bfc40f7bb47fee8eab4e2c736",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "405cd5f9_407500c8",
        "filename": "http/http_client.hpp",
        "patchSetId": 27
      },
      "lineNbr": 456,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-06-21T20:41:10Z",
      "side": 1,
      "message": "I\u0027m not sure if I can solve the issue by using weak_ptr.  I need the callback to own its copy of AsyncResp by shared_ptr because I need to make sure that the AsyncResp lives long enough for the callback to get called once a request is sent and a response is received.  That callback is potentially placed into a queue until the connection can take ownership of it.  \n\nIt seems like what I need to do is delete the callback (and thus the AsyncResp shared_ptr) after it gets called by the connection.  That guarantees that it stays alive only until it\u0027s used.  Without deleting the callback, it keeps AsyncResp alive even after the callback has been called.",
      "parentUuid": "2393f1be_acae1ff2",
      "range": {
        "startLine": 453,
        "startChar": 0,
        "endLine": 456,
        "endChar": 52
      },
      "revId": "2437afcc5653c51bfc40f7bb47fee8eab4e2c736",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}