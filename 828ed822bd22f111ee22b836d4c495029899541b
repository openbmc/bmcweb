{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "0517d6e3_ef4feb0e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 7
      },
      "lineNbr": 20,
      "author": {
        "id": 1000269
      },
      "writtenOn": "2022-09-12T17:03:00Z",
      "side": 1,
      "message": "This will have performance impact and can be used as Denial of service attack. \n\nWith this current implementation, I see resolve and connect is being attempted continuously without  1) Any time delay 2) No exhaust of retry \u0026 terminate/abort subscription.  So this make service busy always doing resolve \u0026 connect and Impact overall bmcweb performance \u0026 even BMC.( Ex: If someone created  max subscriptions to different IP:PORT which are not reachable.",
      "range": {
        "startLine": 18,
        "startChar": 58,
        "endLine": 20,
        "endChar": 10
      },
      "revId": "828ed822bd22f111ee22b836d4c495029899541b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e904604a_ba075bf0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 7
      },
      "lineNbr": 32,
      "author": {
        "id": 1000269
      },
      "writtenOn": "2022-09-12T17:03:00Z",
      "side": 1,
      "message": "Should cover some positive test cases as well.",
      "range": {
        "startLine": 28,
        "startChar": 0,
        "endLine": 32,
        "endChar": 11
      },
      "revId": "828ed822bd22f111ee22b836d4c495029899541b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9aaf9040_aa12c6a7",
        "filename": "http/http_client.hpp",
        "patchSetId": 7
      },
      "lineNbr": 206,
      "author": {
        "id": 1000269
      },
      "writtenOn": "2022-09-12T17:03:00Z",
      "side": 1,
      "message": "Who can abort the connection?  I we have transition states in sequential manner and when some connection is in specific stage( Say connectInProgress or HandShakeInprogress, We don\u0027t allow other connection).  So When exactly this case can hit?",
      "range": {
        "startLine": 206,
        "startChar": 44,
        "endLine": 206,
        "endChar": 61
      },
      "revId": "828ed822bd22f111ee22b836d4c495029899541b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e962927a_d067a67d",
        "filename": "http/http_client.hpp",
        "patchSetId": 7
      },
      "lineNbr": 206,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-09-15T19:56:15Z",
      "side": 1,
      "message": "We are now at the same time calling timer.async_wait() in addition to an async operation like boost::asio::async_connect().  The associated callbacks for each async operation will eventually get called no matter what.  In the timer callback \"onTimeout()\" we are able to recover from this by exiting immediately if the timer was cancelled rather than timing out.\n\nWe have to do a similar thing at the start of the async operation callbacks.  When we have one of those operations timeout we will proceed to close the connection and then retry to send the message.  Closing the connection will call the operation callback such as \"afterConnect()\" to then get called.  In that instance the connect operation was aborted because the connection was closed.\n\nIf we don\u0027t add these checks then we\u0027ll cause a fault and crash BMCWeb whenever we have an operation timeout.",
      "parentUuid": "9aaf9040_aa12c6a7",
      "range": {
        "startLine": 206,
        "startChar": 44,
        "endLine": 206,
        "endChar": 61
      },
      "revId": "828ed822bd22f111ee22b836d4c495029899541b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9537700d_0a44ac5c",
        "filename": "http/http_client.hpp",
        "patchSetId": 7
      },
      "lineNbr": 211,
      "author": {
        "id": 1000269
      },
      "writtenOn": "2022-09-12T17:03:00Z",
      "side": 1,
      "message": "Async timer has to be cancelled first irrespective if ec code. So this has to be moved above operation_aborted check.",
      "revId": "828ed822bd22f111ee22b836d4c495029899541b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6990f7d8_ef803774",
        "filename": "http/http_client.hpp",
        "patchSetId": 7
      },
      "lineNbr": 211,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-09-15T19:56:15Z",
      "side": 1,
      "message": "This is directly related to my above comment.  It\u0027s possible for us to reach \"afterConnect()\" after the timer has already expired.  In that case we\u0027re just wanting to leave this function without touching anything.  Cancelling the timer in this specific case could cause issues since either the timer is not running or it\u0027s running but as part of a different operation that\u0027s not connection.",
      "parentUuid": "9537700d_0a44ac5c",
      "revId": "828ed822bd22f111ee22b836d4c495029899541b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d620d655_6ff02ac0",
        "filename": "http/http_client.hpp",
        "patchSetId": 7
      },
      "lineNbr": 223,
      "author": {
        "id": 1000269
      },
      "writtenOn": "2022-09-12T17:03:00Z",
      "side": 1,
      "message": "BMCWEB_LOG_ERROR",
      "range": {
        "startLine": 223,
        "startChar": 16,
        "endLine": 223,
        "endChar": 32
      },
      "revId": "828ed822bd22f111ee22b836d4c495029899541b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "548ad7c6_2dd8d464",
        "filename": "http/http_client.hpp",
        "patchSetId": 7
      },
      "lineNbr": 223,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-09-15T19:56:15Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "d620d655_6ff02ac0",
      "range": {
        "startLine": 223,
        "startChar": 16,
        "endLine": 223,
        "endChar": 32
      },
      "revId": "828ed822bd22f111ee22b836d4c495029899541b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c75cf1db_4453e964",
        "filename": "http/http_client.hpp",
        "patchSetId": 7
      },
      "lineNbr": 225,
      "author": {
        "id": 1000269
      },
      "writtenOn": "2022-09-12T17:03:00Z",
      "side": 1,
      "message": "For safer side(To avoid race conditions), Set state to failed before performing any operation. (state \u003d ConnState::connectFailed;)",
      "revId": "828ed822bd22f111ee22b836d4c495029899541b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2e2dc468_747dddee",
        "filename": "http/http_client.hpp",
        "patchSetId": 7
      },
      "lineNbr": 225,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-09-15T19:56:15Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c75cf1db_4453e964",
      "revId": "828ed822bd22f111ee22b836d4c495029899541b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "19dc29ad_c1267b5c",
        "filename": "http/http_client.hpp",
        "patchSetId": 7
      },
      "lineNbr": 442,
      "author": {
        "id": 1000269
      },
      "writtenOn": "2022-09-12T17:03:00Z",
      "side": 1,
      "message": "Why only during connectInProgress? What if connection is made unreachable during write/read operations?",
      "revId": "828ed822bd22f111ee22b836d4c495029899541b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1dfed7e5_fc205efd",
        "filename": "http/http_client.hpp",
        "patchSetId": 7
      },
      "lineNbr": 442,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-09-15T19:56:15Z",
      "side": 1,
      "message": "Unreachable denotes that connection attempts timed out.  This is because we want to bypass needing to attempt to connect to an unresponsive destination each time we send a message.  As long as we are able to establish a connection then the server is not unreachable.\n\nOther operations like write or read could time out as well, but that doesn\u0027t mean the destination is unreachable.  We have no way of knowing if the operation timed out due to the server becoming unreachable or it timed out because of some other issue.  For example, the read could timeout on certain endpoints if the destination is not able to generate a response in a timely manner.  If the destination did in fact become unreachable then we\u0027ll catch that as part of the next message send attempt when we timeout during the connection attempt.",
      "parentUuid": "19dc29ad_c1267b5c",
      "revId": "828ed822bd22f111ee22b836d4c495029899541b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}