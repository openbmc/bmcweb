{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "0517d6e3_ef4feb0e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 7
      },
      "lineNbr": 20,
      "author": {
        "id": 1000269
      },
      "writtenOn": "2022-09-12T17:03:00Z",
      "side": 1,
      "message": "This will have performance impact and can be used as Denial of service attack. \n\nWith this current implementation, I see resolve and connect is being attempted continuously without  1) Any time delay 2) No exhaust of retry \u0026 terminate/abort subscription.  So this make service busy always doing resolve \u0026 connect and Impact overall bmcweb performance \u0026 even BMC.( Ex: If someone created  max subscriptions to different IP:PORT which are not reachable.",
      "range": {
        "startLine": 18,
        "startChar": 58,
        "endLine": 20,
        "endChar": 10
      },
      "revId": "828ed822bd22f111ee22b836d4c495029899541b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d16e8c2a_0dda6ecf",
        "filename": "/COMMIT_MSG",
        "patchSetId": 7
      },
      "lineNbr": 20,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-09-20T20:51:24Z",
      "side": 1,
      "message": "\u003e This will have performance impact \nThe performance impact is pretty minimal since you just have a single connection per IP:PORT asynchronously attempting to establish a connection.\n\n\u003e can be used as Denial of service attack.\n\u003e \n\u003e So this make service busy always doing resolve \u0026 connect and Impact overall bmcweb performance \u0026 even BMC.( Ex: If someone created  max subscriptions to different IP:PORT which are not reachable.\nI don\u0027t think that\u0027s true about DoS.  At a minimum this is not worse than what we have now.  Ignoring this change, BMCWeb should already be able to handle sending max subscriptions worth of simultaneous messages.\n\nFollowing your example, someone could create max subscriptions which use a retry policy with no time delay and a large enough number of retry attempts that they effectively won\u0027t be exhausted.  That would be the same idea as having an internal polling routine.  What\u0027s worse is the existing code does not ignore the retry policy for connection timeouts.  That means you could have an entire connection pool always trying to connect (i.e. MAX_SUBSCRIPTIONS * 4).\n\nAs events get triggered the message queues will expand until they reach the max number and start getting dropped.  At least with this change we\u0027ll be able to handle those future messages immediately rather than adding them to an ever growing queue.\n\n\u003e I see resolve and connect is being attempted continuously without  1) Any time delay 2) No exhaust of retry \u0026 terminate/abort subscription.\nWe do this because we want the internal polling routine to be able to detect the moment the destination becomes reachable.  If we 1) add a delay then there will be dead periods where we won\u0027t detect a destination has become reachable and thus erroneously return a 504.\n\nIf we 2) can exhaust the number of retry attempts then we won\u0027t be able to mark the destination as unreachable.  We would give up attempting to reach the destination at some point and then not be able to catch when it does become reachable.  We\u0027d have to clear the bool and allow future message sending attempts to attempt establish a connection to an unreachable destination.  At that point we\u0027re really not getting any benefit out of the changes in this patch.",
      "parentUuid": "0517d6e3_ef4feb0e",
      "range": {
        "startLine": 18,
        "startChar": 58,
        "endLine": 20,
        "endChar": 10
      },
      "revId": "828ed822bd22f111ee22b836d4c495029899541b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e904604a_ba075bf0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 7
      },
      "lineNbr": 32,
      "author": {
        "id": 1000269
      },
      "writtenOn": "2022-09-12T17:03:00Z",
      "side": 1,
      "message": "Should cover some positive test cases as well.",
      "range": {
        "startLine": 28,
        "startChar": 0,
        "endLine": 32,
        "endChar": 11
      },
      "revId": "828ed822bd22f111ee22b836d4c495029899541b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5cd2d4cf_845f55f0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 7
      },
      "lineNbr": 32,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-09-20T20:51:24Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "e904604a_ba075bf0",
      "range": {
        "startLine": 28,
        "startChar": 0,
        "endLine": 32,
        "endChar": 11
      },
      "revId": "828ed822bd22f111ee22b836d4c495029899541b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9aaf9040_aa12c6a7",
        "filename": "http/http_client.hpp",
        "patchSetId": 7
      },
      "lineNbr": 206,
      "author": {
        "id": 1000269
      },
      "writtenOn": "2022-09-12T17:03:00Z",
      "side": 1,
      "message": "Who can abort the connection?  I we have transition states in sequential manner and when some connection is in specific stage( Say connectInProgress or HandShakeInprogress, We don\u0027t allow other connection).  So When exactly this case can hit?",
      "range": {
        "startLine": 206,
        "startChar": 44,
        "endLine": 206,
        "endChar": 61
      },
      "revId": "828ed822bd22f111ee22b836d4c495029899541b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e962927a_d067a67d",
        "filename": "http/http_client.hpp",
        "patchSetId": 7
      },
      "lineNbr": 206,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-09-15T19:56:15Z",
      "side": 1,
      "message": "We are now at the same time calling timer.async_wait() in addition to an async operation like boost::asio::async_connect().  The associated callbacks for each async operation will eventually get called no matter what.  In the timer callback \"onTimeout()\" we are able to recover from this by exiting immediately if the timer was cancelled rather than timing out.\n\nWe have to do a similar thing at the start of the async operation callbacks.  When we have one of those operations timeout we will proceed to close the connection and then retry to send the message.  Closing the connection will call the operation callback such as \"afterConnect()\" to then get called.  In that instance the connect operation was aborted because the connection was closed.\n\nIf we don\u0027t add these checks then we\u0027ll cause a fault and crash BMCWeb whenever we have an operation timeout.",
      "parentUuid": "9aaf9040_aa12c6a7",
      "range": {
        "startLine": 206,
        "startChar": 44,
        "endLine": 206,
        "endChar": 61
      },
      "revId": "828ed822bd22f111ee22b836d4c495029899541b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9537700d_0a44ac5c",
        "filename": "http/http_client.hpp",
        "patchSetId": 7
      },
      "lineNbr": 211,
      "author": {
        "id": 1000269
      },
      "writtenOn": "2022-09-12T17:03:00Z",
      "side": 1,
      "message": "Async timer has to be cancelled first irrespective if ec code. So this has to be moved above operation_aborted check.",
      "revId": "828ed822bd22f111ee22b836d4c495029899541b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6990f7d8_ef803774",
        "filename": "http/http_client.hpp",
        "patchSetId": 7
      },
      "lineNbr": 211,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-09-15T19:56:15Z",
      "side": 1,
      "message": "This is directly related to my above comment.  It\u0027s possible for us to reach \"afterConnect()\" after the timer has already expired.  In that case we\u0027re just wanting to leave this function without touching anything.  Cancelling the timer in this specific case could cause issues since either the timer is not running or it\u0027s running but as part of a different operation that\u0027s not connection.",
      "parentUuid": "9537700d_0a44ac5c",
      "revId": "828ed822bd22f111ee22b836d4c495029899541b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d620d655_6ff02ac0",
        "filename": "http/http_client.hpp",
        "patchSetId": 7
      },
      "lineNbr": 223,
      "author": {
        "id": 1000269
      },
      "writtenOn": "2022-09-12T17:03:00Z",
      "side": 1,
      "message": "BMCWEB_LOG_ERROR",
      "range": {
        "startLine": 223,
        "startChar": 16,
        "endLine": 223,
        "endChar": 32
      },
      "revId": "828ed822bd22f111ee22b836d4c495029899541b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "548ad7c6_2dd8d464",
        "filename": "http/http_client.hpp",
        "patchSetId": 7
      },
      "lineNbr": 223,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-09-15T19:56:15Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "d620d655_6ff02ac0",
      "range": {
        "startLine": 223,
        "startChar": 16,
        "endLine": 223,
        "endChar": 32
      },
      "revId": "828ed822bd22f111ee22b836d4c495029899541b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c75cf1db_4453e964",
        "filename": "http/http_client.hpp",
        "patchSetId": 7
      },
      "lineNbr": 225,
      "author": {
        "id": 1000269
      },
      "writtenOn": "2022-09-12T17:03:00Z",
      "side": 1,
      "message": "For safer side(To avoid race conditions), Set state to failed before performing any operation. (state \u003d ConnState::connectFailed;)",
      "revId": "828ed822bd22f111ee22b836d4c495029899541b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2e2dc468_747dddee",
        "filename": "http/http_client.hpp",
        "patchSetId": 7
      },
      "lineNbr": 225,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-09-15T19:56:15Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c75cf1db_4453e964",
      "revId": "828ed822bd22f111ee22b836d4c495029899541b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "19dc29ad_c1267b5c",
        "filename": "http/http_client.hpp",
        "patchSetId": 7
      },
      "lineNbr": 442,
      "author": {
        "id": 1000269
      },
      "writtenOn": "2022-09-12T17:03:00Z",
      "side": 1,
      "message": "Why only during connectInProgress? What if connection is made unreachable during write/read operations?",
      "revId": "828ed822bd22f111ee22b836d4c495029899541b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1dfed7e5_fc205efd",
        "filename": "http/http_client.hpp",
        "patchSetId": 7
      },
      "lineNbr": 442,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-09-15T19:56:15Z",
      "side": 1,
      "message": "Unreachable denotes that connection attempts timed out.  This is because we want to bypass needing to attempt to connect to an unresponsive destination each time we send a message.  As long as we are able to establish a connection then the server is not unreachable.\n\nOther operations like write or read could time out as well, but that doesn\u0027t mean the destination is unreachable.  We have no way of knowing if the operation timed out due to the server becoming unreachable or it timed out because of some other issue.  For example, the read could timeout on certain endpoints if the destination is not able to generate a response in a timely manner.  If the destination did in fact become unreachable then we\u0027ll catch that as part of the next message send attempt when we timeout during the connection attempt.",
      "parentUuid": "19dc29ad_c1267b5c",
      "revId": "828ed822bd22f111ee22b836d4c495029899541b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}