{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "11fd70ee_1af487c9",
        "filename": "/COMMIT_MSG",
        "patchSetId": 10
      },
      "lineNbr": 9,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2026-02-27T19:38:43Z",
      "side": 1,
      "message": "Remove.  Please write in prose, not in headlines.",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 9,
        "endChar": 46
      },
      "revId": "d4cdf4ef12130dd89308081bd30bbbac07f36495",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d9cc5b17_b8be5dbf",
        "filename": "/COMMIT_MSG",
        "patchSetId": 10
      },
      "lineNbr": 16,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2026-02-27T19:38:43Z",
      "side": 1,
      "message": "What result does this have on the subscription?  On a host server going down, eventually all connections will drop, right?",
      "range": {
        "startLine": 13,
        "startChar": 61,
        "endLine": 16,
        "endChar": 9
      },
      "revId": "d4cdf4ef12130dd89308081bd30bbbac07f36495",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "67e9900e_7799a078",
        "filename": "/COMMIT_MSG",
        "patchSetId": 10
      },
      "lineNbr": 38,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2026-02-27T19:38:43Z",
      "side": 1,
      "message": "This reads a lot like it was written by an LLM.  Use of LLMs are wonderful tools, but please make sure you\u0027re personally reviewing it for correctness before making maintainers review it.\n\nThis line for example appears to be a hallucination, there are no changes to isTerminated in this patchset.",
      "revId": "d4cdf4ef12130dd89308081bd30bbbac07f36495",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "028bc3aa_bd0f7ae6",
        "filename": "/COMMIT_MSG",
        "patchSetId": 10
      },
      "lineNbr": 54,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2026-02-27T19:38:43Z",
      "side": 1,
      "message": "Internal logging is not a functional test, which is what we expect for these kinds of things.  Please read TESTING.md",
      "range": {
        "startLine": 51,
        "startChar": 43,
        "endLine": 54,
        "endChar": 28
      },
      "revId": "d4cdf4ef12130dd89308081bd30bbbac07f36495",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ec0ba142_d68d2610",
        "filename": "/COMMIT_MSG",
        "patchSetId": 10
      },
      "lineNbr": 75,
      "author": {
        "id": 1001604
      },
      "writtenOn": "2026-02-27T18:19:42Z",
      "side": 1,
      "message": "Please add \"Tested:\" section.\n- An example of setup/scenario and verification for the case.\n- Redfish Service Validator verification.",
      "revId": "d4cdf4ef12130dd89308081bd30bbbac07f36495",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1ea0a020_ae53f80b",
        "filename": "http/http_client.hpp",
        "patchSetId": 10
      },
      "lineNbr": 713,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2026-02-27T19:38:43Z",
      "side": 1,
      "message": "Doesn\u0027t this break retries though?  Right now the connections lifetime is infinite and they are reused.",
      "range": {
        "startLine": 713,
        "startChar": 11,
        "endLine": 713,
        "endChar": 46
      },
      "revId": "d4cdf4ef12130dd89308081bd30bbbac07f36495",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bc81d853_95c6000a",
        "filename": "http/http_client.hpp",
        "patchSetId": 10
      },
      "lineNbr": 806,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2026-02-27T19:39:23Z",
      "side": 1,
      "message": "Not necessarily it doesn\u0027t.  Connections are not required to support keepalive.",
      "range": {
        "startLine": 804,
        "startChar": 33,
        "endLine": 806,
        "endChar": 30
      },
      "revId": "d4cdf4ef12130dd89308081bd30bbbac07f36495",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "81475e48_6d50e228",
        "filename": "http/http_client.hpp",
        "patchSetId": 10
      },
      "lineNbr": 822,
      "author": {
        "id": 1001604
      },
      "writtenOn": "2026-02-09T15:57:37Z",
      "side": 1,
      "message": "I\u0027m not sure whether this code block L809-L822 is correct?\nIf there are multiple connections and one of them is `terminated`, I think this code block may cause the bad_gateway even if the connection is for the different target??\nCan this block L809-L822 is removed?",
      "range": {
        "startLine": 809,
        "startChar": 0,
        "endLine": 822,
        "endChar": 13
      },
      "revId": "d4cdf4ef12130dd89308081bd30bbbac07f36495",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ffd97eea_6b12a6a1",
        "filename": "http/http_client.hpp",
        "patchSetId": 10
      },
      "lineNbr": 822,
      "author": {
        "id": 1001604
      },
      "writtenOn": "2026-02-09T16:11:39Z",
      "side": 1,
      "message": "Furthermore, bad_gateway result must already been sent - if the state is `ConnState::terminated`.\n\nhttps://github.com/openbmc/bmcweb/blob/433c9193b0d086f009d53a5860f1ee586cf45792/http/http_client.hpp#L480",
      "parentUuid": "81475e48_6d50e228",
      "range": {
        "startLine": 809,
        "startChar": 0,
        "endLine": 822,
        "endChar": 13
      },
      "revId": "d4cdf4ef12130dd89308081bd30bbbac07f36495",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4271c9b8_83039b93",
        "filename": "http/http_client.hpp",
        "patchSetId": 10
      },
      "lineNbr": 822,
      "author": {
        "id": 1002825
      },
      "writtenOn": "2026-02-10T14:46:03Z",
      "side": 1,
      "message": "As far as I understand, all connections within a single ConnectionPool share the same destination. So a terminated connection in the pool always corresponds to the same target as all other connections.\n\nThis code block is only reached when no existing connection is in an idle, initialized, or closed state - meaning all connections are in transient or failure states (connectFailed, sendFailed, recvFailed, terminated, etc.) and at least one of them is terminated. Since we already know the destination is unreachable (at least one connection exhausted all retry attempts), creating new connections would only grow the pool with doomed connections that will also inevitably fail.\n\nWithout this block, each time a new event arrives, sendData() would create another connection via addConnection() because none of the existing connections match the idle/initialized/closed check. The pool keeps growing until maxConnections is reached, and only then - after every single connection independently exhausts its own retry cycle - can areAllConnectionsTerminated() finally return true.\n\nHere are the logs from a test run with only the sendNext() fix but without this block - you can see the pool growing by one connection every ~10 seconds as events keep arriving:\n\n15:28:22  conn[0] terminated  → pool: 4 conns [15, 4, 4, 4]\n15:28:32  conn[4] created     → pool: 5 conns [15, 15, 4, 4, 4]\n15:28:42  conn[5] created     → pool: 6 conns [15, 15, 15, 4, 4, 4]\n15:28:52  conn[6] created     → pool: 7 conns [15, 15, 15, 15, 4, 4, 4]\n15:29:02  conn[7] created     → pool: 8 conns [15, 15, 15, 15, 15, 4, 4, 4]\n...\n15:29:42  conn[11] created    → pool: 12 conns [15,15,15,15,15,15,15,15,15, 4, 4, 4]\n\nThis would continue all the way up to maxConnections, with each new connection doomed to fail against the same unreachable destination. With the block in place, the pool stays at 4 connections and the subscription is cleaned up as soon as all 4 reach terminated. That said, this block could technically be removed - the subscription would still eventually be cleaned up once the pool hits maxConnections and all connections exhaust their retries. However, based on the logs above, that would delay subscription removal by couple of minutes compared to the immediate cleanup with this block in place.\n\n\nYou\u0027re right that waitAndRetry() already sends bad_gateway via callback() when a connection reaches terminated - but that response is for the request that was being processed when retries were exhausted.\n\nThe dummyRes here serves a different purpose: it responds to the new event that just arrived via sendData(). Since we\u0027re declining to create a connection for it (destination is known - unreachable), we still need to invoke resHandler to fulfill the callback contract and - more importantly - to trigger the isTerminated() check in Subscription::resHandler(), which is how subscription cleanup gets initiated.",
      "parentUuid": "ffd97eea_6b12a6a1",
      "range": {
        "startLine": 809,
        "startChar": 0,
        "endLine": 822,
        "endChar": 13
      },
      "revId": "d4cdf4ef12130dd89308081bd30bbbac07f36495",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1e59a3ae_952f3b18",
        "filename": "http/http_client.hpp",
        "patchSetId": 10
      },
      "lineNbr": 822,
      "author": {
        "id": 1001604
      },
      "writtenOn": "2026-02-19T15:11:44Z",
      "side": 1,
      "message": "\u003eThis code block is only reached when no existing connection is in an idle, initialized, or closed state - meaning all connections are in transient or failure states (connectFailed, sendFailed, recvFailed, terminated, etc.) and at least one of them is terminated. \n\u003e...\n\u003eWithout this block, each time a new event arrives, sendData() would create another connection via addConnection() because none of the existing connections match the idle/initialized/closed check. \n\n\u003e ...\n\n\u003eThis would continue all the way up to maxConnections, with each new connection doomed to fail against the same unreachable destination.  ...\n\nSo, the goal is to hit \u0027maxRetry\u0027 situation before hitting maxConnection, right?\n\nDoes this mean that sendData() should try again to \u0027maxRetry\u0027 before creating a new connection?\n\nIn other words, something like\n\n```\nsendData(...)\n{\n\n     // Reuse an existing connection if one is available\n        for (unsigned int i \u003d 0; i \u003c connections.size(); i++)\n        {\n            auto conn \u003d connections[i];\n            if (conn-\u003estate \u003d\u003d ConnState::terminated)  \u0026\u0026 \n                (retryCount \u003c MaxRetry...) ) \n            {\n                  waitAndRetry();  //with some modification\n                  return;\n            }\n\n\n```",
      "parentUuid": "4271c9b8_83039b93",
      "range": {
        "startLine": 809,
        "startChar": 0,
        "endLine": 822,
        "endChar": 13
      },
      "revId": "d4cdf4ef12130dd89308081bd30bbbac07f36495",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "907be2ee_44b256a9",
        "filename": "http/http_client.hpp",
        "patchSetId": 10
      },
      "lineNbr": 822,
      "author": {
        "id": 1002825
      },
      "writtenOn": "2026-02-19T16:05:13Z",
      "side": 1,
      "message": "Let me clarify how connection states relate to this logic:\n\nConnection states fall into three categories:\n\nAvailable (idle/initialized/closed) - Ready to accept new requests. If any connection is in one of these states, sendData() assigns the incoming event to it immediately.\n\nIn-progress (failure states like connectFailed/sendFailed/recvFailed, etc.) - Currently processing a request within the retry loop. These connections will either succeed and return to an available state, or exhaust their retries and become terminated.\n\nTerminated - Has exhausted all retry attempts. This state serves as confirmation that the destination is unreachable.\n\nAddressing your question about retry in sendData():\n\nNo, sendData() should not perform retries itself. The retry logic belongs to ConnectionInfo::waitAndRetry() and operates on connections that are already processing a request.\n\nWhen sendData() receives a new event, it cannot call waitAndRetry() because the new event has no associated connection yet and retryCount belongs to individual connections, not to incoming requests.\n\nThe goal is not \"hit maxRetry before maxConnection.\" The goal is: once any connection has already hit maxRetry (i.e., reached terminated), don\u0027t create more connections - because that connection has already proven the destination is unreachable.\n\nConnections in connectFailed state are still actively retrying their own request. Creating a new connection in parallel is acceptable because the destination reachability is not yet confirmed. Only terminated provides that confirmation.\n\nNote: Currently, once a connection reaches terminated state, there is no recovery path - the connection will remain in terminated state even if the destination becomes reachable again. A future enhancement could consider resetting terminated connections if the destination becomes reachable again, but that would require additional logic to detect recovery and is outside the scope of this fix.",
      "parentUuid": "1e59a3ae_952f3b18",
      "range": {
        "startLine": 809,
        "startChar": 0,
        "endLine": 822,
        "endChar": 13
      },
      "revId": "d4cdf4ef12130dd89308081bd30bbbac07f36495",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "291dcf74_9a837ce2",
        "filename": "http/http_client.hpp",
        "patchSetId": 10
      },
      "lineNbr": 822,
      "author": {
        "id": 1001604
      },
      "writtenOn": "2026-02-27T18:19:42Z",
      "side": 1,
      "message": "\u003eThe goal is not \"hit maxRetry before maxConnection.\" The goal is: once any connection has already hit maxRetry (i.e., reached terminated), don\u0027t create more connections - because that connection has already proven the destination is unreachable.\n\n\nUnderstood and agreed.",
      "parentUuid": "907be2ee_44b256a9",
      "range": {
        "startLine": 809,
        "startChar": 0,
        "endLine": 822,
        "endChar": 13
      },
      "revId": "d4cdf4ef12130dd89308081bd30bbbac07f36495",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}