{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "ae42079e_ae566188",
        "filename": "redfish-core/include/utils/json_utils.hpp",
        "patchSetId": 3
      },
      "lineNbr": 496,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-05-02T05:27:43Z",
      "side": 1,
      "message": "By design readjson should never allow unknown values.\n\nEither we know what value is read, or we host an error.",
      "range": {
        "startLine": 496,
        "startChar": 40,
        "endLine": 496,
        "endChar": 56
      },
      "revId": "945d3454aea1186bedda62cf510a2514d647bb9a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0e5af24a_f80e3ec2",
        "filename": "redfish-core/include/utils/json_utils.hpp",
        "patchSetId": 3
      },
      "lineNbr": 496,
      "author": {
        "id": 1001486
      },
      "writtenOn": "2025-05-02T16:16:46Z",
      "side": 1,
      "message": "The default design remains the same with readJsonHelperObject when allowUnknownKeys is false. \nWhen we read a fragment of a JSON object (in sub router handlers), the caller will pass what keys to be extracted which we undergo type check but if there are other keys which is not passed by the caller the flag allowUnknownKeys allows not to throw error on that.\nthis API with  allowUnknownKeys set to true is used by readJsonSubObject where the goal is to read fragment inside the object. \nI can write new API for this but thought to reuse the code with readJsonHelperObject.\nLet me know your thoughts.",
      "parentUuid": "ae42079e_ae566188",
      "range": {
        "startLine": 496,
        "startChar": 40,
        "endLine": 496,
        "endChar": 56
      },
      "revId": "945d3454aea1186bedda62cf510a2514d647bb9a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f63c707d_f4192adc",
        "filename": "redfish-core/include/utils/json_utils.hpp",
        "patchSetId": 3
      },
      "lineNbr": 496,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-05-02T17:30:20Z",
      "side": 1,
      "message": "\u003e The default design remains the same with readJsonHelperObject when allowUnknownKeys is false. \n\u003e When we read a fragment of a JSON object (in sub router handlers), the caller will pass what keys to be extracted which we undergo type check but if there are other keys which is not passed by the caller the flag allowUnknownKeys allows not to throw error on that.\n\nAt the top level, when we read as an object_t, keys within that object aren\u0027t enforced, right?\n\n\u003e this API with  allowUnknownKeys set to true is used by readJsonSubObject where the goal is to read fragment inside the object.\n\u003e I can write new API for this but thought to reuse the code with readJsonHelperObject.\n\u003e Let me know your thoughts.\n\n\nI do want to reuse code, but the flow I would\u0027ve expected is:\n\nnlohmann::json::object_t obj;\nreadJson(...., \"Oem/Nvidia\", obj);\n\n\n// Then in the oem handler\nreadJsonObj(obj, \"NVKey\", ...);\n\n\nThat doesn\u0027t require parsing any key twice.  That\u0027s the whole point of being able to parse object_t.",
      "parentUuid": "0e5af24a_f80e3ec2",
      "range": {
        "startLine": 496,
        "startChar": 40,
        "endLine": 496,
        "endChar": 56
      },
      "revId": "945d3454aea1186bedda62cf510a2514d647bb9a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2b49d0d7_6ba309d8",
        "filename": "redfish-core/include/utils/json_utils.hpp",
        "patchSetId": 3
      },
      "lineNbr": 496,
      "author": {
        "id": 1001486
      },
      "writtenOn": "2025-05-03T08:26:14Z",
      "side": 1,
      "message": "Here the current flow we have. \n\nStep 1. \nThe main route handler validates all OEM schema and all Keys. Any missing key on non compliance will be caught here. \n\nStep 2. \nOem router extracts OEM object from the payload and stores that in the subRequest object. We pass the same subRequest object to all OEM route handlers. So we pass the same OEM object to oem route handler1, route handler2 etc. All routes handlers are registered for the same URI and they manager sub segments of the OEM object. \nSo the OEM object at SubRequest level would be something like this \n```\nOem:{\n OpenBmc: {Key1:value1},\n Nvidia: {Key2:value2}\n}\n```\n\nStep 3.\nOEM handler will be called with OEM payload we have above and we need API to read only the Keys OEM sub handler needs. What I know is that we don\u0027t have API today which can read sub objects. \nreadJson(...., \"Oem/Nvidia\", obj); would throw error if there is Oem/OpenBMC also present in the object. \n\nAlternatively OEM at Router level split the sub object like OpenBMC, Nvidia, etc and pass only sub objects to each sub router handler. This was also my very initial patch but I feel this is very complex code for debugging as this would happen at route level. \n\nIf my OEM object is compliant (does not any invalid keys) as this is validated by the main router. I feel the current patch is much simpler to just have same OEM object passed to each sub router handler. \n\nPlease let me know what you feel.",
      "parentUuid": "f63c707d_f4192adc",
      "range": {
        "startLine": 496,
        "startChar": 40,
        "endLine": 496,
        "endChar": 56
      },
      "revId": "945d3454aea1186bedda62cf510a2514d647bb9a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ffb33db1_1e2a2e3d",
        "filename": "redfish-core/include/utils/json_utils.hpp",
        "patchSetId": 3
      },
      "lineNbr": 927,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-05-02T05:27:43Z",
      "side": 1,
      "message": "Why are we packing a new variant here?  Something seems odd if we can\u0027t reuse the vairant pack?",
      "range": {
        "startLine": 927,
        "startChar": 4,
        "endLine": 927,
        "endChar": 15
      },
      "revId": "945d3454aea1186bedda62cf510a2514d647bb9a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "869d806b_71ff8a7b",
        "filename": "redfish-core/include/utils/json_utils.hpp",
        "patchSetId": 3
      },
      "lineNbr": 927,
      "author": {
        "id": 1001486
      },
      "writtenOn": "2025-05-02T16:16:46Z",
      "side": 1,
      "message": "this API is exactly same as readJsonObject. Only diff is it uses readJsonHelperObject with allowUnknownKeys flag set to true. This allows parsing fragment of the object.",
      "parentUuid": "ffb33db1_1e2a2e3d",
      "range": {
        "startLine": 927,
        "startChar": 4,
        "endLine": 927,
        "endChar": 15
      },
      "revId": "945d3454aea1186bedda62cf510a2514d647bb9a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e6a2758d_1ce1d4c1",
        "filename": "redfish-core/include/utils/json_utils.hpp",
        "patchSetId": 3
      },
      "lineNbr": 927,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-05-02T17:30:20Z",
      "side": 1,
      "message": "Sure, lets close on the other comment.",
      "parentUuid": "869d806b_71ff8a7b",
      "range": {
        "startLine": 927,
        "startChar": 4,
        "endLine": 927,
        "endChar": 15
      },
      "revId": "945d3454aea1186bedda62cf510a2514d647bb9a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}