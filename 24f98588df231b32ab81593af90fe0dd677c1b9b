{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "04bf3540_eab6aadd",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 9,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-01-10T23:06:50Z",
      "side": 1,
      "message": "Can you please add more details here?  In theory all modes need to validate parameters at some level, so I suspect we just need a little more explaination of \"why\" in this commit.",
      "range": {
        "startLine": 9,
        "startChar": 26,
        "endLine": 9,
        "endChar": 62
      },
      "revId": "24f98588df231b32ab81593af90fe0dd677c1b9b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d454f321_dd01f527",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 9,
      "author": {
        "id": 1000460
      },
      "writtenOn": "2023-01-12T14:36:04Z",
      "side": 1,
      "message": "Let me describe. \n\nAccording to the design, there are two ways how to initiate virtual media requests. First is initiated by redfish action (legacy mode) and second (proxy mode) using websocket. \nAs proxy mode is not initiated using redfish, requests for appropriate action with proxy mode endpoint needs to be denied with appropriate response message and code. At the moment when we parse the parameters, we do not know which type of endpoint we operate on. That\u0027s why we pass the empty actionParams parameter to the place where such decision could be made, and the appropriate exit code can be passed to the user. Validation is added in other patches.\n\nI will extend the description, hope above gave you some more insight.\n\nBtw, VM backend is available as review request chain in jsnbd repo, so if you want to play around - it is possible now.",
      "parentUuid": "04bf3540_eab6aadd",
      "range": {
        "startLine": 9,
        "startChar": 26,
        "endLine": 9,
        "endChar": 62
      },
      "revId": "24f98588df231b32ab81593af90fe0dd677c1b9b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1f6772fd_f139f0bc",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 9,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-01-13T18:30:31Z",
      "side": 1,
      "message": "\u003e Let me describe. \n\u003e \n\u003e According to the design, there are two ways how to initiate virtual media requests. First is initiated by redfish action (legacy mode) and second (proxy mode) using websocket. \n\n\nWhy does the websocket take the redfish path?\n\n\u003e As proxy mode is not initiated using redfish, requests for appropriate action with proxy mode endpoint needs to be denied with appropriate response message and code.\n\nWhy do the proxy mode endpoints need represented in redfish at all?  What\u0027s the use case?\n\n\u003e At the moment when we parse the parameters, we do not know which type of endpoint we operate on. That\u0027s why we pass the empty actionParams parameter to the place where such decision could be made, and the appropriate exit code can be passed to the user. Validation is added in other patches.\n\nACK\n\n\u003e \n\u003e I will extend the description, hope above gave you some more insight.\n\u003e \n\u003e Btw, VM backend is available as review request chain in jsnbd repo, so if you want to play around - it is possible now.",
      "parentUuid": "d454f321_dd01f527",
      "range": {
        "startLine": 9,
        "startChar": 26,
        "endLine": 9,
        "endChar": 62
      },
      "revId": "24f98588df231b32ab81593af90fe0dd677c1b9b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8d056327_a8f5fbf6",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 9,
      "author": {
        "id": 1000460
      },
      "writtenOn": "2023-01-13T19:04:14Z",
      "side": 1,
      "message": "\u003e \u003e Let me describe. \n\u003e \u003e \n\u003e \u003e According to the design, there are two ways how to initiate virtual media requests. First is initiated by redfish action (legacy mode) and second (proxy mode) using websocket. \n\u003e \n\u003e \n\u003e Why does the websocket take the redfish path?\n\nNo, it does not. For proxy mode we just open /nbd/X websocket to initiate connection. \n\n\u003e \n\u003e \u003e As proxy mode is not initiated using redfish, requests for appropriate action with proxy mode endpoint needs to be denied with appropriate response message and code.\n\u003e \n\u003e Why do the proxy mode endpoints need represented in redfish at all?  What\u0027s the use case? \n\nRedfish could be used to:\n- check if there are any and if so - how many slots are available for each type/mode\n- check current status in each node\n- disconnect current connection\n\nAll is covered in the design document (https://github.com/openbmc/docs/blob/master/designs/virtual-media.md).",
      "parentUuid": "1f6772fd_f139f0bc",
      "range": {
        "startLine": 9,
        "startChar": 26,
        "endLine": 9,
        "endChar": 62
      },
      "revId": "24f98588df231b32ab81593af90fe0dd677c1b9b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c67d1d54_473a0573",
        "filename": "redfish-core/lib/virtual_media.hpp",
        "patchSetId": 1
      },
      "lineNbr": 777,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-01-13T18:18:24Z",
      "side": 1,
      "message": "Needs error checked before dereferencing on line 781",
      "range": {
        "startLine": 777,
        "startChar": 43,
        "endLine": 777,
        "endChar": 55
      },
      "revId": "24f98588df231b32ab81593af90fe0dd677c1b9b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c8bff8ba_7f6914f4",
        "filename": "redfish-core/lib/virtual_media.hpp",
        "patchSetId": 1
      },
      "lineNbr": 777,
      "author": {
        "id": 1000460
      },
      "writtenOn": "2023-01-13T19:17:41Z",
      "side": 1,
      "message": "It is just an std::optional initialized with simple struct. What could possibly go wrong here? Shall I check it against std::nullopt?",
      "parentUuid": "c67d1d54_473a0573",
      "range": {
        "startLine": 777,
        "startChar": 43,
        "endLine": 777,
        "endChar": 55
      },
      "revId": "24f98588df231b32ab81593af90fe0dd677c1b9b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "72d01446_f4ca6885",
        "filename": "redfish-core/lib/virtual_media.hpp",
        "patchSetId": 1
      },
      "lineNbr": 777,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-01-13T20:39:01Z",
      "side": 1,
      "message": "ah, gotcha.  I was reading InsertMediaActionParams as a method, not a constructor.  I suspect what you want here is to make all the elements within InsertMediaActionParams take std::optional (because that\u0027s your intent, for all parameters to be optional), then",
      "parentUuid": "c67d1d54_473a0573",
      "range": {
        "startLine": 777,
        "startChar": 43,
        "endLine": 777,
        "endChar": 55
      },
      "revId": "24f98588df231b32ab81593af90fe0dd677c1b9b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "55a9ef0a_80372a2a",
        "filename": "redfish-core/lib/virtual_media.hpp",
        "patchSetId": 1
      },
      "lineNbr": 777,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-01-13T20:39:42Z",
      "side": 1,
      "message": "then verify later whether or not the parameters are present in the validate function.",
      "parentUuid": "72d01446_f4ca6885",
      "range": {
        "startLine": 777,
        "startChar": 43,
        "endLine": 777,
        "endChar": 55
      },
      "revId": "24f98588df231b32ab81593af90fe0dd677c1b9b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3b1779b4_96286a46",
        "filename": "redfish-core/lib/virtual_media.hpp",
        "patchSetId": 1
      },
      "lineNbr": 777,
      "author": {
        "id": 1000460
      },
      "writtenOn": "2023-01-13T20:56:21Z",
      "side": 1,
      "message": "Yes, and it is made in verifyParams(). But still the problem with reading and parsing json from request remains. I would like to use readJsonAction() as it generate appropriate messages when there is a mismatch. But it is not possible at the level it is used now.",
      "parentUuid": "55a9ef0a_80372a2a",
      "range": {
        "startLine": 777,
        "startChar": 43,
        "endLine": 777,
        "endChar": 55
      },
      "revId": "24f98588df231b32ab81593af90fe0dd677c1b9b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}