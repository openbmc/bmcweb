{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "c0a4c153_30e4a7e0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-11-30T18:17:57Z",
      "side": 1,
      "message": "typo.  Space.",
      "range": {
        "startLine": 10,
        "startChar": 18,
        "endLine": 10,
        "endChar": 21
      },
      "revId": "911708464aa6734ab1395caf530a021c29729912",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ad1b5621_dc5e510b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-11-30T18:17:57Z",
      "side": 1,
      "message": "This looks like it\u0027s still WIP.  It comments out TLS support entirely, which I don\u0027t see mention of in the commit message?  If this is WIP, please mark it as such.",
      "revId": "911708464aa6734ab1395caf530a021c29729912",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6fb91c3f_04d8f07e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-11-30T18:26:02Z",
      "side": 1,
      "message": "I was looking into issues like this a while back.  I don\u0027t remember where I left them, but you might take a look at the two patches at https://gerrit.openbmc.org/c/openbmc/bmcweb/+/56711",
      "revId": "911708464aa6734ab1395caf530a021c29729912",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ac4f99e0_0d499518",
        "filename": "http/http_client.hpp",
        "patchSetId": 1
      },
      "lineNbr": 158,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-11-30T18:17:57Z",
      "side": 1,
      "message": "This is already available through the socket.  Do we need to store it?",
      "range": {
        "startLine": 158,
        "startChar": 4,
        "endLine": 158,
        "endChar": 33
      },
      "revId": "911708464aa6734ab1395caf530a021c29729912",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9663d414_706d2f72",
        "filename": "http/http_client.hpp",
        "patchSetId": 1
      },
      "lineNbr": 161,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-11-30T18:17:57Z",
      "side": 1,
      "message": "This as lifetime problems now that you\u0027ve declared conn after sslConn (which is a reference here).  I\u0027m not following why this was changed.  Can you elaborate?",
      "range": {
        "startLine": 161,
        "startChar": 50,
        "endLine": 161,
        "endChar": 54
      },
      "revId": "911708464aa6734ab1395caf530a021c29729912",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9bb4a20d_57086f8a",
        "filename": "http/http_client.hpp",
        "patchSetId": 1
      },
      "lineNbr": 161,
      "author": {
        "id": 1001762
      },
      "writtenOn": "2023-12-02T07:09:38Z",
      "side": 1,
      "message": "It is an Optional stream. We are supposed to emplace a new SSL stream once the TCP object is available. Earlier code tried to reuse both TCP object and SSL stream, which is invalid once the connection is broken. We are supposed to recreate atleast the SSL stream. This patch set recreates both TCP object and SSL stream. That is why the TCP object is a unique_ptr now. So as per the current code the declaration order is correct.",
      "parentUuid": "9663d414_706d2f72",
      "range": {
        "startLine": 161,
        "startChar": 50,
        "endLine": 161,
        "endChar": 54
      },
      "revId": "911708464aa6734ab1395caf530a021c29729912",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ecfcdd64_547cac5f",
        "filename": "http/http_client.hpp",
        "patchSetId": 1
      },
      "lineNbr": 161,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-12-04T00:02:16Z",
      "side": 1,
      "message": "\u003e It is an Optional stream. We are supposed to emplace a new SSL stream once the TCP object is available.\n\nright, but you\u0027ve now delcared the TCP socket after the sslConn, which means that on destruction, sslConn will hold a reference to a destroyed object, because conn will be destroyed first.  We\u0027ve hit this problem many times before.  I realize it\u0027s non-obvious.",
      "parentUuid": "9bb4a20d_57086f8a",
      "range": {
        "startLine": 161,
        "startChar": 50,
        "endLine": 161,
        "endChar": 54
      },
      "revId": "911708464aa6734ab1395caf530a021c29729912",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eb2c826a_832ac798",
        "filename": "http/http_client.hpp",
        "patchSetId": 1
      },
      "lineNbr": 161,
      "author": {
        "id": 1001762
      },
      "writtenOn": "2023-12-04T12:19:04Z",
      "side": 1,
      "message": "I had to change the order to call the makeConnection from the constructor initializer list.  Moved the code to the constructor body now.Hope this is correct now",
      "parentUuid": "ecfcdd64_547cac5f",
      "range": {
        "startLine": 161,
        "startChar": 50,
        "endLine": 161,
        "endChar": 54
      },
      "revId": "911708464aa6734ab1395caf530a021c29729912",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "84ee5f1c_cf743792",
        "filename": "http/http_client.hpp",
        "patchSetId": 1
      },
      "lineNbr": 161,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-12-04T18:39:46Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "eb2c826a_832ac798",
      "range": {
        "startLine": 161,
        "startChar": 50,
        "endLine": 161,
        "endChar": 54
      },
      "revId": "911708464aa6734ab1395caf530a021c29729912",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6097381d_608bb5bc",
        "filename": "http/http_client.hpp",
        "patchSetId": 1
      },
      "lineNbr": 366,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-11-30T18:24:47Z",
      "side": 1,
      "message": "I\u0027m not following why this has an impact.  If the server broke the connection, won\u0027t the response code on line 383 fail?\n\nI wonder if on line 381 we need to be checking parser.is_done().  That way if we get a truly truncated response (rather than just the server closing the connection uncleanly, which some servers do)\n\nwe can still hit the error path.\n\nhttps://www.boost.org/doc/libs/1_82_0/libs/beast/doc/html/beast/ref/boost__beast__http__parser/is_done.html\n\nSeem reasonable?",
      "revId": "911708464aa6734ab1395caf530a021c29729912",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "176ae9e1_d9c6bd9b",
        "filename": "http/http_client.hpp",
        "patchSetId": 1
      },
      "lineNbr": 366,
      "author": {
        "id": 1001762
      },
      "writtenOn": "2023-12-01T09:19:56Z",
      "side": 1,
      "message": "No. The response code is usually set by the application. But the connection is broken due to TCP keep_alive timeout. \nThis is happening at TCP layer and is done by any intermediate proxies. \nThe server will not set any HTTP response code in this case. It is kind of an abrupt connection termination. \nSince http_client is not waiting by reading the socket, it is not aware of the connection termination. \nThe http_client get to know about the connection failure when it tries to send next event. \nWhich can happen very long time after the connection termination. So the way to know about the broken coonection  is from error code.\nSslstream truncation is the error we usually get in this case.",
      "parentUuid": "6097381d_608bb5bc",
      "revId": "911708464aa6734ab1395caf530a021c29729912",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "079c4afa_989001e1",
        "filename": "http/http_client.hpp",
        "patchSetId": 1
      },
      "lineNbr": 366,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-12-01T18:31:15Z",
      "side": 1,
      "message": "Right, the response code is set by the application, but if a lower layer fails, the response code won\u0027t get transfered, right?\n\n\u003e Since http_client is not waiting by reading the socket.\n\nAh, so maybe that\u0027s the issue.  I wonder if we set up a wait type of wait_error, if this would fix the issue?\n\nhttps://live.boost.org/doc/libs/1_83_0/doc/html/boost_asio/reference/basic_stream_socket/async_wait.html\n\nOr should we rearrange the code so that we\u0027re always reading, and if we read bytes when we don\u0027t expect them, we should just abort?\n\nI do still think we should check that the parser finished in this code, but maybe that doesn\u0027t matter.",
      "parentUuid": "176ae9e1_d9c6bd9b",
      "revId": "911708464aa6734ab1395caf530a021c29729912",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8dccf0f8_6a9cacf4",
        "filename": "http/http_client.hpp",
        "patchSetId": 1
      },
      "lineNbr": 366,
      "author": {
        "id": 1001762
      },
      "writtenOn": "2023-12-02T07:09:38Z",
      "side": 1,
      "message": "Yes, we can use async wait. But it makes code a bit complicated I guess. The eventing semantics do not expect to wait for anything from the server before sending an event. \nIn my opinion, we can handle the error reactively as we do now. It is just that we are reusing the SSL stream improperly and escaping some error conditions. Fixing those will give completeness to the current solution I guess.",
      "parentUuid": "079c4afa_989001e1",
      "revId": "911708464aa6734ab1395caf530a021c29729912",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8a23b3ed_db551674",
        "filename": "http/http_client.hpp",
        "patchSetId": 1
      },
      "lineNbr": 366,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-12-04T00:02:16Z",
      "side": 1,
      "message": "\u003e Yes, we can use async wait. But it makes code a bit complicated I guess.\n\nSure, but it makes it correct I think?  I\u0027d rather have complicated correct code than simple incorrect code.  Ideally it\u0027s simple correct code, but given that we need to monitor the connection at all times, I don\u0027t know if we can avoid the complexity here.\n\n\u003e The eventing semantics do not expect to wait for anything from the server before sending an event. \n\nI have no idea what this means.  Can you rephrase?\n\n\u003e In my opinion, we can handle the error reactively as we do now. It is just that we are reusing the SSL stream improperly and escaping some error conditions. Fixing those will give completeness to the current solution I guess.\n\nThe problem I see is that opens us up to possible DOS problems if we maintain connection objects that are \"open\" but at the same time not open.",
      "parentUuid": "8dccf0f8_6a9cacf4",
      "revId": "911708464aa6734ab1395caf530a021c29729912",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "55258af3_ec8a8415",
        "filename": "http/http_client.hpp",
        "patchSetId": 1
      },
      "lineNbr": 366,
      "author": {
        "id": 1001762
      },
      "writtenOn": "2023-12-04T12:19:04Z",
      "side": 1,
      "message": "I have no idea what this means. Can you rephrase?\n\nIn the case of event publishing, the client will send data and then wait for the response. After the response has arrived client need not wait for anything from the server. \nThe steps will repeat when the next event is ready to be sent.\n\n Sure, but it makes it correct I think?\n\nThe server socket will wait for the next data arrival. So it gets notified about the abrupt connection termination. The server socket can do the clean-up actions and close the socket. Is there any DOS threat here?\n\nThe client also gets to know about the closed connection when it tries to send a new event. But we were ignoring the stream truncation error before. Don\u0027t know why.\nIn the current code, once the client detects error it will restart the connection. That is only one line change. \nOther parts of the code are still needed irrespective of how we detect the connection termination.",
      "parentUuid": "8a23b3ed_db551674",
      "revId": "911708464aa6734ab1395caf530a021c29729912",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "31073474_141d4ae6",
        "filename": "http/http_client.hpp",
        "patchSetId": 1
      },
      "lineNbr": 366,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-12-04T18:39:46Z",
      "side": 1,
      "message": "\u003e I have no idea what this means. Can you rephrase?\n\u003e \n\u003e In the case of event publishing, the client will send data and then wait for the response. After the response has arrived client need not wait for anything from the server. \n\u003e The steps will repeat when the next event is ready to be sent.\n\u003e \n\u003e  Sure, but it makes it correct I think?\n\u003e \n\u003e The server socket will wait for the next data arrival. So it gets notified about the abrupt connection termination. The server socket can do the clean-up actions and close the socket. Is there any DOS threat here?\n\u003e \n\u003e The client also gets to know about the closed connection when it tries to send a new event. But we were ignoring the stream truncation error before. Don\u0027t know why.\n\u003e In the current code, once the client detects error it will restart the connection. That is only one line change. \n\u003e Other parts of the code are still needed irrespective of how we detect the connection termination.",
      "parentUuid": "55258af3_ec8a8415",
      "revId": "911708464aa6734ab1395caf530a021c29729912",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4ccec3f8_c2b1f5be",
        "filename": "http/http_client.hpp",
        "patchSetId": 1
      },
      "lineNbr": 366,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-12-14T18:04:12Z",
      "side": 1,
      "message": "To be clear about what needs to happen here:\n\n1. the stream_truncated check needs to be put back.  There are webservers that do not close the TLS connection cleanly, hence why it\u0027s not directly treated as an error.\n\n2. Add a check for parser-\u003eis_done() on line 381.  This will be able to determine if a connection dropped before we received a response.",
      "parentUuid": "31073474_141d4ae6",
      "revId": "911708464aa6734ab1395caf530a021c29729912",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aadb19a2_17934471",
        "filename": "http/http_client.hpp",
        "patchSetId": 1
      },
      "lineNbr": 366,
      "author": {
        "id": 1001762
      },
      "writtenOn": "2023-12-18T05:03:55Z",
      "side": 1,
      "message": "If the server is closed the connection(whether it is clean or unclean), why are we not retrying? An intentional disconnect happens through an unsubscribe call, right? In all other cases, we should retry according to the retry policy. Am I reading the requirement correctly here?\n\nWhy don\u0027t we add the is_done check after 363?",
      "parentUuid": "4ccec3f8_c2b1f5be",
      "revId": "911708464aa6734ab1395caf530a021c29729912",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c5c3d0d8_ece362da",
        "filename": "http/http_client.hpp",
        "patchSetId": 1
      },
      "lineNbr": 619,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-11-30T18:17:57Z",
      "side": 1,
      "message": "You\u0027ve completely disabled SSL?  This looks like it\u0027s still WIP?",
      "range": {
        "startLine": 604,
        "startChar": 0,
        "endLine": 619,
        "endChar": 16
      },
      "revId": "911708464aa6734ab1395caf530a021c29729912",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bc10ae81_a2c2c078",
        "filename": "http/http_client.hpp",
        "patchSetId": 1
      },
      "lineNbr": 619,
      "author": {
        "id": 1001762
      },
      "writtenOn": "2023-12-01T09:19:56Z",
      "side": 1,
      "message": "my mistake. Copy-paste error from downstream.  Ssl is still used, but the context may not have all details. That is why the error is not shown up in my test",
      "parentUuid": "c5c3d0d8_ece362da",
      "range": {
        "startLine": 604,
        "startChar": 0,
        "endLine": 619,
        "endChar": 16
      },
      "revId": "911708464aa6734ab1395caf530a021c29729912",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0a7a592f_e5228246",
        "filename": "http/http_client.hpp",
        "patchSetId": 1
      },
      "lineNbr": 619,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-12-01T18:31:15Z",
      "side": 1,
      "message": "All good.  Let me know when you\u0027ve fixed your patchset.",
      "parentUuid": "bc10ae81_a2c2c078",
      "range": {
        "startLine": 604,
        "startChar": 0,
        "endLine": 619,
        "endChar": 16
      },
      "revId": "911708464aa6734ab1395caf530a021c29729912",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "198644fb_3937dfbc",
        "filename": "http/http_client.hpp",
        "patchSetId": 1
      },
      "lineNbr": 619,
      "author": {
        "id": 1001762
      },
      "writtenOn": "2023-12-02T07:09:38Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "0a7a592f_e5228246",
      "range": {
        "startLine": 604,
        "startChar": 0,
        "endLine": 619,
        "endChar": 16
      },
      "revId": "911708464aa6734ab1395caf530a021c29729912",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}