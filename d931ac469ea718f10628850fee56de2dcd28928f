{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "98d47a2f_fec3adfe",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 23,
      "author": {
        "id": 1001604
      },
      "writtenOn": "2026-01-22T21:01:18Z",
      "side": 1,
      "message": "Also, would connectFailed state be an intermediate condition before setting it as `terminated` state.\n\nIn that case, should bmcweb attempt to connect multiple times (upto maxRetry) and then its state will become `terminated` state?\n\n- https://github.com/openbmc/bmcweb/blob/ca8790742803cf56283189f63feb37bb5c003912/http/http_client.hpp#L246\n\n```\nvoid afterConnect(const std::shared_ptr\u003cConnectionInfo\u003e\u0026 /*self*/,\n                      const boost::beast::error_code\u0026 ec,\n                      const boost::asio::ip::tcp::endpoint\u0026 endpoint)\n    {\n    ...\n                state \u003d ConnState::connectFailed;\n            waitAndRetry(); \u003c\u003d\u003d\u003d\n            return;\n     }\n```",
      "revId": "d931ac469ea718f10628850fee56de2dcd28928f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "88e8537f_0209660c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 23,
      "author": {
        "id": 1002825
      },
      "writtenOn": "2026-01-27T14:24:33Z",
      "side": 1,
      "message": "Yes, for a single connection connectFailed is an intermediate state - waitAndRetry() is called which either retries (if retryCount \u003c maxRetryAttempts) or transitions to terminated state.\n\nHowever, from my testing on the platform, I observed that typically only one connection in the pool transitions to terminated, while the remaining connections stay in connectFailed state indefinitely. They never transition to terminated.\n\nAs I understand it (please correct me if I\u0027m wrong), having one connection reach terminated state should be sufficient condition to delete the subscription with TerminateAfterRetries policy. The bad_gateway response already indicates that max retry attempts were exhausted for that event delivery.",
      "parentUuid": "98d47a2f_fec3adfe",
      "revId": "d931ac469ea718f10628850fee56de2dcd28928f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "484f4eaa_0ccf58f2",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 23,
      "author": {
        "id": 1001604
      },
      "writtenOn": "2026-01-29T15:34:20Z",
      "side": 1,
      "message": "Then, should we need to find the reason why it does not retry to connect?\nIn semantics, I think only one connectionFailed should not result in as a terminatedState \u0026  max-retry to reconnection should be tried.",
      "parentUuid": "88e8537f_0209660c",
      "revId": "d931ac469ea718f10628850fee56de2dcd28928f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7250e01c_c9dcdf14",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 23,
      "author": {
        "id": 1002825
      },
      "writtenOn": "2026-02-09T13:42:41Z",
      "side": 1,
      "message": "I investigated why only one connection at a time remains in the terminated state - the root cause and proposed fix are described in detail in the comment below. I\u0027m not certain this is the correct approach though - if you see a better alternative, I\u0027m open to suggestions.",
      "parentUuid": "484f4eaa_0ccf58f2",
      "revId": "d931ac469ea718f10628850fee56de2dcd28928f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "84585c07_56f0dce9",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 43,
      "author": {
        "id": 1001604
      },
      "writtenOn": "2026-01-22T20:48:54Z",
      "side": 1,
      "message": "I think all callers already saved `id` locally or captured in a lambda before calling `deleteSubscription()`.\nFor example,\n- https://github.com/openbmc/bmcweb/blob/ca8790742803cf56283189f63feb37bb5c003912/redfish-core/include/event_service_manager.hpp#L120\n- https://github.com/openbmc/bmcweb/blob/ca8790742803cf56283189f63feb37bb5c003912/redfish-core/include/event_service_manager.hpp#L404\n\n\nIs there a specific log traces about the observation?",
      "revId": "d931ac469ea718f10628850fee56de2dcd28928f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6594f04b_a2b882fd",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 43,
      "author": {
        "id": 1002825
      },
      "writtenOn": "2026-01-27T14:24:33Z",
      "side": 1,
      "message": "You\u0027re correct. I initially thought this might be causing some issue I observed previously, but after adding debug logs before and after erase(), I confirmed the ID remains valid. As you noted, callers already handle this properly. I reverted to const std::string\u0026.",
      "parentUuid": "84585c07_56f0dce9",
      "revId": "d931ac469ea718f10628850fee56de2dcd28928f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "06d94eba_0008feee",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 43,
      "author": {
        "id": 1001604
      },
      "writtenOn": "2026-01-29T15:34:20Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "6594f04b_a2b882fd",
      "revId": "d931ac469ea718f10628850fee56de2dcd28928f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f85933c2_19854f6c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 75,
      "author": {
        "id": 1001604
      },
      "writtenOn": "2026-01-22T20:48:54Z",
      "side": 1,
      "message": "It looks like the test seems trying to cover the only bad_gateway case (e.g. connectFailed).\n\nI think the other cases may exist after the connection is done but the send is failed (e.g. sendFailed/recvFailed or sslInitFailed etc??).\n\nIf the current isTerminated() does not cover all cases, should the function check those cases too instead of removing the function like this?\n```\nbool areAllConnectionsTerminated()\n{\n...\n        for (const auto\u0026 conn : connections)\n        {\n         {\n-            if (conn !\u003d nullptr \u0026\u0026 conn-\u003estate !\u003d ConnState::terminated)\n+            if (conn !\u003d nullptr \u0026\u0026 conn-\u003estate !\u003d ConnState::terminated \u0026\u0026\n+                conn-\u003estate !\u003d ConnState::connFailed)\n\n            {\n                BMCWEB_LOG_DEBUG(\n                    \"Not all connections of pool id:{} are terminated\", id);\n                return false;\n            }\n        }\n```",
      "revId": "d931ac469ea718f10628850fee56de2dcd28928f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4c138b27_e8cbdccc",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 75,
      "author": {
        "id": 1002825
      },
      "writtenOn": "2026-01-27T14:24:33Z",
      "side": 1,
      "message": "I considered extending isTerminated() as you mentioned, but it would require tracking all possible failure states (terminated, connectFailed, sendFailed, recvFailed...) and if a new state is added later, we\u0027d need to remember to update this check too.\n\nFrom my understanding (and please correct me if I\u0027m wrong), the resHandler() receiving bad_gateway with TerminateAfterRetries policy already indicates that retry attempts were exhausted - so this seems sufficient as a trigger for deletion, without checking connection pool state.\n\nBut if you think extending isTerminated() is the better approach, I can do that - we\u0027d just need to agree on the full list of \"terminal\" states.",
      "parentUuid": "f85933c2_19854f6c",
      "revId": "d931ac469ea718f10628850fee56de2dcd28928f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "72bcaa3b_d60bd886",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 75,
      "author": {
        "id": 1001604
      },
      "writtenOn": "2026-01-29T15:34:20Z",
      "side": 1,
      "message": "I think it is better to find the cause of not-retying on connectFail case and make a change to retry so that the end-state always becomes `terminated` - https://gerrit.openbmc.org/c/openbmc/bmcweb/+/86859/comment/98d47a2f_fec3adfe/",
      "parentUuid": "4c138b27_e8cbdccc",
      "revId": "d931ac469ea718f10628850fee56de2dcd28928f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6163990a_604d9fce",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 75,
      "author": {
        "id": 1002825
      },
      "writtenOn": "2026-02-09T13:42:41Z",
      "side": 1,
      "message": "The issue is not that connections fail to reach the terminated state - they do. The problem is that the terminated state is not preserved: two code paths transition the connection out of terminated or grow the pool with doomed connections before areAllConnectionsTerminated() can observe all connections as terminated, causing connections to be recycled indefinitely.\n\nHardware testing with diagnostic logging confirmed the pattern:\n\nPool states cycle: [15,4,4,4] -\u003e [4,15,4,4] -\u003e [4,4,15,4] - terminated state rotates between connections instead of accumulating.\n\nThe two code paths responsible:\n\n1. sendNext() - reuses terminated connections for queued requests\nAfter a connection completes (including reaching terminated via waitAndRetry() -\u003e callback()), afterSendData() calls sendNext(). If the requestQueue is not empty, sendNext() calls setConnProps() + sendMessage()/restartConnection() on the terminated connection, overwriting its state.\n\nFix: Early return in sendNext() if conn-\u003estate \u003d\u003d ConnState::terminated.\n\n2. sendData() - creates new doomed connections\nWhen new events arrive, sendData() looks for idle/initialized/closed connections. Terminated and connectFailed connections don\u0027t match any of those states, so sendData() creates new connections via addConnection() up to the maxConnections limit. These new connections are also doomed to fail against an unreachable destination, which delays areAllConnectionsTerminated() from returning true - each new connection must independently exhaust its own retry cycle before reaching terminated. With events arriving periodically, this cycle continues until maxConnections is reached, unnecessarily growing the pool with doomed connections and significantly delaying subscription cleanup.\n\nFix: Inside the if (connections.size() \u003c maxConnections) branch, check if any existing connection is terminated before creating a new one. If so, return bad_gateway via resHandler. The check is scoped to the \"create new connection\" branch only - when maxConnections is already reached, requests go to the queue where they can still be picked up by connections that have not yet exhausted their retries. If all connections eventually reach terminated, queued requests become moot as the subscription itself will be cleaned up by areAllConnectionsTerminated().\n\nAfter the fix, pool states accumulate cleanly: [15,4,4,4] -\u003e [15,15,4,4] -\u003e [15,15,15,4] -\u003e [15,15,15,15] -\u003e areAllConnectionsTerminated() returns true -\u003e subscription removed.",
      "parentUuid": "72bcaa3b_d60bd886",
      "revId": "d931ac469ea718f10628850fee56de2dcd28928f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b753516a_30efe92c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000020
      },
      "writtenOn": "2026-01-22T21:05:00Z",
      "side": 1,
      "message": "Ideally your Gerrit Name matches your CCLA, Signed-Off name..\nhttps://gerrit.openbmc.org/c/openbmc/bmcweb/+/86150",
      "revId": "d931ac469ea718f10628850fee56de2dcd28928f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "45af6226_41b2dd86",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1002825
      },
      "writtenOn": "2026-01-27T14:24:33Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b753516a_30efe92c",
      "revId": "d931ac469ea718f10628850fee56de2dcd28928f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8434bc22_2496e478",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000020
      },
      "writtenOn": "2026-01-27T20:11:58Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "45af6226_41b2dd86",
      "revId": "d931ac469ea718f10628850fee56de2dcd28928f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6f46de10_c63a0d39",
        "filename": "redfish-core/src/subscription.cpp",
        "patchSetId": 5
      },
      "lineNbr": 85,
      "author": {
        "id": 1001604
      },
      "writtenOn": "2026-01-22T20:48:54Z",
      "side": 1,
      "message": "It looks like the change seems unconditionally deleting the subscription after sendEventToSubscriber() - \nhttps://github.com/openbmc/bmcweb/blob/ca8790742803cf56283189f63feb37bb5c003912/redfish-core/src/subscription.cpp#L187",
      "revId": "d931ac469ea718f10628850fee56de2dcd28928f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e62e337a_6a47a1d0",
        "filename": "redfish-core/src/subscription.cpp",
        "patchSetId": 5
      },
      "lineNbr": 85,
      "author": {
        "id": 1002825
      },
      "writtenOn": "2026-01-27T14:24:33Z",
      "side": 1,
      "message": "I think the deletion is not unconditional. Looking at resHandler():\n\n- Early return if response is not bad_gateway - normal successful sends don\u0027t trigger deletion\n- Early return if policy is not TerminateAfterRetries\nSo, as I understand it, the deletion only happens when:\n\nResponse is bad_gateway (meaning all retry attempts exhausted)\nand\nRetry policy is TerminateAfterRetries\n\nThe bad_gateway is only returned by http_client.hpp when retryCount \u003e\u003d maxRetryAttempts (line 494-503), so it should already confirm that max retries were exhausted for that specific event delivery. Please let me know if I\u0027m misunderstanding the flow here.",
      "parentUuid": "6f46de10_c63a0d39",
      "revId": "d931ac469ea718f10628850fee56de2dcd28928f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "901fed2c_d32c9230",
        "filename": "redfish-core/src/subscription.cpp",
        "patchSetId": 5
      },
      "lineNbr": 85,
      "author": {
        "id": 1001604
      },
      "writtenOn": "2026-01-29T15:34:20Z",
      "side": 1,
      "message": "If that\u0027s the case (e.g. max-retry is already exhausted), `isTerminated()` is already satisfied. Then, there is no reason to remove it.\n\nSecond, I\u0027m not sure whether `resHandler` is called only after max-retry.\n`resHandler` seems invoked unconditionally in `afterSendData()` - \n\nhttps://github.com/openbmc/bmcweb/blob/ac69e77ea938e8c2a5bd3dad258cdafd9d3182b7/http/http_client.hpp#L824\n\n\n\n```\n    static void afterSendData(const std::weak_ptr\u003cConnectionPool\u003e\u0026 weakSelf,\n                              const std::function\u003cvoid(Response\u0026)\u003e\u0026 resHandler,\n                              bool keepAlive, uint32_t connId, Response\u0026 res)\n    {\n        // Allow provided callback to perform additional processing of the\n        // request\n        resHandler(res); \u003c\u003d\u003d\u003d\n        \n\n```\n\nIf `isTerminated()` is correctly derived, I would be better to leave to check it before invoking `deleter()`.",
      "parentUuid": "e62e337a_6a47a1d0",
      "revId": "d931ac469ea718f10628850fee56de2dcd28928f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f10b4949_dec1709a",
        "filename": "redfish-core/src/subscription.cpp",
        "patchSetId": 5
      },
      "lineNbr": 85,
      "author": {
        "id": 1002825
      },
      "writtenOn": "2026-02-09T13:42:41Z",
      "side": 1,
      "message": "If we decide to fix the issue where not all connections are entering the terminated state, then you are right - the isTerminated() logic should remain unchanged. Once terminated connections are preserved rather than recycled, the existing check will correctly return true and trigger subscription cleanup.",
      "parentUuid": "901fed2c_d32c9230",
      "revId": "d931ac469ea718f10628850fee56de2dcd28928f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}