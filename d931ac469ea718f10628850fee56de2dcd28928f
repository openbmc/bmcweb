{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "98d47a2f_fec3adfe",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 23,
      "author": {
        "id": 1001604
      },
      "writtenOn": "2026-01-22T21:01:18Z",
      "side": 1,
      "message": "Also, would connectFailed state be an intermediate condition before setting it as `terminated` state.\n\nIn that case, should bmcweb attempt to connect multiple times (upto maxRetry) and then its state will become `terminated` state?\n\n- https://github.com/openbmc/bmcweb/blob/ca8790742803cf56283189f63feb37bb5c003912/http/http_client.hpp#L246\n\n```\nvoid afterConnect(const std::shared_ptr\u003cConnectionInfo\u003e\u0026 /*self*/,\n                      const boost::beast::error_code\u0026 ec,\n                      const boost::asio::ip::tcp::endpoint\u0026 endpoint)\n    {\n    ...\n                state \u003d ConnState::connectFailed;\n            waitAndRetry(); \u003c\u003d\u003d\u003d\n            return;\n     }\n```",
      "revId": "d931ac469ea718f10628850fee56de2dcd28928f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "88e8537f_0209660c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 23,
      "author": {
        "id": 1002825
      },
      "writtenOn": "2026-01-27T14:24:33Z",
      "side": 1,
      "message": "Yes, for a single connection connectFailed is an intermediate state - waitAndRetry() is called which either retries (if retryCount \u003c maxRetryAttempts) or transitions to terminated state.\n\nHowever, from my testing on the platform, I observed that typically only one connection in the pool transitions to terminated, while the remaining connections stay in connectFailed state indefinitely. They never transition to terminated.\n\nAs I understand it (please correct me if I\u0027m wrong), having one connection reach terminated state should be sufficient condition to delete the subscription with TerminateAfterRetries policy. The bad_gateway response already indicates that max retry attempts were exhausted for that event delivery.",
      "parentUuid": "98d47a2f_fec3adfe",
      "revId": "d931ac469ea718f10628850fee56de2dcd28928f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "484f4eaa_0ccf58f2",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 23,
      "author": {
        "id": 1001604
      },
      "writtenOn": "2026-01-29T15:34:20Z",
      "side": 1,
      "message": "Then, should we need to find the reason why it does not retry to connect?\nIn semantics, I think only one connectionFailed should not result in as a terminatedState \u0026  max-retry to reconnection should be tried.",
      "parentUuid": "88e8537f_0209660c",
      "revId": "d931ac469ea718f10628850fee56de2dcd28928f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "84585c07_56f0dce9",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 43,
      "author": {
        "id": 1001604
      },
      "writtenOn": "2026-01-22T20:48:54Z",
      "side": 1,
      "message": "I think all callers already saved `id` locally or captured in a lambda before calling `deleteSubscription()`.\nFor example,\n- https://github.com/openbmc/bmcweb/blob/ca8790742803cf56283189f63feb37bb5c003912/redfish-core/include/event_service_manager.hpp#L120\n- https://github.com/openbmc/bmcweb/blob/ca8790742803cf56283189f63feb37bb5c003912/redfish-core/include/event_service_manager.hpp#L404\n\n\nIs there a specific log traces about the observation?",
      "revId": "d931ac469ea718f10628850fee56de2dcd28928f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6594f04b_a2b882fd",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 43,
      "author": {
        "id": 1002825
      },
      "writtenOn": "2026-01-27T14:24:33Z",
      "side": 1,
      "message": "You\u0027re correct. I initially thought this might be causing some issue I observed previously, but after adding debug logs before and after erase(), I confirmed the ID remains valid. As you noted, callers already handle this properly. I reverted to const std::string\u0026.",
      "parentUuid": "84585c07_56f0dce9",
      "revId": "d931ac469ea718f10628850fee56de2dcd28928f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "06d94eba_0008feee",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 43,
      "author": {
        "id": 1001604
      },
      "writtenOn": "2026-01-29T15:34:20Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "6594f04b_a2b882fd",
      "revId": "d931ac469ea718f10628850fee56de2dcd28928f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f85933c2_19854f6c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 75,
      "author": {
        "id": 1001604
      },
      "writtenOn": "2026-01-22T20:48:54Z",
      "side": 1,
      "message": "It looks like the test seems trying to cover the only bad_gateway case (e.g. connectFailed).\n\nI think the other cases may exist after the connection is done but the send is failed (e.g. sendFailed/recvFailed or sslInitFailed etc??).\n\nIf the current isTerminated() does not cover all cases, should the function check those cases too instead of removing the function like this?\n```\nbool areAllConnectionsTerminated()\n{\n...\n        for (const auto\u0026 conn : connections)\n        {\n         {\n-            if (conn !\u003d nullptr \u0026\u0026 conn-\u003estate !\u003d ConnState::terminated)\n+            if (conn !\u003d nullptr \u0026\u0026 conn-\u003estate !\u003d ConnState::terminated \u0026\u0026\n+                conn-\u003estate !\u003d ConnState::connFailed)\n\n            {\n                BMCWEB_LOG_DEBUG(\n                    \"Not all connections of pool id:{} are terminated\", id);\n                return false;\n            }\n        }\n```",
      "revId": "d931ac469ea718f10628850fee56de2dcd28928f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4c138b27_e8cbdccc",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 75,
      "author": {
        "id": 1002825
      },
      "writtenOn": "2026-01-27T14:24:33Z",
      "side": 1,
      "message": "I considered extending isTerminated() as you mentioned, but it would require tracking all possible failure states (terminated, connectFailed, sendFailed, recvFailed...) and if a new state is added later, we\u0027d need to remember to update this check too.\n\nFrom my understanding (and please correct me if I\u0027m wrong), the resHandler() receiving bad_gateway with TerminateAfterRetries policy already indicates that retry attempts were exhausted - so this seems sufficient as a trigger for deletion, without checking connection pool state.\n\nBut if you think extending isTerminated() is the better approach, I can do that - we\u0027d just need to agree on the full list of \"terminal\" states.",
      "parentUuid": "f85933c2_19854f6c",
      "revId": "d931ac469ea718f10628850fee56de2dcd28928f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "72bcaa3b_d60bd886",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 75,
      "author": {
        "id": 1001604
      },
      "writtenOn": "2026-01-29T15:34:20Z",
      "side": 1,
      "message": "I think it is better to find the cause of not-retying on connectFail case and make a change to retry so that the end-state always becomes `terminated` - https://gerrit.openbmc.org/c/openbmc/bmcweb/+/86859/comment/98d47a2f_fec3adfe/",
      "parentUuid": "4c138b27_e8cbdccc",
      "revId": "d931ac469ea718f10628850fee56de2dcd28928f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b753516a_30efe92c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000020
      },
      "writtenOn": "2026-01-22T21:05:00Z",
      "side": 1,
      "message": "Ideally your Gerrit Name matches your CCLA, Signed-Off name..\nhttps://gerrit.openbmc.org/c/openbmc/bmcweb/+/86150",
      "revId": "d931ac469ea718f10628850fee56de2dcd28928f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "45af6226_41b2dd86",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1002825
      },
      "writtenOn": "2026-01-27T14:24:33Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b753516a_30efe92c",
      "revId": "d931ac469ea718f10628850fee56de2dcd28928f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8434bc22_2496e478",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000020
      },
      "writtenOn": "2026-01-27T20:11:58Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "45af6226_41b2dd86",
      "revId": "d931ac469ea718f10628850fee56de2dcd28928f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6f46de10_c63a0d39",
        "filename": "redfish-core/src/subscription.cpp",
        "patchSetId": 5
      },
      "lineNbr": 85,
      "author": {
        "id": 1001604
      },
      "writtenOn": "2026-01-22T20:48:54Z",
      "side": 1,
      "message": "It looks like the change seems unconditionally deleting the subscription after sendEventToSubscriber() - \nhttps://github.com/openbmc/bmcweb/blob/ca8790742803cf56283189f63feb37bb5c003912/redfish-core/src/subscription.cpp#L187",
      "revId": "d931ac469ea718f10628850fee56de2dcd28928f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e62e337a_6a47a1d0",
        "filename": "redfish-core/src/subscription.cpp",
        "patchSetId": 5
      },
      "lineNbr": 85,
      "author": {
        "id": 1002825
      },
      "writtenOn": "2026-01-27T14:24:33Z",
      "side": 1,
      "message": "I think the deletion is not unconditional. Looking at resHandler():\n\n- Early return if response is not bad_gateway - normal successful sends don\u0027t trigger deletion\n- Early return if policy is not TerminateAfterRetries\nSo, as I understand it, the deletion only happens when:\n\nResponse is bad_gateway (meaning all retry attempts exhausted)\nand\nRetry policy is TerminateAfterRetries\n\nThe bad_gateway is only returned by http_client.hpp when retryCount \u003e\u003d maxRetryAttempts (line 494-503), so it should already confirm that max retries were exhausted for that specific event delivery. Please let me know if I\u0027m misunderstanding the flow here.",
      "parentUuid": "6f46de10_c63a0d39",
      "revId": "d931ac469ea718f10628850fee56de2dcd28928f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "901fed2c_d32c9230",
        "filename": "redfish-core/src/subscription.cpp",
        "patchSetId": 5
      },
      "lineNbr": 85,
      "author": {
        "id": 1001604
      },
      "writtenOn": "2026-01-29T15:34:20Z",
      "side": 1,
      "message": "If that\u0027s the case (e.g. max-retry is already exhausted), `isTerminated()` is already satisfied. Then, there is no reason to remove it.\n\nSecond, I\u0027m not sure whether `resHandler` is called only after max-retry.\n`resHandler` seems invoked unconditionally in `afterSendData()` - \n\nhttps://github.com/openbmc/bmcweb/blob/ac69e77ea938e8c2a5bd3dad258cdafd9d3182b7/http/http_client.hpp#L824\n\n\n\n```\n    static void afterSendData(const std::weak_ptr\u003cConnectionPool\u003e\u0026 weakSelf,\n                              const std::function\u003cvoid(Response\u0026)\u003e\u0026 resHandler,\n                              bool keepAlive, uint32_t connId, Response\u0026 res)\n    {\n        // Allow provided callback to perform additional processing of the\n        // request\n        resHandler(res); \u003c\u003d\u003d\u003d\n        \n\n```\n\nIf `isTerminated()` is correctly derived, I would be better to leave to check it before invoking `deleter()`.",
      "parentUuid": "e62e337a_6a47a1d0",
      "revId": "d931ac469ea718f10628850fee56de2dcd28928f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}