{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "3cf1f5c2_c72cc30b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-08-06T16:58:34Z",
      "side": 1,
      "message": "Can you please write up better what the root cause is here, and how to reproduce?   \n Because we\u0027re commenting out a boost function, please include the links to the line of code within boost beast that\u0027s the problem.  The fix in the patch doesn\u0027t make any sense, although we have replaced prepare_payload in Request::preparePayload, I suspect we might need to do something similar here?",
      "revId": "7e5604b6d80a28b236d3216ae827fa501e86313f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8a52cca8_b6707f3f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-08-06T20:08:13Z",
      "side": 1,
      "message": "FOr reference, this is the function we have:\nhttps://github.com/openbmc/bmcweb/blob/d5c0172e0335df05db2eaae3dae2c7d3def56089/http/http_response.hpp#L171",
      "parentUuid": "3cf1f5c2_c72cc30b",
      "revId": "7e5604b6d80a28b236d3216ae827fa501e86313f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "18307039_42e132ec",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1001264
      },
      "writtenOn": "2024-08-08T17:39:56Z",
      "side": 1,
      "message": "Hi Ed,\nWe was testing on redfish aggregation feature and notice that http client has 50% failed rate to send request to satellite controller (1 success then follow 1 fail).\n\nWe check the request data send from BMC (client side) by Wireshark, and find out the end of request data repeated final chunk [0x00 0x0d 0x0a 0x0d 0x0a] twice, and satellite controller (server side) close the socket due to the extra final chunk sent form BMC.\n\nThe test flow as below:\nBMC --- RF AGGR Req (v) --\u003e SAT \nBMC \u003c-- RF AGGR Res (v) --- SAT (response success)\nBMC \u003c-- Close Socket ------ SAT (extra final chunk)\nBMC --- RF AGGR Req (x) --\u003e SAT (BMC send failed, broken pipe)\n\n\nSo far we have tested two methods that can avoid the this problem.\n\n1. don\u0027t assign body and call prepare_payload() when data is empty.\n[Patchset 1]\nSo far we not sure why calling prepare_payload() with empty body will causing extra final chunk, this may require digging deeper into the `chunked(true)` function of the boost easter library.\n\n2. add into bmcweb::HttpBody\nPlease have a check with link here [https://github.com/boostorg/beast/blob/848e20680fb374532a0c5816b79b38532e6da775/include/boost/beast/http/impl/message.hpp#L362-L375]\nWith static bmcweb:HttpBosy::size() implementation, the `n` will not be null, and then `chunked(false)` will be called.\nAnd we check the request data with this method, it doesn\u0027t contains extra final chunk, and redfish aggregation works successfully.\n\n\n\n\nI\u0027m wondering which approach seems more appropriate?",
      "parentUuid": "8a52cca8_b6707f3f",
      "revId": "7e5604b6d80a28b236d3216ae827fa501e86313f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "44ebe6dd_fea98a60",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-08-08T18:13:02Z",
      "side": 1,
      "message": "\u003e Hi Ed,\n\u003e We was testing on redfish aggregation feature and notice that http client has 50% failed rate to send request to satellite controller (1 success then follow 1 fail).\n\u003e \n\u003e We check the request data send from BMC (client side) by Wireshark, and find out the end of request data repeated final chunk [0x00 0x0d 0x0a 0x0d 0x0a] twice, and satellite controller (server side) close the socket due to the extra final chunk sent form BMC.\n\u003e \n\u003e The test flow as below:\n\u003e BMC --- RF AGGR Req (v) --\u003e SAT \n\u003e BMC \u003c-- RF AGGR Res (v) --- SAT (response success)\n\u003e BMC \u003c-- Close Socket ------ SAT (extra final chunk)\n\u003e BMC --- RF AGGR Req (x) --\u003e SAT (BMC send failed, broken pipe)\n\u003e \n\u003e \n\u003e So far we have tested two methods that can avoid the this problem.\n\u003e \n\u003e 1. don\u0027t assign body and call prepare_payload() when data is empty.\n\u003e [Patchset 1]\n\u003e So far we not sure why calling prepare_payload() with empty body will causing extra final chunk, this may require digging deeper into the `chunked(true)` function of the boost easter library.\n\nFor reference, this is the code.\nhttps://github.com/boostorg/beast/blob/fee9be0be10c9c9a22ac1505a710d1d8ed5a3dfb/include/boost/beast/http/impl/message.hpp#L360\n\nNote that the current http client does not explicitly support HTTP chunking.  Is your satellite sending a chunked response?\n\n\u003e \n\u003e 2. add into bmcweb::HttpBody\n\nThis function is already added to bmcweb Response object.  Please just use the one we have.\n\n\u003e Please have a check with link here [https://github.com/boostorg/beast/blob/848e20680fb374532a0c5816b79b38532e6da775/include/boost/beast/http/impl/message.hpp#L362-L375]\n\u003e With static bmcweb:HttpBosy::size() implementation, the `n` will not be null, and then `chunked(false)` will be called.\n\u003e And we check the request data with this method, it doesn\u0027t contains extra final chunk, and redfish aggregation works successfully.\n\u003e \n\u003e \n\u003e \n\u003e \n\u003e I\u0027m wondering which approach seems more appropriate?\n\nThe second.  we should be calling prepare_payload in all cases;  If we need a custom version, we should use a custom version.  We shouldn\u0027t just void calling it.",
      "parentUuid": "18307039_42e132ec",
      "revId": "7e5604b6d80a28b236d3216ae827fa501e86313f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "78e6b0f8_edf051fd",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1001264
      },
      "writtenOn": "2024-08-09T17:38:09Z",
      "side": 1,
      "message": "\u003e For reference, this is the code.\n\u003e https://github.com/boostorg/beast/blob/fee9be0be10c9c9a22ac1505a710d1d8ed5a3dfb/include/boost/beast/http/impl/message.hpp#L360\n\u003e Note that the current http client does not explicitly support HTTP chunking. Is your satellite sending a chunked response?\n\nI think the problem is from client side request message.\n\nWhen request sends without data, current client request message is looks like below:\n[headers][final chunk][final chunk]\n\nsatellite controller (server) take \"[headers][final chunk]\" as a normal request message and response, and then follow up an unexpected \"[final chunk]\", so server close the socket.\n\nCurrent http_client will expected socket remain if server side supports \"keep-alive\". when server close socket unexpectedly, it cause next request failed (broken pipe).\n\n\u003e This function is already added to bmcweb Response object. Please just use the one we have.\n\nI was trying adding a static function bmcweb::HttpBody::size() into struct bmcweb::HttpBody.\n\nThis is a example from exist basic_dynamic_body in boost beast library.\nhttps://github.com/boostorg/beast/blob/fee9be0be10c9c9a22ac1505a710d1d8ed5a3dfb/include/boost/beast/http/basic_dynamic_body.hpp#L48-L59\n\n\u003e The second. we should be calling prepare_payload in all cases; If we need a custom version, we should use a custom version. We shouldn\u0027t just void calling it.\n\nWe are not trying to adding new custom version of HttpBody.\n\nIn patchset2, we want to ensure that prepare_payload() goes into the section below, and this will need bmcweb::HttpBody::size() implemented.\nhttps://github.com/boostorg/beast/blob/fee9be0be10c9c9a22ac1505a710d1d8ed5a3dfb/include/boost/beast/http/impl/message.hpp#L364-L374\n```\n        if(*n \u003e 0 ||\n            this-\u003emethod() \u003d\u003d verb::options ||\n            this-\u003emethod() \u003d\u003d verb::put ||\n            this-\u003emethod() \u003d\u003d verb::post)\n        {\n            this-\u003econtent_length(n);\n        }\n        else\n        {\n            this-\u003echunked(false);\n        }\n```\n\nin this section, the empty data request will call `this-\u003echunked(false)`, so that the request data will not contains unexpected final chunk.",
      "parentUuid": "44ebe6dd_fea98a60",
      "revId": "7e5604b6d80a28b236d3216ae827fa501e86313f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "043c99bb_4de109df",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-08-09T18:24:34Z",
      "side": 1,
      "message": "Understood.  This conclusion makes a lot more sense.",
      "parentUuid": "78e6b0f8_edf051fd",
      "revId": "7e5604b6d80a28b236d3216ae827fa501e86313f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a16c5987_77a690bd",
        "filename": "http/http_client.hpp",
        "patchSetId": 1
      },
      "lineNbr": 742,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-08-06T16:58:34Z",
      "side": 1,
      "message": "If data.empty() is true, this line will have no effect, right?",
      "revId": "7e5604b6d80a28b236d3216ae827fa501e86313f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "672a3cdb_8a010194",
        "filename": "http/http_client.hpp",
        "patchSetId": 1
      },
      "lineNbr": 743,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-08-06T16:58:34Z",
      "side": 1,
      "message": "Why does prepare_payload send the wrong response if body().str() is empty?",
      "revId": "7e5604b6d80a28b236d3216ae827fa501e86313f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}