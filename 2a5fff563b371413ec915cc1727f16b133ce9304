{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "1d43ece0_2bdd4615",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 73
      },
      "lineNbr": 0,
      "author": {
        "id": 1001486
      },
      "writtenOn": "2025-02-06T07:10:43Z",
      "side": 1,
      "message": "@ed@tanous.net - do you have further comments here ? Can you help with re-review.",
      "revId": "2a5fff563b371413ec915cc1727f16b133ce9304",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "baba85bf_24975fc8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 73
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-02-17T22:23:44Z",
      "side": 1,
      "message": "Existing comments are still open.  We discussed on discord about the url parsing issues.",
      "parentUuid": "1d43ece0_2bdd4615",
      "revId": "2a5fff563b371413ec915cc1727f16b133ce9304",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eed31751_d935fd88",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 73
      },
      "lineNbr": 0,
      "author": {
        "id": 1001486
      },
      "writtenOn": "2025-03-04T04:41:07Z",
      "side": 1,
      "message": "@ed@tanous.net as discussed in the discord, let me know if you got chance to tryout the url parsing with encoding for fragment extraction. Can we go ahead with the current solution and if we later a find a solution that works I can push another MR to fix this issue.",
      "parentUuid": "baba85bf_24975fc8",
      "revId": "2a5fff563b371413ec915cc1727f16b133ce9304",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3edf09f0_07d3742a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 73
      },
      "lineNbr": 0,
      "author": {
        "id": 1001486
      },
      "writtenOn": "2025-03-18T15:19:21Z",
      "side": 1,
      "message": "I did further study to use boost::url::encode to convert string to percent decode string. \n```\n        char buf[300];\n        try {\n            // Encode the input using the \u0027pchars\u0027 character set (unreserved characters)\n            std::size_t len \u003d boost::urls::encode(\n                buf,                     // Destination buffer\n                sizeof(buf),             // Buffer size\n                urlIn,  // Input string\n                boost::urls::pchars       // Unreserved character set\n            );\n            std::string_view encodedUrl(buf, len);\n            BMCWEB_LOG_CRITICAL(\"Encoded: {}\", encodedUrl);\n            try {\n                // Create a url_view from the encoded URL\n                boost::urls::url_view urlwithFragment(encodedUrl);\n                 if (urlwithFragment.has_fragment()) {\n                     BMCWEB_LOG_CRITICAL(\"Fragment: {}\", urlwithFragment.fragment());\n                  } else {\n                     BMCWEB_LOG_CRITICAL(\"No fragment present in the URL.\");\n                 }\n            } catch (const std::exception\u0026 e) {\n                BMCWEB_LOG_CRITICAL(\"Encoding error:: {}\", e.what());\n            }\n\n        } catch (const std::exception\u0026 e) {\n            BMCWEB_LOG_CRITICAL(\"Encoding error:: {}\", e.what());\n        }\n```\nOutput \n- We are able to get a percent encoded string with includes the fragment \n- But when url object is created it cant find the fragment \n- has_fragment seem to work only when # is present and does not work when # is percent converted. \n\n\nMy alternate proposal is to cleanup the url string manually before we create the URL object out of it \n\n```\n        std::string cleaned(urlIn);\n        cleaned.erase(std::remove_if(cleaned.begin(), cleaned.end(), [](char c) {\n            return c \u003d\u003d \u0027\u003c\u0027 || c \u003d\u003d \u0027\u003e\u0027;\n        }), cleaned.end());\n\n        // Create a boost::urls::url_view from the cleaned URL\n        boost::urls::url_view urlwithFragment(cleaned);\n        // Check if the URL contains a fragment\n        if (urlwithFragment.has_fragment()) {\n            BMCWEB_LOG_CRITICAL(\"Fragment: {}\", urlwithFragment.fragment());\n        } else {\n            BMCWEB_LOG_CRITICAL(\"No fragment present in the URL.\");\n        }\n```\n\nThis works well and we are able to get the correct fragment. \n\n@ed@tanous.net - would you ok with this alternate till we find a better way to do this ?",
      "parentUuid": "eed31751_d935fd88",
      "revId": "2a5fff563b371413ec915cc1727f16b133ce9304",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}