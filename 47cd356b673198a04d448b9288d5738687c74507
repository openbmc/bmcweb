{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "c7eae4ac_2f4b3ee3",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-06-19T04:01:17Z",
      "side": 1,
      "message": "Generally not in bmcweb.  Strings are deduplicated, at compile time, so unless the code is intentionally the same, it doesn\u0027t help to declare a global scoped variable.",
      "range": {
        "startLine": 9,
        "startChar": 53,
        "endLine": 10,
        "endChar": 71
      },
      "revId": "47cd356b673198a04d448b9288d5738687c74507",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5fa5a76e_b7ba1ef6",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1000682
      },
      "writtenOn": "2022-06-22T00:02:23Z",
      "side": 1,
      "message": "Thanks, I am not saving memory usage or improving anything. \n\n\u003e Strings are deduplicated, at compile time\nSeems like it depends on the compiler implementation. https://stackoverflow.com/questions/52423837/is-storage-for-the-same-content-string-literals-guaranteed-to-be-the-same \n\nJust these string literals are fixed (they are two DBus interfaces) and we really shouldn\u0027t create multiple SoT.",
      "parentUuid": "c7eae4ac_2f4b3ee3",
      "range": {
        "startLine": 9,
        "startChar": 53,
        "endLine": 10,
        "endChar": 71
      },
      "revId": "47cd356b673198a04d448b9288d5738687c74507",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "26eefb8d_149af8d3",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1000682
      },
      "writtenOn": "2022-06-22T00:16:41Z",
      "side": 1,
      "message": "For example, someday we changed the interface, without this change, we have to change the string literal multiple times.",
      "parentUuid": "5fa5a76e_b7ba1ef6",
      "range": {
        "startLine": 9,
        "startChar": 53,
        "endLine": 10,
        "endChar": 71
      },
      "revId": "47cd356b673198a04d448b9288d5738687c74507",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c86cc627_47d5db78",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-06-28T04:14:14Z",
      "side": 1,
      "message": "\u003e For example, someday we changed the interface, without this change, we have to change the string literal multiple times.\n\nYes, and that\u0027s a good thing, because it would require us to audit all the places this string is used, which we would need to do anyway, but if it\u0027s duplicated in other places, it shows up in code review, which is a good thing.\n\nAlso, and happens more in the project, only one instance of an interface changes, and needs to port to another daemon/interface, in which case, we would now need to move the only usage back to inline, which makes more of a mess.\n\nInline definitions also make it much easier to code review.\n\n\u003e Seems like it depends on the compiler implementation. \n\nYep, and our specific implementation with the flags we have deduplicates them at compile time, and if it didn\u0027t, they\u0027d be deduplicated as part of compression.\n\n\n\nThe biggest thing for me here is that code review is faster with inlines, and when someone wants to go debug something, someone can immediately convert an async_method_call into a dbus-send (or busctl) call.  At least that was the intent when we inlined all these strings.",
      "parentUuid": "26eefb8d_149af8d3",
      "range": {
        "startLine": 9,
        "startChar": 53,
        "endLine": 10,
        "endChar": 71
      },
      "revId": "47cd356b673198a04d448b9288d5738687c74507",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "689c110a_912e14de",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1000682
      },
      "writtenOn": "2022-06-28T18:57:34Z",
      "side": 1,
      "message": "Oh, so we prefer inline duplicate string literals? Seems like it\u0027s not consistent across the project.\n\nCertificate service file is an example.",
      "parentUuid": "c86cc627_47d5db78",
      "range": {
        "startLine": 9,
        "startChar": 53,
        "endLine": 10,
        "endChar": 71
      },
      "revId": "47cd356b673198a04d448b9288d5738687c74507",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ce4685d0_05a84dbc",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-06-28T21:21:04Z",
      "side": 1,
      "message": "I personally find inline string literals easier to read and turn into debug statements.  It\u0027s generally not something that I have enforced heavily, but I think it aids significantly in the readability to not have to reference another line when looking at dbus calls.\n\nAlso, when we started, we did a lot of global-scoped strings, and we kept having problems where a string would need to be reused between schemas, so either one schema needs to #include the other (bad for code separation) or we needed to create a totally separate file for all the string constants, which made the readability even worse (now you have to go to a different file to see the constants), and when we did it, now patches would merge-conflict heavily if two different patchsets needed that global, which tends to happen when more than one developer makes changes in a space.\n\nThe argument of \"if it ever changes\" is way less important than readability/code review speed/rebase conflicts to me.  In practice, we\u0027ve had 2 schemas that ever really changed in backward incompatible ways, and in both cases, the names didn\u0027t change, so for the moment, a schema changing name without logic changes is hypothetical, and even if it happened, find and replace is trivial to do.",
      "parentUuid": "689c110a_912e14de",
      "range": {
        "startLine": 9,
        "startChar": 53,
        "endLine": 10,
        "endChar": 71
      },
      "revId": "47cd356b673198a04d448b9288d5738687c74507",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}