{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "35d2a9b4_5ab0c0e1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-06-01T22:58:27Z",
      "side": 1,
      "message": "This wasn\u0027t quite what I had in mind, but it does seem to work, and be pretty clean so I\u0027m fine with it.  Just for FYI, I had imagined a retry mechanism similar to how asio does it, with something like\n\ninline void afterSendThing(ThingResponse\u0026 res){\n\n    if (res.failed){\n        retries--;\n        async_send_thing(afterSendThing);\n        return;\n    }\n    \n    /// SUCCESS!\n}\n\nasync_send_thing(afterSendThing);\n\n\n\n\n\nBut a callback like you did it seems reasonable, lets see if we can make it a little less complex, and this should be fine.",
      "revId": "abcb5ac1d031ba0527c53898bf48410f87c79472",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ff65664a_3c7ffaab",
        "filename": "http/http_client.hpp",
        "patchSetId": 4
      },
      "lineNbr": 708,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-06-01T22:58:27Z",
      "side": 1,
      "message": "Couple comments on this api:\n\n1. Now that we can inject them, do they need to have a \"name\" at all in this API?  Could retryPolicyName be completely removed?\n2. Should we work retryAttempts and retryTimeoutInterval into the callback itself?  I\u0027m thinking it could be something returned, kinda like:\n\n\nenum class Retry {\n   Continue;\n   Complete;\n   Error;\n}\n\nstruct RetryInfo {\n   Retry retry;\n   std::chrono::seconds retryAfter;\n   size_t attemptsRemaining \u003d 5;\n}\n\ninline handleRetry(RetryInfo\u0026 retry, response\u0026 res){\n     if ((respCode \u003c 200) || (respCode \u003e\u003d 300))\n    {\n       \n       return Retry::error;\n    }\n    \n    return Retry::Complete\n}\n\n\n\n\nThis could allow clients to do things like handle http retry-after headers as the spec requests, by parsing them and setting the retryAfter correctly.\n\n\n\n\nIt\u0027s quite possible I\u0027m overthinking the above, and it\u0027s certainly something we can evolve over time, but something to think about.",
      "revId": "abcb5ac1d031ba0527c53898bf48410f87c79472",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "50f64ee0_627c6954",
        "filename": "http/http_client.hpp",
        "patchSetId": 4
      },
      "lineNbr": 708,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-06-02T17:39:52Z",
      "side": 1,
      "message": "\u003e 1. Now that we can inject them, do they need to have a \"name\" at all in this API?  Could retryPolicyName be completely removed?\nI think we need to keep the name for reporting purposes. Each individual connection receives a copy of the RetryInfo struct as part of the message sending process.  \"retryPolicyName\" is the only way to indicate which retry policy is being used.\n\n\u003e 2. Should we work retryAttempts and retryTimeoutInterval into the callback itself?\nI think at that point we\u0027d be really getting into duplicating work within each retry policy.  Each policy should use those values in the same way.\n\nWe also attempt to retry if any stage of sending a message fails.  This change would break out retries on response code failures while leaving the other retry logic in place.\n\n\u003e This could allow clients to do things like handle http retry-after headers as the spec requests, by parsing them and setting the retryAfter correctly.\nI think this would be more appropriate to be handled within recvMessage() so that different policies can handle those situations as well.  I\u0027d much rather add a bool to the retry policy to enable/disable additional features like that.",
      "parentUuid": "ff65664a_3c7ffaab",
      "revId": "abcb5ac1d031ba0527c53898bf48410f87c79472",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ab901752_3c943ee1",
        "filename": "http/http_client.hpp",
        "patchSetId": 4
      },
      "lineNbr": 708,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-06-06T19:10:16Z",
      "side": 1,
      "message": "\u003e \u003e 1. Now that we can inject them, do they need to have a \"name\" at all in this API?  Could retryPolicyName be completely removed?\n\u003e I think we need to keep the name for reporting purposes. Each individual connection receives a copy of the RetryInfo struct as part of the message sending process.  \"retryPolicyName\" is the only way to indicate which retry policy is being used.\n\nBut why would we need to report it?  There\u0027s no API that actually uses the name, except maybe logging?  Or is there something that needs to report the name per-request?\n\n\u003e \n\u003e \u003e 2. Should we work retryAttempts and retryTimeoutInterval into the callback itself?\n\u003e I think at that point we\u0027d be really getting into duplicating work within each retry policy.  Each policy should use those values in the same way.\n\u003e \n\u003e We also attempt to retry if any stage of sending a message fails.  This change would break out retries on response code failures while leaving the other retry logic in place.\n\nThat\u0027s a good point.  ACK.\n\n\u003e \n\u003e \u003e This could allow clients to do things like handle http retry-after headers as the spec requests, by parsing them and setting the retryAfter correctly.\n\u003e I think this would be more appropriate to be handled within recvMessage() so that different policies can handle those situations as well.  I\u0027d much rather add a bool to the retry policy to enable/disable additional features like that.",
      "parentUuid": "50f64ee0_627c6954",
      "revId": "abcb5ac1d031ba0527c53898bf48410f87c79472",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "512a2b9c_11a5e3ac",
        "filename": "http/http_client.hpp",
        "patchSetId": 4
      },
      "lineNbr": 708,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-06-06T19:30:50Z",
      "side": 1,
      "message": "\u003e \u003e \u003e 1. Now that we can inject them, do they need to have a \"name\" at all in this API?  Could retryPolicyName be completely removed?\n\u003e \u003e I think we need to keep the name for reporting purposes. Each individual connection receives a copy of the RetryInfo struct as part of the message sending process.  \"retryPolicyName\" is the only way to indicate which retry policy is being used.\n\u003e But why would we need to report it?  There\u0027s no API that actually uses the name, except maybe logging?  Or is there something that needs to report the name per-request?\nIt\u0027s purely for logging purposes.  I thought it would be useful to know for sure which retry policy is being used by a given message.\n\n\u003e \u003e \u003e This could allow clients to do things like handle http retry-after headers as the spec requests, by parsing them and setting the retryAfter correctly.\n\u003e \u003e I think this would be more appropriate to be handled within recvMessage() so that different policies can handle those situations as well.  I\u0027d much rather add a bool to the retry policy to enable/disable additional features like that.\n\u003e \nYou quoted these lines without comment.  Did you accidentally leave off the intended message?",
      "parentUuid": "ab901752_3c943ee1",
      "revId": "abcb5ac1d031ba0527c53898bf48410f87c79472",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}