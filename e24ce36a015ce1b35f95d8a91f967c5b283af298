{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "519f78da_37dc59a7",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 12,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-09-28T15:31:39Z",
      "side": 1,
      "message": "nit, capital for new sentences.",
      "range": {
        "startLine": 12,
        "startChar": 0,
        "endLine": 12,
        "endChar": 3
      },
      "revId": "e24ce36a015ce1b35f95d8a91f967c5b283af298",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "776a4c60_e4d2e8d3",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 12,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2023-09-28T17:02:54Z",
      "side": 1,
      "message": "done",
      "parentUuid": "519f78da_37dc59a7",
      "range": {
        "startLine": 12,
        "startChar": 0,
        "endLine": 12,
        "endChar": 3
      },
      "revId": "e24ce36a015ce1b35f95d8a91f967c5b283af298",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "64513f83_03de3111",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 14,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-09-28T15:31:39Z",
      "side": 1,
      "message": "Have you considered setting reasonable limits, then using NOLINT calls for the functions that don\u0027t meet the criteria?  As-written, this is only going to enforce that the longest function (I\u0027m assuming the one in sensors.hpp) doesn\u0027t get longer, which doesn\u0027t really seem all that helpful.\n\nThat\u0027s how we\u0027ve handled these kinds of ratchets in the past.  Grep for NOLINT and you\u0027ll find several that we\u0027re still working through.",
      "revId": "e24ce36a015ce1b35f95d8a91f967c5b283af298",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "20d3ad59_7f22115b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 14,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2023-09-28T17:02:54Z",
      "side": 1,
      "message": "This is going to result in many functions being flagged NOLINT in some way.\n\nAssuming 1 person is trying to refactor the functions down to size, other people would still be able to inflate the functions marked NOLINT, undermining the effort.\n\nHaving NOLINT annotation also gives precedent for people to annotate their code in this way, claiming that the other code is annotated in the same way. If there are no such annotations in the codebase, that is harder to justify.\n\nIts probably not the most obvious choice what to do here, but i would prefer setting high limits initially and then lowering them over time to some documented sane defaults.",
      "parentUuid": "64513f83_03de3111",
      "revId": "e24ce36a015ce1b35f95d8a91f967c5b283af298",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d35a204b_803414e8",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 14,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-09-28T17:27:51Z",
      "side": 1,
      "message": "\u003e This is going to result in many functions being flagged NOLINT in some way.\n\nHow many is many?  Some info as to the scale of the problem would be good.\n\n\u003e \n\u003e Assuming 1 person is trying to refactor the functions down to size, other people would still be able to inflate the functions marked NOLINT, undermining the effort.\n\nThis assumes that maintainers aren\u0027t doing code review.  As maintainers, one of our main jobs is to ensure that peoples work in progress doesn\u0027t get regressed by others.  Having functions that don\u0027t obey the policy marked would help us to enforce that functions need to be refactored before they\u0027re modified to make them longer (which in general, we tend to try to do).\n\n\u003e \n\u003e Having NOLINT annotation also gives precedent for people to annotate their code in this way, claiming that the other code is annotated in the same way. If there are no such annotations in the codebase, that is harder to justify.\n\nThat\u0027s never been a justification for using NOLINT in new code, and you\u0027ll find quite a few review comments where people attempting to add it have been disallowed from merging new patchsets (especially if there\u0027s not a comment as to why the exception needs made).  The only justification we\u0027ve had in the past is if there wasn\u0027t a way to make the code right (given a 3rd party API or something), but given that we have active maintainership, people claiming they followed something else isn\u0027t a situation I\u0027m worried about, so long as we can be clear about the rules.\n\n\u003e \n\u003e Its probably not the most obvious choice what to do here, but i would prefer setting high limits initially and then lowering them over time to some documented sane defaults.\n\nWhere are those documented defaults?\n\nI\u0027d like to at least understand the scale of why doing it the NOLINT way isn\u0027t going to work, because that\u0027s how we\u0027ve ratcheted these things in the past, and it\u0027s a pretty trivial thing to check (just run with the expected defaults and count the failures).  As a maintainer, having a NOLINT flag makes it much more efficient to review code if the \"real\" rules are enforced for everything, with well defined exceptions (ie NOLINT) being present for old code that doesn\u0027t yet meet the standard, or code where we can\u0027t figure out how to implement to the standard (with a comment as to why).",
      "parentUuid": "20d3ad59_7f22115b",
      "revId": "e24ce36a015ce1b35f95d8a91f967c5b283af298",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a0f738d1_a91fa0a0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 14,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2023-09-28T18:20:45Z",
      "side": 1,
      "message": "imo NOLINT would be a big upfront effort to mark all the code which is nonconforming, with these patches providing no benefit on their own.\n\nIt would result in a lot of NOLINT annotations which make the code even less readable.\n\nFor some of the smaller repos this would certainly be doable but would require upfront agreement on what the final rules should be. Maybe the final rules will be different based on the individual repositories?\n\nThe .clang-tidy is already looking different for the various repositories.\n\nAgreed that it would be a little confusing for maintainers if the rules would change over time.\n\nBut isn\u0027t the point of this clang-tidy automation to make these things something maintainers do not need to worry about?",
      "parentUuid": "d35a204b_803414e8",
      "revId": "e24ce36a015ce1b35f95d8a91f967c5b283af298",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "18029459_324ec7e5",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 14,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-09-28T18:52:48Z",
      "side": 1,
      "message": "\u003e imo NOLINT would be a big upfront effort to mark all the code which is nonconforming, with these patches providing no benefit on their own.\n\nLets not use opinion to make this decision.  Lets use facts and engineering.  If we set tidy to the expected project-wide value, how many NOLINT places would we need to change?  Unless I\u0027m missing something about how hard running that test is, it\u0027s just a matter of changing it to the expected values, and returning the count of failures.  Once you come up with the defaults, I can even run that analysis for you if you\u0027re not able to (I just don\u0027t know what to set the values to yet, because these rules aren\u0027t in the coding standard.). Is just getting that number harder than I\u0027m thinking it is?\n\n\u003e \n\u003e It would result in a lot of NOLINT annotations which make the code even less readable.\n\nExplaining a different way, how much is \"a lot\"?  10?  4000?  If it\u0027s 10, I would think that NOLINT would be worth it (i\u0027m even willing to make the diff for you if it\u0027s too much effort) to get enforcement of all functions. If that number is 4000, obviously that\u0027s a larger problem and you\u0027re right, wouldn\u0027t make sense to do.\n\n\u003e \n\u003e For some of the smaller repos this would certainly be doable but would require upfront agreement on what the final rules should be.\n\nYep, which I suspect you\u0027re going to work on?  Lets focus on two problems:\n1. What standard should we be driving toward?\n2. What can we get refactored automatically, quickly, and on which repos?\n\nRight now your patchset implies that the longest function is too long (which I agree with), has too many statements, too many variables, and too many scopes. but in this patch, that\u0027s implied, so it makes it hard to figure out what your intent is with #1.  Make sense?\n \n\u003e Maybe the final rules will be different based on the individual repositories?\n\nPlease don\u0027t let this be the plan.  Having different documented rules is a historical anti pattern.  In theory all repos are held to the same coding standard, just some are more careful than others, and spend differing amounts on refactoring.  While we might have different enforcement of individual repos based on the amount of effort we can expend refactoring (note, that clang-tidy itself is only supported on a handful of repos), the ideal rules should be the same across the project, unless there\u0027s a good engineering reason to be different.  Make sense?\n\n\u003e \n\u003e The .clang-tidy is already looking different for the various repositories.\n\nYep, and a lot of repos don\u0027t even have tidy yet.  The migration to clang-tidy has generally been to add rules to bmcweb (which I maintain, and can analyze the maintenance and bug cost of) then roll them out to the rest of the repos.  If you\u0027re a maintainer of a repo and want to follow that same pattern, you have my full support.\n\n\u003e \n\u003e Agreed that it would be a little confusing for maintainers if the rules would change over time.\n\u003e \n\u003e But isn\u0027t the point of this clang-tidy automation to make these things something maintainers do not need to worry about?\n\nMaintainers still have to be able to help people when their code fails the checks, as well as make (difficult and error prone) judgement calls on when to accept code that doesn\u0027t follow the rules (via NOLINT).  Just turning on a check in no way means we \"don\u0027t need to worry about\" the rule.  To maintain the rule, I have to be able to say \"Hey, here\u0027s the coding standard rule you violated\" when people ask me why their CI check failed.  If it\u0027s not documented, explaining to N developers what the rules are takes more maintainer time than would be saved by having short functions.\n\nMake sense?",
      "parentUuid": "a0f738d1_a91fa0a0",
      "revId": "e24ce36a015ce1b35f95d8a91f967c5b283af298",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6af4250e_9e15572c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-09-28T16:14:37Z",
      "side": 1,
      "message": "Do you have an intention personally fixing these over time through refactoring?  Or are you asking for help in doing this migration?\n\nI see this same patchset was sent to several clang-tidy enabled repos, all with different parameters keyed in.  It would be good to:\n\nA. Get a patchset out to the base clang-tidy in the docs repo with the desired settings for this, and how those desired settings were arrived at.  Settings that  make it no worse is a good start, but where are we trying to get to?  Getting that documented will help a lot.\nB. Get your intentions documented about the long term.  Are you going to refactor these to bring them down in size?  Do you need community help and are there people lined up to do these refactors?",
      "revId": "e24ce36a015ce1b35f95d8a91f967c5b283af298",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "43d8ba72_7a90444e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2023-09-28T17:02:54Z",
      "side": 1,
      "message": "(A)\ndocs $ find . -name \".clang-format\"\n./style/javascript/.clang-format\n./style/cpp/.clang-format\n./style/c/.clang-format\ndocs $ find . -name \".clang-tidy\"\n\nwhere is the base .clang-tidy?\n\nI am open to document the targeted settings, and openbmc can perhaps just copy these from another project that is already using them.\n\n(B)\nThe Motivation is to fix them personally as i often have to read the code when debugging some issue.\n\nMaking it more readable would help me to make changes more quickly and also have a higher chance of getting them accepted.\n\nAs always the patch stands on its own and does not require any further changes in order to be useful for the project, even if further changes are intended.\n\nAs it stands, the intention of this patch is just to put a brake on things from getting much worse in terms of the size of some of the bigger functions.",
      "parentUuid": "6af4250e_9e15572c",
      "revId": "e24ce36a015ce1b35f95d8a91f967c5b283af298",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "79dd2943_9634486f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-09-28T17:27:51Z",
      "side": 1,
      "message": "\u003e (A)\n\u003e docs $ find . -name \".clang-format\"\n\u003e ./style/javascript/.clang-format\n\u003e ./style/cpp/.clang-format\n\u003e ./style/c/.clang-format\n\u003e docs $ find . -name \".clang-tidy\"\n\u003e \n\u003e where is the base .clang-tidy?\n\nYou found them all above.  They\u0027re separated by language.\n\n\u003e \n\u003e I am open to document the targeted settings, and openbmc can perhaps just copy these from another project that is already using them.\n\nI\u0027d rather at least some justification from the coding standard than blindly copying from another project.\n\n\u003e \n\u003e (B)\n\u003e The Motivation is to fix them personally as i often have to read the code when debugging some issue.\n\nSweet.  Can\u0027t wait to see what you do.  Thank you for the good work.\n\n\u003e \n\u003e Making it more readable would help me to make changes more quickly and also have a higher chance of getting them accepted.\n\u003e \n\u003e As always the patch stands on its own and does not require any further changes in order to be useful for the project, even if further changes are intended.\n\u003e \n\u003e As it stands, the intention of this patch is just to put a brake on things from getting much worse in terms of the size of some of the bigger functions.\n\nHave things been getting \"much worse\"?  In recent years, we\u0027ve been stopping these things in code review and asking for refactors ahead of code.  Most of the code that\u0027s mediocre was left from many years ago.",
      "parentUuid": "43d8ba72_7a90444e",
      "revId": "e24ce36a015ce1b35f95d8a91f967c5b283af298",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "54c382f2_f5bee1a3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2023-09-28T18:20:45Z",
      "side": 1,
      "message": "I did not find a .clang-tidy, just .clang-format files. If there is none i can\nsubmit one. https://gerrit.openbmc.org/c/openbmc/docs/+/66836\n\nWhere should the justification come from? How the code should look is subjective and based on preference. I included mine in the patch.\n\nI don\u0027t know about the long term history of the project since i am relatively new to it. But when there is no check in place, there is certainly always the possibility of things getting worse. As somebody already documented, the intention of most contributions is to fix an immediate issue or implement something, such that refactoring tends to fall by the wayside.",
      "parentUuid": "79dd2943_9634486f",
      "revId": "e24ce36a015ce1b35f95d8a91f967c5b283af298",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4ff20de1_dfd79272",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-09-28T18:52:48Z",
      "side": 1,
      "message": "\u003e You found them all above. They\u0027re separated by language.\n\nI was mistaken.  I was thinking of the template repo concept that never got made official.  My fault.\n\n\u003e Where should the justification come from?\n\nIdeally the coding standard (cpp core guidelines for cpp code).  Most of the tidy tests are just enforcing rules that already exist in the standard.  Barring that, some sort of study of other projects that have made this same migration to great effect, other coding standards that mandate a required max function length, or experts in the field of coding standards coming up with recommended values.  Really it\u0027s up to you where you want to source this from, but ideally it wouldn\u0027t be a number that we picked out of thin air, or if it is arbitrarily picked, lets get it documented as such.\n\n\u003e such that refactoring tends to fall by the wayside.\n\nYep, which is also a little worried that this will JUST enable the check, and not actually do any refactoring or documenting for said check to ensure that we can actually meet the rules we select and they give a positive result on the code.\n\nAs written, this check only really enforces that the worst function we have doesn\u0027t get worse, or another function doesn\u0027t supersede it.  Is maintaining tests that don\u0027t have any documentation behind them, and only enforce realistically one method worth the cost of the tests?  Debatable, but I think we can do better.\n\n\nPS, if you\u0027d like to stretch this into multiple patchsets, that\u0027s fine.",
      "parentUuid": "54c382f2_f5bee1a3",
      "revId": "e24ce36a015ce1b35f95d8a91f967c5b283af298",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}