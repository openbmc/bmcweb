{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "8f7a3bbe_e82d0360",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 20
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-06T00:07:24Z",
      "side": 1,
      "message": "Lots of comments;  This is looking like a great start!",
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "02cede11_e21fe92d",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 82,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-06T00:07:24Z",
      "side": 1,
      "message": "Generally rather than an explicit ID (which can have uniqueness problems) in other places we\u0027ve relied on just printing \"this\" pointer as the identifier.",
      "range": {
        "startLine": 82,
        "startChar": 0,
        "endLine": 82,
        "endChar": 24
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e0beddd5_43f92cdf",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 82,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-04-06T19:44:59Z",
      "side": 1,
      "message": "I wanted connID to refer to its vector location within ConnectionPool\u0027s std::vector\u003cstd::shared_ptr\u003cConnectionInfo\u003e\u003e connections.  It\u0027s only used for logging purposes.  The actual ID of a ConnectionInfo instance is a combination of host, port, and connId.  As-is, ConnectionPool does not delete an instance of ConnectionInfo so there are not concerns about connId collisions within a given connection pool.\n\nI at least want to keep the current fields since I think those are the most readable for logging purpose.  I can add \"this\" pointer as an overall unique ID if you still think it\u0027s necessary.",
      "parentUuid": "02cede11_e21fe92d",
      "range": {
        "startLine": 82,
        "startChar": 0,
        "endLine": 82,
        "endChar": 24
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "46cde50c_11ce88a5",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 82,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-07T02:47:36Z",
      "side": 1,
      "message": "\u003e I wanted connID to refer to its vector location within ConnectionPool\u0027s std::vector\u003cstd::shared_ptr\u003cConnectionInfo\u003e\u003e connections.  It\u0027s only used for logging purposes.  The actual ID of a ConnectionInfo instance is a combination of host, port, and connId.  As-is, ConnectionPool does not delete an instance of ConnectionInfo so there are not concerns about connId collisions within a given connection pool.\n\nNot deleting ConnInfo seems like a problem.  If all the connections time out, I would expect them to be deleted from the pool, right?  Or am I missing a subtlety?\n\n\u003e \n\u003e I at least want to keep the current fields since I think those are the most readable for logging purpose.  I can add \"this\" pointer as an overall unique ID if you still think it\u0027s necessary.\n\nconnID pointing to the index in the vector seems error prone, given that it\u0027s not fixed.  If I call connections.erase(connections.begin(), 1) ie erase the first connection, all the indexes now get invalidated.",
      "parentUuid": "e0beddd5_43f92cdf",
      "range": {
        "startLine": 82,
        "startChar": 0,
        "endLine": 82,
        "endChar": 24
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "741e73dc_f8820771",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 82,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-04-07T20:56:51Z",
      "side": 1,
      "message": "The subtlety is ConnInfo is never deleted so there is not a worry about the indexes getting invalidated.  The connection can be closed for failure events like timeouts, but once it has been closed it can be re-resolved and used by future message sending events.\n\nMy thought is message sending is a repeated event. If the message load is high enough to cause multiple connections to be added to the pool then that load will happen again. When a message fails we don\u0027t block sending other messages to that client.  It should be sufficient to just close the connection.  Deleting and then recreating ConnectionInfo\u0027s then would just be unnecessary overhead.\n\nAdding queues and capping the pool size at 4 would limit the size of the connection pools.",
      "parentUuid": "46cde50c_11ce88a5",
      "range": {
        "startLine": 82,
        "startChar": 0,
        "endLine": 82,
        "endChar": 24
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bdf399c8_ccbbdc3c",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 86,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-06T00:07:24Z",
      "side": 1,
      "message": "Slightly confused here why doResolve needs to store data?  Would it be better just loaded into a class variable prior to resolving the dns?",
      "range": {
        "startLine": 86,
        "startChar": 19,
        "endLine": 86,
        "endChar": 42
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3f05267e_2a3fd413",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 86,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-04-06T19:44:59Z",
      "side": 1,
      "message": "That was to make it available to sendMessage() since one of the flows is doResolve() -\u003e doConnect() -\u003e sendMessage().  I didn\u0027t consider using a class variable, but yes that would be better than passing data through the entire flow.",
      "parentUuid": "bdf399c8_ccbbdc3c",
      "range": {
        "startLine": 86,
        "startChar": 19,
        "endLine": 86,
        "endChar": 42
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "94a3288c_3ec35b7a",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 86,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-04-08T20:53:13Z",
      "side": 1,
      "message": "I have uploaded the change.  I added \"data\" as a class variable for ConnectionInfo",
      "parentUuid": "3f05267e_2a3fd413",
      "range": {
        "startLine": 86,
        "startChar": 19,
        "endLine": 86,
        "endChar": 42
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9eacb25c_89c2f985",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 278,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-06T00:07:24Z",
      "side": 1,
      "message": "Every time you capture by value like this, you\u0027re making a complete copy of the data, which I\u0027m not sure you intended.",
      "range": {
        "startLine": 278,
        "startChar": 26,
        "endLine": 278,
        "endChar": 30
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "053d35f4_e0a83d3b",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 278,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-04-06T19:44:59Z",
      "side": 1,
      "message": "The only alternative I could think of was using \"\u0026data\" and that\u0027s unsafe.  Your above suggestion of storing data as a class variable should get around this issue.",
      "parentUuid": "9eacb25c_89c2f985",
      "range": {
        "startLine": 278,
        "startChar": 26,
        "endLine": 278,
        "endChar": 30
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "08367aba_af38657d",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 278,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-07T02:47:36Z",
      "side": 1,
      "message": "yep.",
      "parentUuid": "053d35f4_e0a83d3b",
      "range": {
        "startLine": 278,
        "startChar": 26,
        "endLine": 278,
        "endChar": 30
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4e8c4b39_08c26c2b",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 278,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-04-08T20:53:13Z",
      "side": 1,
      "message": "I have removed the \"data\" captures in the latest patchset",
      "parentUuid": "08367aba_af38657d",
      "range": {
        "startLine": 278,
        "startChar": 26,
        "endLine": 278,
        "endChar": 30
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "add36b4d_1539c7e4",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 279,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-06T00:07:24Z",
      "side": 1,
      "message": "If the operation got aborted (ie, the request completed within the timeout) we should not be closing the connection.  I would expect this code to to nothing.",
      "range": {
        "startLine": 279,
        "startChar": 0,
        "endLine": 279,
        "endChar": 60
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a8e7d539_2d2579b9",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 279,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-04-06T19:44:59Z",
      "side": 1,
      "message": "This is how it\u0027s handled in the existing code.  waitAndRetry gets called when there is a failure in the flow before a response is received.  When the timer expires the connection is closed so we can attempt to resend the message beginning with doResolve().\n\nI need to do something or else the connection will just remain in a fail state and never get reused.  It seems like my only options are close the connection so it gets returned to the pool or retry sending the message.",
      "parentUuid": "add36b4d_1539c7e4",
      "range": {
        "startLine": 279,
        "startChar": 0,
        "endLine": 279,
        "endChar": 60
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1a37a22a_2287d01c",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 279,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-07T02:47:36Z",
      "side": 1,
      "message": "\u003e This is how it\u0027s handled in the existing code.\n\nACK.  Existing code is incorrect then, but I won\u0027t hold you to solve all problems for all code in one patch üòä\n\nLuckily timers don\u0027t fail that often, if ever (and if they do, something else is very...very wrong) so it\u0027s not a big deal.\n\n\u003e  waitAndRetry gets called when there is a failure in the flow before a response is received.  When the timer expires the connection is closed so we can attempt to resend the message beginning with doResolve().\n\u003e \n\u003e I need to do something or else the connection will just remain in a fail state and never get reused.  It seems like my only options are close the connection so it gets returned to the pool or retry sending the message.\n\nThis is where we need some subtleties;  I suspect that the class above (HttpClient) class needs to hold the to-be-sent data queue, and only erase items from the queue once they\u0027ve been successfully sent.\n\nIdeally the connection would never truly own any data, given the connection might be destroyed and need to be retried.  It might own by a shared_ptr, just to get lifetime gaurantees (probably want to hold weak_ptr internally, then shared_ptr when you start an async transaction with the data).",
      "parentUuid": "a8e7d539_2d2579b9",
      "range": {
        "startLine": 279,
        "startChar": 0,
        "endLine": 279,
        "endChar": 60
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7f8429c8_ced4124b",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 279,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-04-08T21:23:20Z",
      "side": 1,
      "message": "\u003e This is where we need some subtleties;  I suspect that the class above (HttpClient) class needs to hold the to-be-sent data queue, and only erase items from the queue once they\u0027ve been successfully sent.\n\u003e \n\u003e Ideally the connection would never truly own any data, given the connection might be destroyed and need to be retried.  It might own by a shared_ptr, just to get lifetime gaurantees (probably want to hold weak_ptr internally, then shared_ptr when you start an async transaction with the data).\n\nIf my justification from a previous comment for never deleting connections is valid then I won\u0027t have to worry about letting the ConnectionInfo own the data.  Because I\u0027ll have a connection pool I\u0027ll need some intermediate container anyway to hold the data when it is being sent.  If I wait to remove data from the queue until it\u0027s been successfully sent, then that would lock me into only sending a single message at a time.  ConnectionInfo\u0027s data member can serve as this intermediate container.",
      "parentUuid": "1a37a22a_2287d01c",
      "range": {
        "startLine": 279,
        "startChar": 0,
        "endLine": 279,
        "endChar": 60
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7f98f37f_19f4f10b",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 289,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-06T00:07:24Z",
      "side": 1,
      "message": "We shouldn\u0027t ignore timer errors like this.  If the timer subsystem in linux has failed us, we can just abort entirely, something has gone very wrong, and we should clean up and get out.",
      "range": {
        "startLine": 287,
        "startChar": 0,
        "endLine": 289,
        "endChar": 60
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "482a0c85_ee220d06",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 289,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-04-06T19:44:59Z",
      "side": 1,
      "message": "Similar to the previous comment, I was replicating the existing approach.  I\u0027ll do your suggestions and close the connection regardless of how many retries were remaining.",
      "parentUuid": "7f98f37f_19f4f10b",
      "range": {
        "startLine": 287,
        "startChar": 0,
        "endLine": 289,
        "endChar": 60
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d060a461_455d5f33",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 289,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-07T02:47:36Z",
      "side": 1,
      "message": "Yep, if the old code had a problem it\u0027s fine.  No need to boil the ocean.",
      "parentUuid": "482a0c85_ee220d06",
      "range": {
        "startLine": 287,
        "startChar": 0,
        "endLine": 289,
        "endChar": 60
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ee582f70_520f56d9",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 334,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-06T00:07:24Z",
      "side": 1,
      "message": "This is going to force a re-resolve for every request, which I\u0027m pretty sure isn\u0027t what we want.  We only want to re-resolve if the system stops responding.",
      "range": {
        "startLine": 334,
        "startChar": 12,
        "endLine": 334,
        "endChar": 47
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dc6f1815_aef3d877",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 334,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-04-06T19:44:59Z",
      "side": 1,
      "message": "This function only gets called when we want to retry a request that previously failed (including failures during doResolve()).  For all retries wouldn\u0027t we want to close the connection and then retry starting from the very beginning of the flow like in the existing code just to be safe?\n\nI suppose the alternative would be to check the value of self-\u003estate at the end of waitAndRetry() in order to begin the retry from the point in the flow the failed.  That would look like:\n\nresolveFailed --\u003e doResolve()\nconnectFailed --\u003e doConnect()\nsendFailed --\u003e sendMessage()\nrecvFailed --\u003e doCloseAndRetry()",
      "parentUuid": "ee582f70_520f56d9",
      "range": {
        "startLine": 334,
        "startChar": 12,
        "endLine": 334,
        "endChar": 47
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "072067ba_69251c1a",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 394,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-06T00:07:24Z",
      "side": 1,
      "message": "This can\u0027t be the final behavior;  We will overwhelm servers this way if we get a flood of events, and we spin up one connection per event.  There needs to be some kind of queue, and a limit on number of connections per client (probably 1-4 is a good reasonable starting place).\n\nThis is what the requestDataQueue variable was supposed to handle in the old code, and I don\u0027t think we can remove it.",
      "range": {
        "startLine": 394,
        "startChar": 8,
        "endLine": 394,
        "endChar": 60
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c9d1c1d1_42cc899d",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 394,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-04-11T06:54:44Z",
      "side": 1,
      "message": "I changed it so that now each connection pool can only have a max of 4 connections.  Each pool also has a requestDataQueue like in the old code to buffer the additional requests that need to be sent when all connections in the pool are in use.",
      "parentUuid": "072067ba_69251c1a",
      "range": {
        "startLine": 394,
        "startChar": 8,
        "endLine": 394,
        "endChar": 60
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "93a6e48c_d2894194",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 394,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-19T18:28:53Z",
      "side": 1,
      "message": "Based on what you described, sounds good (haven\u0027t gotten a chance to look at the patchset yet).",
      "parentUuid": "c9d1c1d1_42cc899d",
      "range": {
        "startLine": 394,
        "startChar": 8,
        "endLine": 394,
        "endChar": 60
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "66bddff5_b2c2d89e",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 394,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-04-26T17:09:21Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "93a6e48c_d2894194",
      "range": {
        "startLine": 394,
        "startChar": 8,
        "endLine": 394,
        "endChar": 60
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8d7cfc75_c199fe8a",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 429,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-06T00:07:24Z",
      "side": 1,
      "message": "nit, this-\u003e isn\u0027t required for member classes.",
      "range": {
        "startLine": 429,
        "startChar": 8,
        "endLine": 429,
        "endChar": 14
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1463af06_d38d28dc",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 429,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-04-08T20:53:13Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "8d7cfc75_c199fe8a",
      "range": {
        "startLine": 429,
        "startChar": 8,
        "endLine": 429,
        "endChar": 14
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3c5272ee_50abc82a",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 436,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-06T00:07:24Z",
      "side": 1,
      "message": "probably want unordered_map here.",
      "range": {
        "startLine": 436,
        "startChar": 9,
        "endLine": 436,
        "endChar": 12
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4a8daef9_57255b09",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 436,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-04-06T19:44:59Z",
      "side": 1,
      "message": "I know unordered_map has constant time lookup, but I\u0027m still concerned that there won\u0027t realistically be enough \"connectionPool\" objects in the map to overcome the overhead of the hash operation (e.g. for 10 items it should actually take less time to locate an item in std::map than in std::unordered_map).\n\nI\u0027ll make the change to unordered_map for this CL and leave exploring alternatives to something that can be revisited in the future if needed.",
      "parentUuid": "3c5272ee_50abc82a",
      "range": {
        "startLine": 436,
        "startChar": 9,
        "endLine": 436,
        "endChar": 12
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a9e799d1_4b435a29",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 436,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-07T02:47:36Z",
      "side": 1,
      "message": "ACK.  I do appreciate that you\u0027ve thought about the problem;  If you want to leave it as-is, it\u0027s fine.  I guess I always assumed that std::less on a string, when doing multiple comparisons (especially comparisons that have common prefixes, which seems likely) would far and above beat the overhead of std::hash.\n\nWith that said, agree, we\u0027re probably in the noise for either.  Use whichever works for you.",
      "parentUuid": "4a8daef9_57255b09",
      "range": {
        "startLine": 436,
        "startChar": 9,
        "endLine": 436,
        "endChar": 12
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "455c1737_4ec93aa2",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 467,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-06T00:07:24Z",
      "side": 1,
      "message": "This is doing your key lookup twice.  The API you\u0027re looking for here is try_emplace().  The ret.second parameter tells you if the element was constructed.",
      "range": {
        "startLine": 467,
        "startChar": 28,
        "endLine": 467,
        "endChar": 36
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "063824aa_08c64ee7",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 467,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-04-08T20:53:13Z",
      "side": 1,
      "message": "I switched to using try_emplace() and moved this section of code into sendData().",
      "parentUuid": "455c1737_4ec93aa2",
      "range": {
        "startLine": 467,
        "startChar": 28,
        "endLine": 467,
        "endChar": 36
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "421eb687_651e4a7d",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 476,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-06T00:07:24Z",
      "side": 1,
      "message": "I would\u0027ve expected the \"connectionExists\" and \"createConnection\" methods to be private to a user of this interface.  There\u0027s less left to implementation details in that way, and it simplifies the calling code.",
      "range": {
        "startLine": 451,
        "startChar": 0,
        "endLine": 476,
        "endChar": 8
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "040eae57_0b8b0132",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 476,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-06T00:07:24Z",
      "side": 1,
      "message": "You shouldn\u0027t need to construct a temporary here with emplace (it kinda defeats the purpose), and also requires your ConnectionPool element to have a move operator, which ideally you wouldn\u0027t want.\n\nping me on discord if you cant get the in-place construction to work, it should definitely be possible here.",
      "range": {
        "startLine": 476,
        "startChar": 12,
        "endLine": 476,
        "endChar": 26
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cc105b22_06a295f7",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 476,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-04-06T19:44:59Z",
      "side": 1,
      "message": "I did that to try to simply the individual calls to sendData().  I can change connectionExists() and createConnection() to be private, but that will require providing their arguments to sendData().  This new sendData() would attempt to create a connection pool if one doesn\u0027t already exist before sending the message to the specified client.  The end result would be something like:\n\nvoid sendData(\n    const std::string\u0026 data, \n    boost::asio::io_context\u0026 ioc,\n    const std::string\u0026 id,\n    const std::string\u0026 destIP,\n    const std::string\u0026 destPort,\n    const std::string\u0026 destUri,\n    const boost::beast::http::fields\u0026 httpHeader\n)\n\nI feel like this still complicates the calling code, but just in a different way.  Is this acceptable or is there another option?\n\nWhat if I make \"createConnection\" private, keep the existing version of sendData(), and also add the new version of sendData()?  Presumably you\u0027ll want to send data when you first create a connection pool so that would combine the two steps.  The existing sendData() would be called when you can assume a client connection already exists, and connectionExists() provides the ability to choose between the two situations in case the calling code needs to know.",
      "parentUuid": "421eb687_651e4a7d",
      "range": {
        "startLine": 451,
        "startChar": 0,
        "endLine": 476,
        "endChar": 8
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fba4f22d_4e1235cc",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 476,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-07T02:47:36Z",
      "side": 1,
      "message": "\u003e I did that to try to simply the individual calls to sendData().  I can change connectionExists() and createConnection() to be private, but that will require providing their arguments to sendData().  This new sendData() would attempt to create a connection pool if one doesn\u0027t already exist before sending the message to the specified client.  The end result would be something like:\n\u003e \n\u003e void sendData(\n\u003e     const std::string\u0026 data, \n\u003e     boost::asio::io_context\u0026 ioc,\n\u003e     const std::string\u0026 id,\n\u003e     const std::string\u0026 destIP,\n\u003e     const std::string\u0026 destPort,\n\u003e     const std::string\u0026 destUri,\n\u003e     const boost::beast::http::fields\u0026 httpHeader\n\u003e )\n\nwhile it seems a little messy, I think it\u0027s a decent API, although can we pass ioc on construction of the object, instead of for each sendData call?  that\u0027s how most of the other implementations do it.\n\n\u003e \n\u003e I feel like this still complicates the calling code, but just in a different way.  Is this acceptable or is there another option?\n\nIf I compare to the python requests library (which is my gold standard for this kind of thing):\nhttps://docs.python-requests.org/en/latest/api/\n\nWhat you have above is basically the same, with the exceptions that destIp/Port/URI are all combined into one string (which seems reasonable given your API)\n\n\u003e \n\u003e What if I make \"createConnection\" private, keep the existing version of sendData(), and also add the new version of sendData()?  Presumably you\u0027ll want to send data when you first create a connection pool so that would combine the two steps.\n\nI\u0027m not quite following;  Why is that better than just calling a single overload of sendData?  The caller has to maintain the request structure around anyway, right?\n\n\u003e  The existing sendData() would be called when you can assume a client connection already exists, and connectionExists() provides the ability to choose between the two situations in case the calling code needs to know.\n\nThis seems like it\u0027s just pushing stuff into the library that really shouldn\u0027t be.  If you think it\u0027s cleaner, I\u0027ll concede, this isn\u0027t super important to me, but just about every client http library I know of requires you provide the connection details with every request (see requests above).",
      "parentUuid": "cc105b22_06a295f7",
      "range": {
        "startLine": 451,
        "startChar": 0,
        "endLine": 476,
        "endChar": 8
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "af0fb90e_07ffbbe0",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 476,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-04-07T20:56:51Z",
      "side": 1,
      "message": "Most of my motivation was trying to keep sendData() as close to the original implementation as possible which was only \"void sendData(const std::string\u0026 data)\". I\u0027m good with only having the single version with more arguments now that I know that\u0027s pretty standard.\n\n\u003e can we pass ioc on construction of the object, instead of for each sendData call?\n\nI can lookup ioc when HttpClient is initialized and then pass it to ConnectionPool and later ConnectionInfo each time one is created.",
      "parentUuid": "fba4f22d_4e1235cc",
      "range": {
        "startLine": 451,
        "startChar": 0,
        "endLine": 476,
        "endChar": 8
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "36242d63_c62294e4",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 476,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-04-08T20:53:13Z",
      "side": 1,
      "message": "sendData() is now the lone public API.  It handles creating a new connection pool if one does not already exist and then sends the request.  I used try_emplace() as advised in a previous comment to perform the check and also construct a new ConnectionPool in place if one does not exist.\n\nThe createConnection() and connectionExists() functions have been deleted and their functionality effectively moved into sendData().",
      "parentUuid": "af0fb90e_07ffbbe0",
      "range": {
        "startLine": 451,
        "startChar": 0,
        "endLine": 476,
        "endChar": 8
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3e350639_5e9d5f41",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 476,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-04-08T20:53:13Z",
      "side": 1,
      "message": "I think I got it to work if you can confirm it looks correct.  I also moved this section of code into sendData().",
      "parentUuid": "040eae57_0b8b0132",
      "range": {
        "startLine": 476,
        "startChar": 12,
        "endLine": 476,
        "endChar": 26
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d52047bd_24a1aafa",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 491,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-06T00:07:24Z",
      "side": 1,
      "message": "Please don\u0027t use exceptions for this kind of error handling;  Other bmcweb code prefers range checks and return codes for handlable (ie non fatal) errors.",
      "range": {
        "startLine": 487,
        "startChar": 0,
        "endLine": 491,
        "endChar": 9
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "81252901_041f1672",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 491,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-04-06T19:44:59Z",
      "side": 1,
      "message": "I was trying to avoid performing two lookups on \"connectionPools\".  I can use find() instead to accomplish this while also removing the use of exceptions.",
      "parentUuid": "d52047bd_24a1aafa",
      "range": {
        "startLine": 487,
        "startChar": 0,
        "endLine": 491,
        "endChar": 9
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5008f0bb_c8db9cd6",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 491,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-07T02:47:36Z",
      "side": 1,
      "message": "üëç",
      "parentUuid": "81252901_041f1672",
      "range": {
        "startLine": 487,
        "startChar": 0,
        "endLine": 491,
        "endChar": 9
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "19fd5cac_86b05b2f",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 491,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-04-08T20:53:13Z",
      "side": 1,
      "message": "I removed the exception in favor of using find().",
      "parentUuid": "5008f0bb_c8db9cd6",
      "range": {
        "startLine": 487,
        "startChar": 0,
        "endLine": 491,
        "endChar": 9
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9267cdb4_506701c8",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 505,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-06T00:07:24Z",
      "side": 1,
      "message": "There retry policies are EventService subscription specific, and I wouldn\u0027t really expect them to be in a common class.  Aggregator retries (which are implementation defined) are going to have very different policies than EventSerivce, which is defined by the redfish spec.",
      "range": {
        "startLine": 495,
        "startChar": 0,
        "endLine": 505,
        "endChar": 1
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9eb227f6_d81b6a01",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 505,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-04-06T19:44:59Z",
      "side": 1,
      "message": "Sounds good.  I\u0027ll make each ConnectionPool have its own associated retry policy.  The policy will need to be viewable by each ConnectionInfo in the pool.  My options are:\n(1) Have the policy variables be members of ConnectionPool and add pointers to these members within each associated ConnectionInfo.\n(2) Have a global map (or similar struct) that contains \u003cHostPortKey,policy struct\u003e.  Each ConnectionInfo would have to query the global to get its associated policy.\n\nI think the first option would be both faster to interact with and require less memory.",
      "parentUuid": "9267cdb4_506701c8",
      "range": {
        "startLine": 495,
        "startChar": 0,
        "endLine": 505,
        "endChar": 1
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eb8faca6_33145197",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 505,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-07T02:47:36Z",
      "side": 1,
      "message": "\u003e Sounds good.  I\u0027ll make each ConnectionPool have its own associated retry policy.  The policy will need to be viewable by each ConnectionInfo in the pool.  My options are:\n\nI was actually thinking we just push it into client code (ie, EventService has a retry mechanism, and aggregator has a different retry mechanism).  With that said, if you want to try to do a generic thing, I\u0027m in for the ride, lets see if we can build something reasonable.\n\n\u003e (1) Have the policy variables be members of ConnectionPool and add pointers to these members within each associated ConnectionInfo.\n\u003e (2) Have a global map (or similar struct) that contains \u003cHostPortKey,policy struct\u003e.  Each ConnectionInfo would have to query the global to get its associated policy.\n\u003e \n\u003e I think the first option would be both faster to interact with and require less memory.\n\n1 seems fine, just use shared_ptr where appropriate.",
      "parentUuid": "9eb227f6_d81b6a01",
      "range": {
        "startLine": 495,
        "startChar": 0,
        "endLine": 505,
        "endChar": 1
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b5dca36f_49e116e1",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 505,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-04-11T06:54:44Z",
      "side": 1,
      "message": "I moved these functions back to HttpClient methods.  They now take also require a host and port argument so that the retry details can be linked to the associated connection pool.\n\nI think this will work as a generic approach as long as each each host:port combination can only have a single retry policy.\n\nAre shared_ptr\u0027s still needed if connections won\u0027t be destroyed during normal operation?",
      "parentUuid": "eb8faca6_33145197",
      "range": {
        "startLine": 495,
        "startChar": 0,
        "endLine": 505,
        "endChar": 1
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "252dd3a9_ee370245",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 505,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-19T18:28:53Z",
      "side": 1,
      "message": "\u003e I moved these functions back to HttpClient methods.  They now take also require a host and port argument so that the retry details can be linked to the associated connection pool.\n\u003e \n\u003e I think this will work as a generic approach as long as each each host:port combination can only have a single retry policy.\n\nI don\u0027t think that can be guaranteed.  EventService and a Redfish client could be on the same server, or could be operating through a reverse proxy or load balancer.\n\n\u003e \n\u003e Are shared_ptr\u0027s still needed if connections won\u0027t be destroyed during normal operation?\n\nAs a statement, we can\u0027t have that;  Connections MUST be able to be destroyed in normal operation, otherwise we\u0027ll run out of memory.\n\nAlso application shutdown is part of \"normal operation\" so the connections will be destroyed at some point.  If we\u0027re in the middle of a read/write when that shutdown happens, the ownership needs to be handled properly.\n\nNow, there are a bunch of patterns for ensuring RAII correctness, shared_ptr/weak_ptr is one of them (ie, share ownership between the real owners, and the callback) and I\u0027m ok with basically any that are engineer-wise correct.  What I\u0027m not ok with is relying on UB on object destruction.  Not handling that properly has caused way too much hard-to-triage bugs in the past.\n\nNote, all of the above is said without having looked at your current patch, and someone keying off a single sentence.  It\u0027s quite possible you\u0027ve handled this already",
      "parentUuid": "b5dca36f_49e116e1",
      "range": {
        "startLine": 495,
        "startChar": 0,
        "endLine": 505,
        "endChar": 1
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7839be39_4c00f00a",
        "filename": "http/http_client.hpp",
        "patchSetId": 20
      },
      "lineNbr": 505,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2022-04-26T17:09:21Z",
      "side": 1,
      "message": "\u003e I don\u0027t think that can be guaranteed.  EventService and a Redfish client could be on the same server, or could be operating through a reverse proxy or load balancer.\n\nI\u0027ve been thinking on this, and my solution is to use a retryPolicyName argument as the key rather than a host:port pair.  The retry policy is now set on a per connection basis.  That means there is still only a single connection pool per each host:port pair, but connections within that pool can have different retry policies.\n\nThe retry policies are stored as a global map.  sendData() requires supplying a retry policy argument.  That policy name is ultimately used to set the retry policy for each message send by ConnectionInfo.  The policy name is queued if all connections in the pool are in use.  The methods setRetryConfig() and setRetryPolicy() have been converted into free functions.\n\nFor the RAII correctness I tried to follow the existing implementation as an example, but I\u0027m not sure if my changes are completely compliant.",
      "parentUuid": "252dd3a9_ee370245",
      "range": {
        "startLine": 495,
        "startChar": 0,
        "endLine": 505,
        "endChar": 1
      },
      "revId": "b61ba6f3154203ee2ec27df956c849e4111b6718",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}