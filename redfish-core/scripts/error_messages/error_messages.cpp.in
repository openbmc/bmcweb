/*
// Copyright (c) 2018 Intel Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
*/
#include <error_messages.hpp>
#include <crow/logging.h>

namespace redfish {

namespace messages {

void addMessageToErrorJson(nlohmann::json& target,
                           const nlohmann::json& message) {
  auto& error = target["error"];

  // If this is the first error message, fill in the information from the first
  // error message to the top level struct
  if (!error.is_object()) {
    auto message_id_iterator = message.find("MessageId");
    if (message_id_iterator == message.end()) {
      BMCWEB_LOG_CRITICAL << "Attempt to add error message without MessageId";
      return;
    }

    auto message_field_iterator = message.find("Message");
    if (message_field_iterator == message.end()) {
      BMCWEB_LOG_CRITICAL << "Attempt to add error message without Message";
      return;
    }
    // clang-format off
    error = {
        {"code", *message_id_iterator},
        {"message", *message_field_iterator}
    };
    // clang-format on
  } else {
    // More than 1 error occurred, so the message has to be generic
    error["code"] = std::string(messageVersionPrefix) + "GeneralError";
    error["message"] = "A general error has occurred. See ExtendedInfo for more"
        "information.";
  }

  // This check could technically be done in in the default construction
  // branch above, but because we need the pointer to the extended info field
  // anyway, it's more efficient to do it here.
  auto& extended_info = error[messages::messageAnnotation];
  if (!extended_info.is_array()) {
    extended_info = nlohmann::json::array();
  }

  extended_info.push_back(message);
}

void addMessageToJsonRoot(nlohmann::json& target,
                          const nlohmann::json& message) {
  if (!target[messages::messageAnnotation].is_array()) {
    // Force object to be an array
    target[messages::messageAnnotation] = nlohmann::json::array();
  }

  target[messages::messageAnnotation].push_back(message);
}

void addMessageToJson(nlohmann::json& target, const nlohmann::json& message,
                      const std::string& fieldPath) {
  nlohmann::json_pointer extendedInfo(fieldPath + messages::messageAnnotation);

  if (!target[extendedInfo].is_array()) {
    // Force object to be an array
    target[extendedInfo] = nlohmann::json::array();
  }

  // Object exists and it is an array so we can just push in the message
  target[extendedInfo].push_back(message);
}

/*********************************
 * AUTOGENERATED FUNCTIONS START *
 *********************************/

/*<<<<<<AUTOGENERATED_FUNCTIONS_IMPLEMENTATIONS>>>>>>*/

/*********************************
 * AUTOGENERATED FUNCTIONS END *
 *********************************/

}  // namespace messages

}  // namespace redifsh
