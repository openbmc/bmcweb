{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "a429c8e1_a6afe695",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 10
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-07-19T18:22:51Z",
      "side": 1,
      "message": "Overall, I\u0027m really surprised we\u0027re having to write this ourselves.  Is there nothing in boost, or std::chrono that can generate what we need?",
      "revId": "4270c234f1d8575ec9388892bd3da9c28e50f779",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0cd60c9b_64e7304b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 10
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-07-19T18:30:50Z",
      "side": 1,
      "message": "I\u0027m taking a look at the to_iso_extended_string implementation here, and it looks like it\u0027s entirely implemented using public methods.\n\n\nhttps://github.com/boostorg/date_time/blob/acbee0dc6a168289c398041e91e053b3684083fc/include/boost/date_time/posix_time/time_formatters_limited.hpp#L196\n\n\n\nIt looks like we\u0027ve implemented more code than to_simple_string:\n\nhttps://github.com/boostorg/date_time/blob/acbee0dc6a168289c398041e91e053b3684083fc/include/boost/date_time/posix_time/time_formatters_limited.hpp#L27\n\n\nShould we just:\n\nCopy/paste the above code, remove the things we don\u0027t need (MSVC IFDEF for example), adapt the error conditions (We should never return \"infinity\" for example), then just modify the call to num_fractional_digits() to just use the parameter we have here?\n\n\nThat seems like it would be less code, and faster than what we\u0027re doing below.",
      "revId": "4270c234f1d8575ec9388892bd3da9c28e50f779",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "30526223_1a3124d3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 10
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-07-19T18:32:20Z",
      "side": 1,
      "message": "Wait.... I\u0027m looking at this further, num_fractional_digits is determined by the underlying type.....  Is the answer that we just need to cast the 3 digit to posix_time::milliseconds, and 6 digit to posix_time_microseconds, and the rest will just work?",
      "parentUuid": "0cd60c9b_64e7304b",
      "revId": "4270c234f1d8575ec9388892bd3da9c28e50f779",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bccff1a9_75496f13",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 10
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-07-20T02:57:30Z",
      "side": 1,
      "message": "https://stackoverflow.com/questions/9157816/fixed-precision-for-boostposix-timeptime#comment11517711_9158177",
      "revId": "4270c234f1d8575ec9388892bd3da9c28e50f779",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "217b8219_d49392ba",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 10
      },
      "lineNbr": 0,
      "author": {
        "id": 1001143
      },
      "writtenOn": "2022-07-22T04:19:27Z",
      "side": 1,
      "message": "In patchset 11 I am taking the copy-paste approach. If we go with it, does any Boost license text need to be added or do we have it somewhere already?\n\nFrom what I read and observed with bench testing, num_fractional_digits() is based on the max resolution configured by compile options (microseconds in our case), and casting doesn\u0027t help.\n\nPrint output:\nboost::posix_time::time_duration::num_fractional_digits(): 6\nboost::posix_time::milliseconds::num_fractional_digits(): 6\nboost::posix_time::microseconds::num_fractional_digits(): 6",
      "parentUuid": "30526223_1a3124d3",
      "revId": "4270c234f1d8575ec9388892bd3da9c28e50f779",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "84d3834f_9dd71b90",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 10
      },
      "lineNbr": 0,
      "author": {
        "id": 1001143
      },
      "writtenOn": "2022-07-22T04:19:27Z",
      "side": 1,
      "message": "There are two issues in existing code that I\u0027m trying to solve as part of this patchset:\n\n1) Nonzero value fraction digits: too many fraction digits are output for timestamps intended to be millisecond-precision\n2) All-0 value fraction digits: they are truncated, which isn\u0027t what we want for timestamps that are intended to be higher precision than seconds\n\nIt looks like boost::date_time::time_facet can help us solve the second problem but not the first. Still, thanks for finding and sharing this post.",
      "parentUuid": "bccff1a9_75496f13",
      "revId": "4270c234f1d8575ec9388892bd3da9c28e50f779",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "17225592_f65408e6",
        "filename": "http/utility.hpp",
        "patchSetId": 10
      },
      "lineNbr": 553,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-07-19T18:22:51Z",
      "side": 1,
      "message": "I don\u0027t think this works, given that there are optional fields, and I don\u0027t beleive \u003cMM\u003e-\u003cDD\u003e are required to be zero padded.",
      "range": {
        "startLine": 553,
        "startChar": 18,
        "endLine": 553,
        "endChar": 33
      },
      "revId": "4270c234f1d8575ec9388892bd3da9c28e50f779",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e93d63f0_f6a6c58f",
        "filename": "http/utility.hpp",
        "patchSetId": 10
      },
      "lineNbr": 553,
      "author": {
        "id": 1001143
      },
      "writtenOn": "2022-07-22T04:19:27Z",
      "side": 1,
      "message": "It\u0027s a moot point now with the latest patchset, but padding is required and there aren\u0027t optional fields to the left of the decimal (well maybe the \u0027T\u0027, though in practice to_iso_extended_string() always gives it to us). But it\u0027d be fair to say this kind of code is brittle.",
      "parentUuid": "17225592_f65408e6",
      "range": {
        "startLine": 553,
        "startChar": 18,
        "endLine": 553,
        "endChar": 33
      },
      "revId": "4270c234f1d8575ec9388892bd3da9c28e50f779",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c2f465bd_e3c273b7",
        "filename": "http/utility.hpp",
        "patchSetId": 10
      },
      "lineNbr": 563,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-07-20T02:57:30Z",
      "side": 1,
      "message": "BTW, it looks like there\u0027s a constructor for ptime that does this for us\n\nptime(date,time_duration)",
      "range": {
        "startLine": 563,
        "startChar": 29,
        "endLine": 563,
        "endChar": 59
      },
      "revId": "4270c234f1d8575ec9388892bd3da9c28e50f779",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3bb1facf_8c3ae387",
        "filename": "http/utility.hpp",
        "patchSetId": 10
      },
      "lineNbr": 563,
      "author": {
        "id": 1001143
      },
      "writtenOn": "2022-07-22T04:19:27Z",
      "side": 1,
      "message": "Updated to use the constructor.",
      "parentUuid": "c2f465bd_e3c273b7",
      "range": {
        "startLine": 563,
        "startChar": 29,
        "endLine": 563,
        "endChar": 59
      },
      "revId": "4270c234f1d8575ec9388892bd3da9c28e50f779",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "07aab98f_252e7a77",
        "filename": "http/utility.hpp",
        "patchSetId": 10
      },
      "lineNbr": 584,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-07-19T18:22:51Z",
      "side": 1,
      "message": "This should just be a range check.  If there\u0027s code that\u0027s requesting \u003e fractionDigitsMicroSeconds, it\u0027s arguably incorrect, we should just return empty string.",
      "range": {
        "startLine": 583,
        "startChar": 1,
        "endLine": 584,
        "endChar": 73
      },
      "revId": "4270c234f1d8575ec9388892bd3da9c28e50f779",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1d4a1310_cb1988a5",
        "filename": "http/utility.hpp",
        "patchSetId": 10
      },
      "lineNbr": 584,
      "author": {
        "id": 1001143
      },
      "writtenOn": "2022-07-22T04:19:27Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "07aab98f_252e7a77",
      "range": {
        "startLine": 583,
        "startChar": 1,
        "endLine": 584,
        "endChar": 73
      },
      "revId": "4270c234f1d8575ec9388892bd3da9c28e50f779",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dfb9a7ec_be46b3ac",
        "filename": "http/utility.hpp",
        "patchSetId": 10
      },
      "lineNbr": 586,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-07-19T18:22:51Z",
      "side": 1,
      "message": "This seems a little error prone;  Is there a way we can just generate the struct we need upfront, rather than generating the wrong one, and then trying to turn it into the one we need?  It seems odd there\u0027s not a boost::posix_time overload that can do this.\n\n\nAlso, this is really odd.... if we know decimalPosition, can\u0027t we just check string[decimalPosition] \u003d\u003d \u0027.\u0027 ?",
      "range": {
        "startLine": 586,
        "startChar": 0,
        "endLine": 586,
        "endChar": 58
      },
      "revId": "4270c234f1d8575ec9388892bd3da9c28e50f779",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7e600bb4_606aa580",
        "filename": "http/utility.hpp",
        "patchSetId": 10
      },
      "lineNbr": 586,
      "author": {
        "id": 1001143
      },
      "writtenOn": "2022-07-22T04:19:27Z",
      "side": 1,
      "message": "Moot point with the latest patchset, but indeed checking string[decimalPosition] would have been more straightforward. The benefit of find() is that it can tell us whether a decimal was found in an unexpected position (invalid) vs. not present at all (valid), so it depends if we need to differentiate between those cases.",
      "parentUuid": "dfb9a7ec_be46b3ac",
      "range": {
        "startLine": 586,
        "startChar": 0,
        "endLine": 586,
        "endChar": 58
      },
      "revId": "4270c234f1d8575ec9388892bd3da9c28e50f779",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}