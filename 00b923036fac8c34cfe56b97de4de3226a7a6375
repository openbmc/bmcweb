{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "877f5a3f_196351a4",
        "filename": "http/http_body.hpp",
        "patchSetId": 3
      },
      "lineNbr": 56,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-05-12T22:31:44Z",
      "side": 1,
      "message": "?",
      "revId": "00b923036fac8c34cfe56b97de4de3226a7a6375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ce4cae26_6ff266f7",
        "filename": "http/http_body.hpp",
        "patchSetId": 3
      },
      "lineNbr": 56,
      "author": {
        "id": 1002325
      },
      "writtenOn": "2025-05-14T18:49:13Z",
      "side": 1,
      "message": "These declarations allow the reader and writer classes to access private members of the value_type class. Reader class directly accesses and modifies mimeFields and Writer class access file related members to read data from file",
      "parentUuid": "877f5a3f_196351a4",
      "revId": "00b923036fac8c34cfe56b97de4de3226a7a6375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "92f964c3_0ce5a407",
        "filename": "http/http_body.hpp",
        "patchSetId": 3
      },
      "lineNbr": 62,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-05-12T22:31:44Z",
      "side": 1,
      "message": "We\u0027re now at the point where we have 3 embedded types here.  Checking fileHandle.is_open() was a relatively easy way to tell which was being used for any given body.  Now that we have a third, I suspect this needs to become a std::variant\u003cstd::string, DuplicatableFileHandle, std::vector\u003cFormPart\u003e\u003e;",
      "range": {
        "startLine": 58,
        "startChar": 0,
        "endLine": 62,
        "endChar": 39
      },
      "revId": "00b923036fac8c34cfe56b97de4de3226a7a6375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bf9646bb_e54c6036",
        "filename": "http/http_body.hpp",
        "patchSetId": 3
      },
      "lineNbr": 62,
      "author": {
        "id": 1002325
      },
      "writtenOn": "2025-05-29T08:27:35Z",
      "side": 1,
      "message": "This might need some rework and would increase the scope of this patch. Shall we take this up as a follow up commit ?",
      "parentUuid": "92f964c3_0ce5a407",
      "range": {
        "startLine": 58,
        "startChar": 0,
        "endLine": 62,
        "endChar": 39
      },
      "revId": "00b923036fac8c34cfe56b97de4de3226a7a6375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "21e9546f_0022b450",
        "filename": "http/http_body.hpp",
        "patchSetId": 3
      },
      "lineNbr": 62,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-05-29T22:48:48Z",
      "side": 1,
      "message": "Feel free to put it as a patch ahead of this if you\u0027re worried about this patch getting to large, but I don\u0027t like the subtlety that this can be one of three different types.",
      "parentUuid": "bf9646bb_e54c6036",
      "range": {
        "startLine": 58,
        "startChar": 0,
        "endLine": 62,
        "endChar": 39
      },
      "revId": "00b923036fac8c34cfe56b97de4de3226a7a6375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ae3c1a4c_83234c22",
        "filename": "http/http_body.hpp",
        "patchSetId": 3
      },
      "lineNbr": 62,
      "author": {
        "id": 1002325
      },
      "writtenOn": "2025-06-11T19:12:54Z",
      "side": 1,
      "message": "Sure, I\u0027ll be creating a patch for this.",
      "parentUuid": "21e9546f_0022b450",
      "range": {
        "startLine": 58,
        "startChar": 0,
        "endLine": 62,
        "endChar": 39
      },
      "revId": "00b923036fac8c34cfe56b97de4de3226a7a6375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aec8baa5_aa52798d",
        "filename": "http/http_body.hpp",
        "patchSetId": 3
      },
      "lineNbr": 62,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-07-01T16:10:38Z",
      "side": 1,
      "message": "I see the patch.  Would like to see the variant done first so this patchset is reviewable.  If that\u0027s not something you can manage, I can do it.",
      "parentUuid": "ae3c1a4c_83234c22",
      "range": {
        "startLine": 58,
        "startChar": 0,
        "endLine": 62,
        "endChar": 39
      },
      "revId": "00b923036fac8c34cfe56b97de4de3226a7a6375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "213f558a_9c34da49",
        "filename": "http/http_body.hpp",
        "patchSetId": 3
      },
      "lineNbr": 62,
      "author": {
        "id": 1002325
      },
      "writtenOn": "2025-07-01T16:58:20Z",
      "side": 1,
      "message": "@ed@tanous.net I\u0027ve made this change, kindly re-review the patch.",
      "parentUuid": "aec8baa5_aa52798d",
      "range": {
        "startLine": 58,
        "startChar": 0,
        "endLine": 62,
        "endChar": 39
      },
      "revId": "00b923036fac8c34cfe56b97de4de3226a7a6375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8ed2791f_551324da",
        "filename": "http/http_body.hpp",
        "patchSetId": 3
      },
      "lineNbr": 274,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-05-15T22:41:34Z",
      "side": 1,
      "message": "Another thing to consider here is that now all URIs will now implicitly support reading multipart requests.  We should make some attempt to disallow that in the obvious cases.\n\nChecking the verb is POST before allowing multipart would be a good start, and would remove a lot of the obvious footguns that would give a weird error message back to the user.",
      "range": {
        "startLine": 274,
        "startChar": 33,
        "endLine": 274,
        "endChar": 44
      },
      "revId": "00b923036fac8c34cfe56b97de4de3226a7a6375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fea537c7_3d7cdd34",
        "filename": "http/http_body.hpp",
        "patchSetId": 3
      },
      "lineNbr": 274,
      "author": {
        "id": 1002325
      },
      "writtenOn": "2025-05-29T08:27:35Z",
      "side": 1,
      "message": "I\u0027ve added a check for POST method. Please review.",
      "parentUuid": "8ed2791f_551324da",
      "range": {
        "startLine": 274,
        "startChar": 33,
        "endLine": 274,
        "endChar": 44
      },
      "revId": "00b923036fac8c34cfe56b97de4de3226a7a6375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "88c13a7d_bd48e811",
        "filename": "http/http_body.hpp",
        "patchSetId": 3
      },
      "lineNbr": 275,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-05-12T22:31:44Z",
      "side": 1,
      "message": "Please fix this check.\n\n1. !multipartParser will always be true when this is called after construction\n2. We have content-type parsers now.  Please use them.\n3. !contentType.empty() is redundant if the next check is comparing starts_with",
      "revId": "00b923036fac8c34cfe56b97de4de3226a7a6375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7678cef3_2e9ea317",
        "filename": "http/http_body.hpp",
        "patchSetId": 3
      },
      "lineNbr": 275,
      "author": {
        "id": 1002325
      },
      "writtenOn": "2025-05-29T08:27:35Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "88c13a7d_bd48e811",
      "revId": "00b923036fac8c34cfe56b97de4de3226a7a6375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d03aceeb_12025d3f",
        "filename": "http/http_body.hpp",
        "patchSetId": 3
      },
      "lineNbr": 283,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-05-12T22:31:44Z",
      "side": 1,
      "message": "No need to reset it here.  We\u0027re returning an error, the whole reader object is about to be destroyed.",
      "range": {
        "startLine": 283,
        "startChar": 0,
        "endLine": 283,
        "endChar": 40
      },
      "revId": "00b923036fac8c34cfe56b97de4de3226a7a6375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "47ead476_b9260781",
        "filename": "http/http_body.hpp",
        "patchSetId": 3
      },
      "lineNbr": 283,
      "author": {
        "id": 1002325
      },
      "writtenOn": "2025-05-14T18:59:16Z",
      "side": 1,
      "message": "Makes sense, I\u0027ll revert this",
      "parentUuid": "d03aceeb_12025d3f",
      "range": {
        "startLine": 283,
        "startChar": 0,
        "endLine": 283,
        "endChar": 40
      },
      "revId": "00b923036fac8c34cfe56b97de4de3226a7a6375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d25b0b7d_e87f9532",
        "filename": "http/http_body.hpp",
        "patchSetId": 3
      },
      "lineNbr": 283,
      "author": {
        "id": 1002325
      },
      "writtenOn": "2025-05-29T08:27:35Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "47ead476_b9260781",
      "range": {
        "startLine": 283,
        "startChar": 0,
        "endLine": 283,
        "endChar": 40
      },
      "revId": "00b923036fac8c34cfe56b97de4de3226a7a6375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "81251c02_aa830e59",
        "filename": "http/http_body.hpp",
        "patchSetId": 3
      },
      "lineNbr": 285,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-05-12T22:31:44Z",
      "side": 1,
      "message": "Keep in mind, when we hit parsing errors, we need to be able to return 400 bad request from the handler.  As written, I suspect you want to just set an internal error, that the handler can read back on multipart().",
      "range": {
        "startLine": 284,
        "startChar": 0,
        "endLine": 285,
        "endChar": 54
      },
      "revId": "00b923036fac8c34cfe56b97de4de3226a7a6375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "40237df0_2747b096",
        "filename": "http/http_body.hpp",
        "patchSetId": 3
      },
      "lineNbr": 285,
      "author": {
        "id": 1002325
      },
      "writtenOn": "2025-05-14T18:49:13Z",
      "side": 1,
      "message": "Just revisited the http_connection code — shouldn\u0027t this be handled in afterRead()? We could add a condition to specifically check for bad_message there.\n\nFrom what I understand of the current design, the execution will never reach the update_service handler because afterRead() calls gracefulClose() as soon as any error is encountered.\n\nPlease correct me if I’m missing something.",
      "parentUuid": "81251c02_aa830e59",
      "range": {
        "startLine": 284,
        "startChar": 0,
        "endLine": 285,
        "endChar": 54
      },
      "revId": "00b923036fac8c34cfe56b97de4de3226a7a6375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0ea4942b_17ca5c3f",
        "filename": "http/http_body.hpp",
        "patchSetId": 3
      },
      "lineNbr": 285,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-05-15T22:41:34Z",
      "side": 1,
      "message": "\u003e Just revisited the http_connection code — shouldn\u0027t this be handled in afterRead()? We could add a condition to specifically check for bad_message there.\n\nthe connection class isn\u0027t in charge of responses, the router is.  Hardcoding this in http connection would mean that we\u0027d have to hardcode one specific error return, rather than a per-uri error return.\n\nRedfish should respond with a redfish json payload 400 error\nLogin routes should respond with their specific 400 error code.\n\n\u003e \n\u003e From what I understand of the current design, the execution will never reach the update_service handler because afterRead() calls gracefulClose() as soon as any error is encountered.\n\nRight....  this isn\u0027t an \"error\" in the normal sense.  For files and strings the only kind of errors are internal errors the user can do nothing about (ie 500 errors).\n\nThis flow should return a 400 error, that the user could do something about by correcting their response, so the body needs to basically mark that the parse failed, and return that when the specific handler requests the mime data.\n\nThe \"right\" solution would be what we did for 401, which would be to add yet another condition to the routing table, and register a redfish-specific \"400\" handler.  I don\u0027t want to make you do that work for what\u0027s ultimately one URI.\n\n\u003e \n\u003e Please correct me if I’m missing something.",
      "parentUuid": "40237df0_2747b096",
      "range": {
        "startLine": 284,
        "startChar": 0,
        "endLine": 285,
        "endChar": 54
      },
      "revId": "00b923036fac8c34cfe56b97de4de3226a7a6375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d0856448_778972b9",
        "filename": "http/http_body.hpp",
        "patchSetId": 3
      },
      "lineNbr": 285,
      "author": {
        "id": 1002325
      },
      "writtenOn": "2025-05-29T08:27:35Z",
      "side": 1,
      "message": "I\u0027ve handled this in the code, please re-review.",
      "parentUuid": "0ea4942b_17ca5c3f",
      "range": {
        "startLine": 284,
        "startChar": 0,
        "endLine": 285,
        "endChar": 54
      },
      "revId": "00b923036fac8c34cfe56b97de4de3226a7a6375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d01de985_6247fe00",
        "filename": "http/http_body.hpp",
        "patchSetId": 3
      },
      "lineNbr": 290,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-05-12T22:31:44Z",
      "side": 1,
      "message": "Roll this into the above branch.  there\u0027s no case where multipartParser gets set without the above branch running.",
      "revId": "00b923036fac8c34cfe56b97de4de3226a7a6375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "22b7db24_089d80f6",
        "filename": "http/http_body.hpp",
        "patchSetId": 3
      },
      "lineNbr": 290,
      "author": {
        "id": 1002325
      },
      "writtenOn": "2025-05-14T18:59:16Z",
      "side": 1,
      "message": "Agree, I\u0027ll make the change.",
      "parentUuid": "d01de985_6247fe00",
      "revId": "00b923036fac8c34cfe56b97de4de3226a7a6375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ebb04e7f_28c4979c",
        "filename": "http/http_body.hpp",
        "patchSetId": 3
      },
      "lineNbr": 290,
      "author": {
        "id": 1002325
      },
      "writtenOn": "2025-05-29T08:27:35Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "22b7db24_089d80f6",
      "revId": "00b923036fac8c34cfe56b97de4de3226a7a6375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "79346062_bee83783",
        "filename": "include/temporary_releasable_file_handle.hpp",
        "patchSetId": 3
      },
      "lineNbr": 10,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-05-12T22:31:44Z",
      "side": 1,
      "message": "We already have TemporaryFileHandle that fulfills basically this same use case, although might be missing a couple mesthods (that can be added).  Any reason we avoided that?",
      "revId": "00b923036fac8c34cfe56b97de4de3226a7a6375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fd072196_0ededb81",
        "filename": "include/temporary_releasable_file_handle.hpp",
        "patchSetId": 3
      },
      "lineNbr": 10,
      "author": {
        "id": 1002325
      },
      "writtenOn": "2025-05-14T18:49:13Z",
      "side": 1,
      "message": "For multipart uploads we additionally need to - \n1. create a secure temp file (mkstemp)\n2. remember the path so we can rename()/copy it to /tmp/images/\u003cuuid\u003e\n3. auto-unlink the temp file on every failure path.\n\nThese behaviours would change the lifetime rules of the existing class, e.g. a copied handle would suddenly have to agree on who deletes the file, so I\u0027ve added a separate TemporaryReleasableFileHandle to keep the original semantics of DuplicatableFileHandle untouched.",
      "parentUuid": "79346062_bee83783",
      "revId": "00b923036fac8c34cfe56b97de4de3226a7a6375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}