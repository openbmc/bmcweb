{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "877f5a3f_196351a4",
        "filename": "http/http_body.hpp",
        "patchSetId": 3
      },
      "lineNbr": 56,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-05-12T22:31:44Z",
      "side": 1,
      "message": "?",
      "revId": "00b923036fac8c34cfe56b97de4de3226a7a6375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ce4cae26_6ff266f7",
        "filename": "http/http_body.hpp",
        "patchSetId": 3
      },
      "lineNbr": 56,
      "author": {
        "id": 1002325
      },
      "writtenOn": "2025-05-14T18:49:13Z",
      "side": 1,
      "message": "These declarations allow the reader and writer classes to access private members of the value_type class. Reader class directly accesses and modifies mimeFields and Writer class access file related members to read data from file",
      "parentUuid": "877f5a3f_196351a4",
      "revId": "00b923036fac8c34cfe56b97de4de3226a7a6375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "92f964c3_0ce5a407",
        "filename": "http/http_body.hpp",
        "patchSetId": 3
      },
      "lineNbr": 62,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-05-12T22:31:44Z",
      "side": 1,
      "message": "We\u0027re now at the point where we have 3 embedded types here.  Checking fileHandle.is_open() was a relatively easy way to tell which was being used for any given body.  Now that we have a third, I suspect this needs to become a std::variant\u003cstd::string, DuplicatableFileHandle, std::vector\u003cFormPart\u003e\u003e;",
      "range": {
        "startLine": 58,
        "startChar": 0,
        "endLine": 62,
        "endChar": 39
      },
      "revId": "00b923036fac8c34cfe56b97de4de3226a7a6375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "88c13a7d_bd48e811",
        "filename": "http/http_body.hpp",
        "patchSetId": 3
      },
      "lineNbr": 275,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-05-12T22:31:44Z",
      "side": 1,
      "message": "Please fix this check.\n\n1. !multipartParser will always be true when this is called after construction\n2. We have content-type parsers now.  Please use them.\n3. !contentType.empty() is redundant if the next check is comparing starts_with",
      "revId": "00b923036fac8c34cfe56b97de4de3226a7a6375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d03aceeb_12025d3f",
        "filename": "http/http_body.hpp",
        "patchSetId": 3
      },
      "lineNbr": 283,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-05-12T22:31:44Z",
      "side": 1,
      "message": "No need to reset it here.  We\u0027re returning an error, the whole reader object is about to be destroyed.",
      "range": {
        "startLine": 283,
        "startChar": 0,
        "endLine": 283,
        "endChar": 40
      },
      "revId": "00b923036fac8c34cfe56b97de4de3226a7a6375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "81251c02_aa830e59",
        "filename": "http/http_body.hpp",
        "patchSetId": 3
      },
      "lineNbr": 285,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-05-12T22:31:44Z",
      "side": 1,
      "message": "Keep in mind, when we hit parsing errors, we need to be able to return 400 bad request from the handler.  As written, I suspect you want to just set an internal error, that the handler can read back on multipart().",
      "range": {
        "startLine": 284,
        "startChar": 0,
        "endLine": 285,
        "endChar": 54
      },
      "revId": "00b923036fac8c34cfe56b97de4de3226a7a6375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "40237df0_2747b096",
        "filename": "http/http_body.hpp",
        "patchSetId": 3
      },
      "lineNbr": 285,
      "author": {
        "id": 1002325
      },
      "writtenOn": "2025-05-14T18:49:13Z",
      "side": 1,
      "message": "Just revisited the http_connection code — shouldn\u0027t this be handled in afterRead()? We could add a condition to specifically check for bad_message there.\n\nFrom what I understand of the current design, the execution will never reach the update_service handler because afterRead() calls gracefulClose() as soon as any error is encountered.\n\nPlease correct me if I’m missing something.",
      "parentUuid": "81251c02_aa830e59",
      "range": {
        "startLine": 284,
        "startChar": 0,
        "endLine": 285,
        "endChar": 54
      },
      "revId": "00b923036fac8c34cfe56b97de4de3226a7a6375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d01de985_6247fe00",
        "filename": "http/http_body.hpp",
        "patchSetId": 3
      },
      "lineNbr": 290,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-05-12T22:31:44Z",
      "side": 1,
      "message": "Roll this into the above branch.  there\u0027s no case where multipartParser gets set without the above branch running.",
      "revId": "00b923036fac8c34cfe56b97de4de3226a7a6375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "79346062_bee83783",
        "filename": "include/temporary_releasable_file_handle.hpp",
        "patchSetId": 3
      },
      "lineNbr": 10,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-05-12T22:31:44Z",
      "side": 1,
      "message": "We already have TemporaryFileHandle that fulfills basically this same use case, although might be missing a couple mesthods (that can be added).  Any reason we avoided that?",
      "revId": "00b923036fac8c34cfe56b97de4de3226a7a6375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fd072196_0ededb81",
        "filename": "include/temporary_releasable_file_handle.hpp",
        "patchSetId": 3
      },
      "lineNbr": 10,
      "author": {
        "id": 1002325
      },
      "writtenOn": "2025-05-14T18:49:13Z",
      "side": 1,
      "message": "For multipart uploads we additionally need to - \n1. create a secure temp file (mkstemp)\n2. remember the path so we can rename()/copy it to /tmp/images/\u003cuuid\u003e\n3. auto-unlink the temp file on every failure path.\n\nThese behaviours would change the lifetime rules of the existing class, e.g. a copied handle would suddenly have to agree on who deletes the file, so I\u0027ve added a separate TemporaryReleasableFileHandle to keep the original semantics of DuplicatableFileHandle untouched.",
      "parentUuid": "79346062_bee83783",
      "revId": "00b923036fac8c34cfe56b97de4de3226a7a6375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}