{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "ba7e1803_a5459841",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 65
      },
      "lineNbr": 0,
      "author": {
        "id": 1001621
      },
      "writtenOn": "2024-02-01T21:43:11Z",
      "side": 1,
      "message": "Looks good to me.",
      "revId": "3d73c5862a0a64e87ff1f07b468ab7ce91d6af67",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6a3ac97e_7bb3b792",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 65
      },
      "lineNbr": 0,
      "author": {
        "id": 1000020
      },
      "writtenOn": "2024-02-07T04:57:08Z",
      "side": 1,
      "message": "Can this go?",
      "revId": "3d73c5862a0a64e87ff1f07b468ab7ce91d6af67",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7d8302d0_2120a0f6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 65
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-02-07T05:00:04Z",
      "side": 1,
      "message": "Still has bugs, so no, I don\u0027t think it can go.",
      "parentUuid": "6a3ac97e_7bb3b792",
      "revId": "3d73c5862a0a64e87ff1f07b468ab7ce91d6af67",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "268e1910_09b01369",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 65
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-02-07T05:00:04Z",
      "side": 1,
      "message": "s",
      "revId": "3d73c5862a0a64e87ff1f07b468ab7ce91d6af67",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "87dc7f79_05c9e040",
        "filename": "redfish-core/lib/fabric_ports.hpp",
        "patchSetId": 65
      },
      "lineNbr": 41,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-02-07T04:58:55Z",
      "side": 1,
      "message": "Name is rarely the same as the ID.",
      "range": {
        "startLine": 41,
        "startChar": 39,
        "endLine": 41,
        "endChar": 45
      },
      "revId": "3d73c5862a0a64e87ff1f07b468ab7ce91d6af67",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3aaa0ee9_099a26d6",
        "filename": "redfish-core/lib/fabric_ports.hpp",
        "patchSetId": 65
      },
      "lineNbr": 41,
      "author": {
        "id": 1000020
      },
      "writtenOn": "2024-02-07T14:39:24Z",
      "side": 1,
      "message": "It looks like the CPU is just \"Processor.\" Can we just do \"FabricAdapter\" here?\nhttps://github.com/openbmc/bmcweb/blob/master/redfish-core/lib/processor.hpp#L242",
      "parentUuid": "87dc7f79_05c9e040",
      "range": {
        "startLine": 41,
        "startChar": 39,
        "endLine": 41,
        "endChar": 45
      },
      "revId": "3d73c5862a0a64e87ff1f07b468ab7ce91d6af67",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8ce563f8_94d8058d",
        "filename": "redfish-core/lib/fabric_ports.hpp",
        "patchSetId": 65
      },
      "lineNbr": 41,
      "author": {
        "id": 1001604
      },
      "writtenOn": "2024-02-07T16:26:32Z",
      "side": 1,
      "message": "Done.\nI\u0027ve updated it as \"Fabric Port\", and also \"Fabric Port Collection\" for collection.",
      "parentUuid": "3aaa0ee9_099a26d6",
      "range": {
        "startLine": 41,
        "startChar": 39,
        "endLine": 41,
        "endChar": 45
      },
      "revId": "3d73c5862a0a64e87ff1f07b468ab7ce91d6af67",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "108197bf_305c1608",
        "filename": "redfish-core/lib/fabric_ports.hpp",
        "patchSetId": 65
      },
      "lineNbr": 41,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-02-07T18:06:14Z",
      "side": 1,
      "message": "Yep, those are correct (with the spaces).  Name is human readable.",
      "parentUuid": "8ce563f8_94d8058d",
      "range": {
        "startLine": 41,
        "startChar": 39,
        "endLine": 41,
        "endChar": 45
      },
      "revId": "3d73c5862a0a64e87ff1f07b468ab7ce91d6af67",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8ecd952a_7198a980",
        "filename": "redfish-core/lib/fabric_ports.hpp",
        "patchSetId": 65
      },
      "lineNbr": 57,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-02-07T04:58:55Z",
      "side": 1,
      "message": "\u003e     This defines a Port of a switch, controller, chassis, or any other device\n\n\nWhere is the code that checks that the connected device is a FabricAdapter?",
      "range": {
        "startLine": 57,
        "startChar": 30,
        "endLine": 57,
        "endChar": 40
      },
      "revId": "3d73c5862a0a64e87ff1f07b468ab7ce91d6af67",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0dc47d73_6cdeaac4",
        "filename": "redfish-core/lib/fabric_ports.hpp",
        "patchSetId": 65
      },
      "lineNbr": 57,
      "author": {
        "id": 1001604
      },
      "writtenOn": "2024-02-07T13:13:51Z",
      "side": 1,
      "message": "This `getFabricAssociatedPortSubTree()` is called by `getFabricPortSubTree()` which checks the validity of the fabric adapter using `getValidFabricAdapterPath()` in L69-L76.\n\n```\ninline void\n    getFabricPortSubTree(const std::shared_ptr\u003cbmcweb::AsyncResp\u003e\u0026 asyncResp,\n                         const std::string\u0026 systemName,\n                         const std::string\u0026 adapterId, Callback\u0026\u0026 callback)\n{\n    getValidFabricAdapterPath(\n        adapterId, systemName, asyncResp,\n        std::bind_front(getFabricAssociatedPortSubTree, asyncResp,\n                        std::forward\u003cCallback\u003e(callback)));\n}\n```",
      "parentUuid": "8ecd952a_7198a980",
      "range": {
        "startLine": 57,
        "startChar": 30,
        "endLine": 57,
        "endChar": 40
      },
      "revId": "3d73c5862a0a64e87ff1f07b468ab7ce91d6af67",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f5e8c1a3_857c37cb",
        "filename": "redfish-core/lib/fabric_ports.hpp",
        "patchSetId": 65
      },
      "lineNbr": 131,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-02-07T04:58:55Z",
      "side": 1,
      "message": "nullptr dereference.  if portIter-\u003esecond.empty()",
      "range": {
        "startLine": 131,
        "startChar": 54,
        "endLine": 131,
        "endChar": 56
      },
      "revId": "3d73c5862a0a64e87ff1f07b468ab7ce91d6af67",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4c0f0eba_efe1a553",
        "filename": "redfish-core/lib/fabric_ports.hpp",
        "patchSetId": 65
      },
      "lineNbr": 131,
      "author": {
        "id": 1001604
      },
      "writtenOn": "2024-02-07T13:13:51Z",
      "side": 1,
      "message": "This `portIter-\u003esecond` is the service names for Port.\nIs it possible to have an empty service for the obtained subtree element? \n\nIn bmcweb, many other places are doing like this.\nhttps://github.com/openbmc/bmcweb/blob/aaf08ac7cd355341499453fc8677c2976a4e5464/redfish-core/lib/systems.hpp#L2805",
      "parentUuid": "f5e8c1a3_857c37cb",
      "range": {
        "startLine": 131,
        "startChar": 54,
        "endLine": 131,
        "endChar": 56
      },
      "revId": "3d73c5862a0a64e87ff1f07b468ab7ce91d6af67",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4f48d505_c44db5df",
        "filename": "redfish-core/lib/fabric_ports.hpp",
        "patchSetId": 65
      },
      "lineNbr": 131,
      "author": {
        "id": 1001604
      },
      "writtenOn": "2024-02-07T16:26:32Z",
      "side": 1,
      "message": "Done.\nI\u0027ve added the checks for both `first.empty()` and `second.empty()`.",
      "parentUuid": "4c0f0eba_efe1a553",
      "range": {
        "startLine": 131,
        "startChar": 54,
        "endLine": 131,
        "endChar": 56
      },
      "revId": "3d73c5862a0a64e87ff1f07b468ab7ce91d6af67",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "02c08afb_8b7dc1e1",
        "filename": "redfish-core/lib/fabric_ports.hpp",
        "patchSetId": 65
      },
      "lineNbr": 296,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-02-07T04:58:55Z",
      "side": 1,
      "message": "The flow here needs to be:\n\nFind the port that matches the name of this entry.\nVerify that the port is connected to the expected FabricAdapter.",
      "range": {
        "startLine": 296,
        "startChar": 4,
        "endLine": 296,
        "endChar": 29
      },
      "revId": "3d73c5862a0a64e87ff1f07b468ab7ce91d6af67",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fb86fed5_60273973",
        "filename": "redfish-core/lib/fabric_ports.hpp",
        "patchSetId": 65
      },
      "lineNbr": 296,
      "author": {
        "id": 1001604
      },
      "writtenOn": "2024-02-07T13:13:51Z",
      "side": 1,
      "message": "I think this has been discussed in the previous comments/responses.\n\nPort can also be associated for the other types - e.g. Network etc.\n\nSo, assuming bmcweb implements port for the other types in addition to FabricAdapter, if we find the matching Ports first, the associated endpoints potentially may be the mix of the different inventory types (besides FabricAdapter) if port name happens to be same.   This could result in the multiple dbus calls to verify the endpoints (additional calls per each matching port).\n\nHowever, if we search fabric adapter first (using the given input `adapterId`), all associated ports to the fabric adapters will be returned using `getAssociatedSubtree()` without needing any more dbus calls.",
      "parentUuid": "02c08afb_8b7dc1e1",
      "range": {
        "startLine": 296,
        "startChar": 4,
        "endLine": 296,
        "endChar": 29
      },
      "revId": "3d73c5862a0a64e87ff1f07b468ab7ce91d6af67",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c2ab19e2_cbdeb38d",
        "filename": "redfish-core/lib/fabric_ports.hpp",
        "patchSetId": 65
      },
      "lineNbr": 296,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-02-07T22:14:08Z",
      "side": 1,
      "message": "\u003e I think this has been discussed in the previous comments/responses.\n\u003e \n\u003e Port can also be associated for the other types - e.g. Network etc.\n\u003e \n\u003e So, assuming bmcweb implements port for the other types in addition to FabricAdapter, if we find the matching Ports first, the associated endpoints potentially may be the mix of the different inventory types (besides FabricAdapter) if port name happens to be same.\n\nRight, but that can happen regardless, you need to verify that the thing attached to the other end of the association matches the type you expect.  I suspect that given the change a year ago to non-type specific associations we need another mapper call added that can answer:\n\n\"Find me the entries with type X associated with type Y on association connected_by\"\n\nPutting all this logic in bmcweb and doing a triple tiered mapper call is complexity that we can\u0027t really handle in bmcweb, as we start getting into business logic.\n\n\u003e   This could result in the multiple dbus calls to verify the endpoints (additional calls per each matching port).\n\u003e \n\u003e However, if we search fabric adapter first (using the given input `adapterId`), all associated ports to the fabric adapters will be returned using `getAssociatedSubtree()` without needing any more dbus calls.\n\nWe still have multiple dbus calls though?",
      "parentUuid": "fb86fed5_60273973",
      "range": {
        "startLine": 296,
        "startChar": 4,
        "endLine": 296,
        "endChar": 29
      },
      "revId": "3d73c5862a0a64e87ff1f07b468ab7ce91d6af67",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e1bcd091_c3459636",
        "filename": "redfish-core/lib/fabric_ports.hpp",
        "patchSetId": 65
      },
      "lineNbr": 296,
      "author": {
        "id": 1001604
      },
      "writtenOn": "2024-02-08T15:41:49Z",
      "side": 1,
      "message": "Here, the query is to get ports of the given/specific adapter (e.g. `disk_backplane0`), not all ports in the system.\n\n```\ncurl -k -X GET https://${bmc}:18080/redfish/v1/Systems/system/FabricAdapters/disk_backplane0/Ports\n```\n\n\nApproach A)\n\nSo, the logic flow (by `getValidFabricPortSubTree()`) here is\n1) validate the give adapter (`disk_backplane0`) where is it a valid fabric adapter using `getValidFabricAdapterPath()`.  \n\n2) With the validate fabric adapter, the find ports (with the type of `Connector.Port`) that are associated by \u0027connecting\u0027 with the fabric adapter (`disk_backplane0`) in `getFabricAssociatedPortSubTree()`\n\n```\ngetFabricAssociatedPortSubTree()\n{\n\n    dbus::utility::getAssociatedSubTree(\n        fabricAdapterPath + \"/connecting\", \n        ...\n}\n```\nThis will return all valid ports of type `Connector.Port` that are associated by `connecting` for the given fabric adapter.  We don\u0027t need to validate each port\u0027s type again as they are already valid.\n\n---\n\nApproach B)\n\nHowever, if we do the other way arounds like\n1) find all ports with the types of \u0027Connector.Port\u0027.  This may return the the mix of the ports that may be associated with the other types (e.g. Network).\n\n2) Then, for each port, we need to call \u0027getAssociatedSubTreePaths()` using `connected_to` for FabricAdapter.\n\n- For example, if (1) returns N items, the step (2) will invoke `getAssociatedSubTreePaths()\u0027  N times.\n\n```\n     for(port : subtreepaths)\n     {\n         getAssociatedSubTreePaths( .. port + \"/connected_to\", )\n     }\n```\n\n---\n\nI think Approach (A) is correct and more efficient than (B).\nIt is because the query is for the already-scoped input (e.g. given adapter).",
      "parentUuid": "c2ab19e2_cbdeb38d",
      "range": {
        "startLine": 296,
        "startChar": 4,
        "endLine": 296,
        "endChar": 29
      },
      "revId": "3d73c5862a0a64e87ff1f07b468ab7ce91d6af67",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}